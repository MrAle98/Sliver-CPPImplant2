// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sliver.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sliver_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sliver_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sliver_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sliver_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sliver_2eproto;
namespace sliverpb {
class Backdoor;
struct BackdoorDefaultTypeInternal;
extern BackdoorDefaultTypeInternal _Backdoor_default_instance_;
class BackdoorReq;
struct BackdoorReqDefaultTypeInternal;
extern BackdoorReqDefaultTypeInternal _BackdoorReq_default_instance_;
class BeaconRegister;
struct BeaconRegisterDefaultTypeInternal;
extern BeaconRegisterDefaultTypeInternal _BeaconRegister_default_instance_;
class BeaconTasks;
struct BeaconTasksDefaultTypeInternal;
extern BeaconTasksDefaultTypeInternal _BeaconTasks_default_instance_;
class CallExtension;
struct CallExtensionDefaultTypeInternal;
extern CallExtensionDefaultTypeInternal _CallExtension_default_instance_;
class CallExtensionReq;
struct CallExtensionReqDefaultTypeInternal;
extern CallExtensionReqDefaultTypeInternal _CallExtensionReq_default_instance_;
class CdReq;
struct CdReqDefaultTypeInternal;
extern CdReqDefaultTypeInternal _CdReq_default_instance_;
class CloseSession;
struct CloseSessionDefaultTypeInternal;
extern CloseSessionDefaultTypeInternal _CloseSession_default_instance_;
class CurrentTokenOwner;
struct CurrentTokenOwnerDefaultTypeInternal;
extern CurrentTokenOwnerDefaultTypeInternal _CurrentTokenOwner_default_instance_;
class CurrentTokenOwnerReq;
struct CurrentTokenOwnerReqDefaultTypeInternal;
extern CurrentTokenOwnerReqDefaultTypeInternal _CurrentTokenOwnerReq_default_instance_;
class DNSBlockHeader;
struct DNSBlockHeaderDefaultTypeInternal;
extern DNSBlockHeaderDefaultTypeInternal _DNSBlockHeader_default_instance_;
class DNSPoll;
struct DNSPollDefaultTypeInternal;
extern DNSPollDefaultTypeInternal _DNSPoll_default_instance_;
class DNSSessionInit;
struct DNSSessionInitDefaultTypeInternal;
extern DNSSessionInitDefaultTypeInternal _DNSSessionInit_default_instance_;
class Download;
struct DownloadDefaultTypeInternal;
extern DownloadDefaultTypeInternal _Download_default_instance_;
class DownloadReq;
struct DownloadReqDefaultTypeInternal;
extern DownloadReqDefaultTypeInternal _DownloadReq_default_instance_;
class EnvInfo;
struct EnvInfoDefaultTypeInternal;
extern EnvInfoDefaultTypeInternal _EnvInfo_default_instance_;
class EnvReq;
struct EnvReqDefaultTypeInternal;
extern EnvReqDefaultTypeInternal _EnvReq_default_instance_;
class Envelope;
struct EnvelopeDefaultTypeInternal;
extern EnvelopeDefaultTypeInternal _Envelope_default_instance_;
class Execute;
struct ExecuteDefaultTypeInternal;
extern ExecuteDefaultTypeInternal _Execute_default_instance_;
class ExecuteAssembly;
struct ExecuteAssemblyDefaultTypeInternal;
extern ExecuteAssemblyDefaultTypeInternal _ExecuteAssembly_default_instance_;
class ExecuteAssemblyReq;
struct ExecuteAssemblyReqDefaultTypeInternal;
extern ExecuteAssemblyReqDefaultTypeInternal _ExecuteAssemblyReq_default_instance_;
class ExecuteReq;
struct ExecuteReqDefaultTypeInternal;
extern ExecuteReqDefaultTypeInternal _ExecuteReq_default_instance_;
class ExecuteWindowsReq;
struct ExecuteWindowsReqDefaultTypeInternal;
extern ExecuteWindowsReqDefaultTypeInternal _ExecuteWindowsReq_default_instance_;
class FileInfo;
struct FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
class GetPrivs;
struct GetPrivsDefaultTypeInternal;
extern GetPrivsDefaultTypeInternal _GetPrivs_default_instance_;
class GetPrivsReq;
struct GetPrivsReqDefaultTypeInternal;
extern GetPrivsReqDefaultTypeInternal _GetPrivsReq_default_instance_;
class GetSystem;
struct GetSystemDefaultTypeInternal;
extern GetSystemDefaultTypeInternal _GetSystem_default_instance_;
class HTTPSessionInit;
struct HTTPSessionInitDefaultTypeInternal;
extern HTTPSessionInitDefaultTypeInternal _HTTPSessionInit_default_instance_;
class Ifconfig;
struct IfconfigDefaultTypeInternal;
extern IfconfigDefaultTypeInternal _Ifconfig_default_instance_;
class IfconfigReq;
struct IfconfigReqDefaultTypeInternal;
extern IfconfigReqDefaultTypeInternal _IfconfigReq_default_instance_;
class Impersonate;
struct ImpersonateDefaultTypeInternal;
extern ImpersonateDefaultTypeInternal _Impersonate_default_instance_;
class ImpersonateReq;
struct ImpersonateReqDefaultTypeInternal;
extern ImpersonateReqDefaultTypeInternal _ImpersonateReq_default_instance_;
class InvokeExecuteAssemblyReq;
struct InvokeExecuteAssemblyReqDefaultTypeInternal;
extern InvokeExecuteAssemblyReqDefaultTypeInternal _InvokeExecuteAssemblyReq_default_instance_;
class InvokeGetSystemReq;
struct InvokeGetSystemReqDefaultTypeInternal;
extern InvokeGetSystemReqDefaultTypeInternal _InvokeGetSystemReq_default_instance_;
class InvokeInProcExecuteAssemblyReq;
struct InvokeInProcExecuteAssemblyReqDefaultTypeInternal;
extern InvokeInProcExecuteAssemblyReqDefaultTypeInternal _InvokeInProcExecuteAssemblyReq_default_instance_;
class InvokeMigrateReq;
struct InvokeMigrateReqDefaultTypeInternal;
extern InvokeMigrateReqDefaultTypeInternal _InvokeMigrateReq_default_instance_;
class InvokeSpawnDllReq;
struct InvokeSpawnDllReqDefaultTypeInternal;
extern InvokeSpawnDllReqDefaultTypeInternal _InvokeSpawnDllReq_default_instance_;
class KillReq;
struct KillReqDefaultTypeInternal;
extern KillReqDefaultTypeInternal _KillReq_default_instance_;
class ListExtensions;
struct ListExtensionsDefaultTypeInternal;
extern ListExtensionsDefaultTypeInternal _ListExtensions_default_instance_;
class ListExtensionsReq;
struct ListExtensionsReqDefaultTypeInternal;
extern ListExtensionsReqDefaultTypeInternal _ListExtensionsReq_default_instance_;
class ListTokens;
struct ListTokensDefaultTypeInternal;
extern ListTokensDefaultTypeInternal _ListTokens_default_instance_;
class ListTokensReq;
struct ListTokensReqDefaultTypeInternal;
extern ListTokensReqDefaultTypeInternal _ListTokensReq_default_instance_;
class Ls;
struct LsDefaultTypeInternal;
extern LsDefaultTypeInternal _Ls_default_instance_;
class LsReq;
struct LsReqDefaultTypeInternal;
extern LsReqDefaultTypeInternal _LsReq_default_instance_;
class MakeToken;
struct MakeTokenDefaultTypeInternal;
extern MakeTokenDefaultTypeInternal _MakeToken_default_instance_;
class MakeTokenReq;
struct MakeTokenReqDefaultTypeInternal;
extern MakeTokenReqDefaultTypeInternal _MakeTokenReq_default_instance_;
class Migrate;
struct MigrateDefaultTypeInternal;
extern MigrateDefaultTypeInternal _Migrate_default_instance_;
class Mkdir;
struct MkdirDefaultTypeInternal;
extern MkdirDefaultTypeInternal _Mkdir_default_instance_;
class MkdirReq;
struct MkdirReqDefaultTypeInternal;
extern MkdirReqDefaultTypeInternal _MkdirReq_default_instance_;
class Mv;
struct MvDefaultTypeInternal;
extern MvDefaultTypeInternal _Mv_default_instance_;
class MvReq;
struct MvReqDefaultTypeInternal;
extern MvReqDefaultTypeInternal _MvReq_default_instance_;
class NetConnPivot;
struct NetConnPivotDefaultTypeInternal;
extern NetConnPivotDefaultTypeInternal _NetConnPivot_default_instance_;
class NetInterface;
struct NetInterfaceDefaultTypeInternal;
extern NetInterfaceDefaultTypeInternal _NetInterface_default_instance_;
class Netstat;
struct NetstatDefaultTypeInternal;
extern NetstatDefaultTypeInternal _Netstat_default_instance_;
class NetstatReq;
struct NetstatReqDefaultTypeInternal;
extern NetstatReqDefaultTypeInternal _NetstatReq_default_instance_;
class OpenSession;
struct OpenSessionDefaultTypeInternal;
extern OpenSessionDefaultTypeInternal _OpenSession_default_instance_;
class Ping;
struct PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class PivotHello;
struct PivotHelloDefaultTypeInternal;
extern PivotHelloDefaultTypeInternal _PivotHello_default_instance_;
class PivotListener;
struct PivotListenerDefaultTypeInternal;
extern PivotListenerDefaultTypeInternal _PivotListener_default_instance_;
class PivotListeners;
struct PivotListenersDefaultTypeInternal;
extern PivotListenersDefaultTypeInternal _PivotListeners_default_instance_;
class PivotListenersReq;
struct PivotListenersReqDefaultTypeInternal;
extern PivotListenersReqDefaultTypeInternal _PivotListenersReq_default_instance_;
class PivotPeer;
struct PivotPeerDefaultTypeInternal;
extern PivotPeerDefaultTypeInternal _PivotPeer_default_instance_;
class PivotPeerEnvelope;
struct PivotPeerEnvelopeDefaultTypeInternal;
extern PivotPeerEnvelopeDefaultTypeInternal _PivotPeerEnvelope_default_instance_;
class PivotPeerFailure;
struct PivotPeerFailureDefaultTypeInternal;
extern PivotPeerFailureDefaultTypeInternal _PivotPeerFailure_default_instance_;
class PivotPing;
struct PivotPingDefaultTypeInternal;
extern PivotPingDefaultTypeInternal _PivotPing_default_instance_;
class PivotServerKeyExchange;
struct PivotServerKeyExchangeDefaultTypeInternal;
extern PivotServerKeyExchangeDefaultTypeInternal _PivotServerKeyExchange_default_instance_;
class PivotStartListenerReq;
struct PivotStartListenerReqDefaultTypeInternal;
extern PivotStartListenerReqDefaultTypeInternal _PivotStartListenerReq_default_instance_;
class PivotStopListenerReq;
struct PivotStopListenerReqDefaultTypeInternal;
extern PivotStopListenerReqDefaultTypeInternal _PivotStopListenerReq_default_instance_;
class PollInterval;
struct PollIntervalDefaultTypeInternal;
extern PollIntervalDefaultTypeInternal _PollInterval_default_instance_;
class PollIntervalReq;
struct PollIntervalReqDefaultTypeInternal;
extern PollIntervalReqDefaultTypeInternal _PollIntervalReq_default_instance_;
class Portfwd;
struct PortfwdDefaultTypeInternal;
extern PortfwdDefaultTypeInternal _Portfwd_default_instance_;
class PortfwdReq;
struct PortfwdReqDefaultTypeInternal;
extern PortfwdReqDefaultTypeInternal _PortfwdReq_default_instance_;
class ProcessDump;
struct ProcessDumpDefaultTypeInternal;
extern ProcessDumpDefaultTypeInternal _ProcessDump_default_instance_;
class ProcessDumpReq;
struct ProcessDumpReqDefaultTypeInternal;
extern ProcessDumpReqDefaultTypeInternal _ProcessDumpReq_default_instance_;
class Ps;
struct PsDefaultTypeInternal;
extern PsDefaultTypeInternal _Ps_default_instance_;
class PsReq;
struct PsReqDefaultTypeInternal;
extern PsReqDefaultTypeInternal _PsReq_default_instance_;
class Pwd;
struct PwdDefaultTypeInternal;
extern PwdDefaultTypeInternal _Pwd_default_instance_;
class PwdReq;
struct PwdReqDefaultTypeInternal;
extern PwdReqDefaultTypeInternal _PwdReq_default_instance_;
class RPortfwd;
struct RPortfwdDefaultTypeInternal;
extern RPortfwdDefaultTypeInternal _RPortfwd_default_instance_;
class RPortfwdReq;
struct RPortfwdReqDefaultTypeInternal;
extern RPortfwdReqDefaultTypeInternal _RPortfwdReq_default_instance_;
class Reconfigure;
struct ReconfigureDefaultTypeInternal;
extern ReconfigureDefaultTypeInternal _Reconfigure_default_instance_;
class ReconfigureReq;
struct ReconfigureReqDefaultTypeInternal;
extern ReconfigureReqDefaultTypeInternal _ReconfigureReq_default_instance_;
class Register;
struct RegisterDefaultTypeInternal;
extern RegisterDefaultTypeInternal _Register_default_instance_;
class RegisterExtension;
struct RegisterExtensionDefaultTypeInternal;
extern RegisterExtensionDefaultTypeInternal _RegisterExtension_default_instance_;
class RegisterExtensionReq;
struct RegisterExtensionReqDefaultTypeInternal;
extern RegisterExtensionReqDefaultTypeInternal _RegisterExtensionReq_default_instance_;
class RegistryCreateKey;
struct RegistryCreateKeyDefaultTypeInternal;
extern RegistryCreateKeyDefaultTypeInternal _RegistryCreateKey_default_instance_;
class RegistryCreateKeyReq;
struct RegistryCreateKeyReqDefaultTypeInternal;
extern RegistryCreateKeyReqDefaultTypeInternal _RegistryCreateKeyReq_default_instance_;
class RegistryDeleteKey;
struct RegistryDeleteKeyDefaultTypeInternal;
extern RegistryDeleteKeyDefaultTypeInternal _RegistryDeleteKey_default_instance_;
class RegistryDeleteKeyReq;
struct RegistryDeleteKeyReqDefaultTypeInternal;
extern RegistryDeleteKeyReqDefaultTypeInternal _RegistryDeleteKeyReq_default_instance_;
class RegistryListValuesReq;
struct RegistryListValuesReqDefaultTypeInternal;
extern RegistryListValuesReqDefaultTypeInternal _RegistryListValuesReq_default_instance_;
class RegistryRead;
struct RegistryReadDefaultTypeInternal;
extern RegistryReadDefaultTypeInternal _RegistryRead_default_instance_;
class RegistryReadReq;
struct RegistryReadReqDefaultTypeInternal;
extern RegistryReadReqDefaultTypeInternal _RegistryReadReq_default_instance_;
class RegistrySubKeyList;
struct RegistrySubKeyListDefaultTypeInternal;
extern RegistrySubKeyListDefaultTypeInternal _RegistrySubKeyList_default_instance_;
class RegistrySubKeyListReq;
struct RegistrySubKeyListReqDefaultTypeInternal;
extern RegistrySubKeyListReqDefaultTypeInternal _RegistrySubKeyListReq_default_instance_;
class RegistryValuesList;
struct RegistryValuesListDefaultTypeInternal;
extern RegistryValuesListDefaultTypeInternal _RegistryValuesList_default_instance_;
class RegistryWrite;
struct RegistryWriteDefaultTypeInternal;
extern RegistryWriteDefaultTypeInternal _RegistryWrite_default_instance_;
class RegistryWriteReq;
struct RegistryWriteReqDefaultTypeInternal;
extern RegistryWriteReqDefaultTypeInternal _RegistryWriteReq_default_instance_;
class RemoveServiceReq;
struct RemoveServiceReqDefaultTypeInternal;
extern RemoveServiceReqDefaultTypeInternal _RemoveServiceReq_default_instance_;
class RevToSelf;
struct RevToSelfDefaultTypeInternal;
extern RevToSelfDefaultTypeInternal _RevToSelf_default_instance_;
class RevToSelfReq;
struct RevToSelfReqDefaultTypeInternal;
extern RevToSelfReqDefaultTypeInternal _RevToSelfReq_default_instance_;
class Rm;
struct RmDefaultTypeInternal;
extern RmDefaultTypeInternal _Rm_default_instance_;
class RmReq;
struct RmReqDefaultTypeInternal;
extern RmReqDefaultTypeInternal _RmReq_default_instance_;
class RportFwdListener;
struct RportFwdListenerDefaultTypeInternal;
extern RportFwdListenerDefaultTypeInternal _RportFwdListener_default_instance_;
class RportFwdListeners;
struct RportFwdListenersDefaultTypeInternal;
extern RportFwdListenersDefaultTypeInternal _RportFwdListeners_default_instance_;
class RportFwdListenersReq;
struct RportFwdListenersReqDefaultTypeInternal;
extern RportFwdListenersReqDefaultTypeInternal _RportFwdListenersReq_default_instance_;
class RportFwdStartListenerReq;
struct RportFwdStartListenerReqDefaultTypeInternal;
extern RportFwdStartListenerReqDefaultTypeInternal _RportFwdStartListenerReq_default_instance_;
class RportFwdStopListenerReq;
struct RportFwdStopListenerReqDefaultTypeInternal;
extern RportFwdStopListenerReqDefaultTypeInternal _RportFwdStopListenerReq_default_instance_;
class RunAs;
struct RunAsDefaultTypeInternal;
extern RunAsDefaultTypeInternal _RunAs_default_instance_;
class RunAsReq;
struct RunAsReqDefaultTypeInternal;
extern RunAsReqDefaultTypeInternal _RunAsReq_default_instance_;
class SSHCommand;
struct SSHCommandDefaultTypeInternal;
extern SSHCommandDefaultTypeInternal _SSHCommand_default_instance_;
class SSHCommandReq;
struct SSHCommandReqDefaultTypeInternal;
extern SSHCommandReqDefaultTypeInternal _SSHCommandReq_default_instance_;
class Screenshot;
struct ScreenshotDefaultTypeInternal;
extern ScreenshotDefaultTypeInternal _Screenshot_default_instance_;
class ScreenshotReq;
struct ScreenshotReqDefaultTypeInternal;
extern ScreenshotReqDefaultTypeInternal _ScreenshotReq_default_instance_;
class ServiceInfo;
struct ServiceInfoDefaultTypeInternal;
extern ServiceInfoDefaultTypeInternal _ServiceInfo_default_instance_;
class ServiceInfoReq;
struct ServiceInfoReqDefaultTypeInternal;
extern ServiceInfoReqDefaultTypeInternal _ServiceInfoReq_default_instance_;
class SessionRegister;
struct SessionRegisterDefaultTypeInternal;
extern SessionRegisterDefaultTypeInternal _SessionRegister_default_instance_;
class SetEnv;
struct SetEnvDefaultTypeInternal;
extern SetEnvDefaultTypeInternal _SetEnv_default_instance_;
class SetEnvReq;
struct SetEnvReqDefaultTypeInternal;
extern SetEnvReqDefaultTypeInternal _SetEnvReq_default_instance_;
class Shell;
struct ShellDefaultTypeInternal;
extern ShellDefaultTypeInternal _Shell_default_instance_;
class ShellReq;
struct ShellReqDefaultTypeInternal;
extern ShellReqDefaultTypeInternal _ShellReq_default_instance_;
class Sideload;
struct SideloadDefaultTypeInternal;
extern SideloadDefaultTypeInternal _Sideload_default_instance_;
class SideloadReq;
struct SideloadReqDefaultTypeInternal;
extern SideloadReqDefaultTypeInternal _SideloadReq_default_instance_;
class SockTabEntry;
struct SockTabEntryDefaultTypeInternal;
extern SockTabEntryDefaultTypeInternal _SockTabEntry_default_instance_;
class SockTabEntry_SockAddr;
struct SockTabEntry_SockAddrDefaultTypeInternal;
extern SockTabEntry_SockAddrDefaultTypeInternal _SockTabEntry_SockAddr_default_instance_;
class Socks;
struct SocksDefaultTypeInternal;
extern SocksDefaultTypeInternal _Socks_default_instance_;
class SocksData;
struct SocksDataDefaultTypeInternal;
extern SocksDataDefaultTypeInternal _SocksData_default_instance_;
class SpawnDll;
struct SpawnDllDefaultTypeInternal;
extern SpawnDllDefaultTypeInternal _SpawnDll_default_instance_;
class SpawnDllReq;
struct SpawnDllReqDefaultTypeInternal;
extern SpawnDllReqDefaultTypeInternal _SpawnDllReq_default_instance_;
class StartServiceReq;
struct StartServiceReqDefaultTypeInternal;
extern StartServiceReqDefaultTypeInternal _StartServiceReq_default_instance_;
class StopServiceReq;
struct StopServiceReqDefaultTypeInternal;
extern StopServiceReqDefaultTypeInternal _StopServiceReq_default_instance_;
class Task;
struct TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class TaskReq;
struct TaskReqDefaultTypeInternal;
extern TaskReqDefaultTypeInternal _TaskReq_default_instance_;
class Terminate;
struct TerminateDefaultTypeInternal;
extern TerminateDefaultTypeInternal _Terminate_default_instance_;
class TerminateReq;
struct TerminateReqDefaultTypeInternal;
extern TerminateReqDefaultTypeInternal _TerminateReq_default_instance_;
class Token;
struct TokenDefaultTypeInternal;
extern TokenDefaultTypeInternal _Token_default_instance_;
class Tunnel;
struct TunnelDefaultTypeInternal;
extern TunnelDefaultTypeInternal _Tunnel_default_instance_;
class TunnelData;
struct TunnelDataDefaultTypeInternal;
extern TunnelDataDefaultTypeInternal _TunnelData_default_instance_;
class UnsetEnv;
struct UnsetEnvDefaultTypeInternal;
extern UnsetEnvDefaultTypeInternal _UnsetEnv_default_instance_;
class UnsetEnvReq;
struct UnsetEnvReqDefaultTypeInternal;
extern UnsetEnvReqDefaultTypeInternal _UnsetEnvReq_default_instance_;
class Upload;
struct UploadDefaultTypeInternal;
extern UploadDefaultTypeInternal _Upload_default_instance_;
class UploadReq;
struct UploadReqDefaultTypeInternal;
extern UploadReqDefaultTypeInternal _UploadReq_default_instance_;
class WGPortForward;
struct WGPortForwardDefaultTypeInternal;
extern WGPortForwardDefaultTypeInternal _WGPortForward_default_instance_;
class WGPortForwardStartReq;
struct WGPortForwardStartReqDefaultTypeInternal;
extern WGPortForwardStartReqDefaultTypeInternal _WGPortForwardStartReq_default_instance_;
class WGPortForwardStopReq;
struct WGPortForwardStopReqDefaultTypeInternal;
extern WGPortForwardStopReqDefaultTypeInternal _WGPortForwardStopReq_default_instance_;
class WGSocks;
struct WGSocksDefaultTypeInternal;
extern WGSocksDefaultTypeInternal _WGSocks_default_instance_;
class WGSocksServer;
struct WGSocksServerDefaultTypeInternal;
extern WGSocksServerDefaultTypeInternal _WGSocksServer_default_instance_;
class WGSocksServers;
struct WGSocksServersDefaultTypeInternal;
extern WGSocksServersDefaultTypeInternal _WGSocksServers_default_instance_;
class WGSocksServersReq;
struct WGSocksServersReqDefaultTypeInternal;
extern WGSocksServersReqDefaultTypeInternal _WGSocksServersReq_default_instance_;
class WGSocksStartReq;
struct WGSocksStartReqDefaultTypeInternal;
extern WGSocksStartReqDefaultTypeInternal _WGSocksStartReq_default_instance_;
class WGSocksStopReq;
struct WGSocksStopReqDefaultTypeInternal;
extern WGSocksStopReqDefaultTypeInternal _WGSocksStopReq_default_instance_;
class WGTCPForwarder;
struct WGTCPForwarderDefaultTypeInternal;
extern WGTCPForwarderDefaultTypeInternal _WGTCPForwarder_default_instance_;
class WGTCPForwarders;
struct WGTCPForwardersDefaultTypeInternal;
extern WGTCPForwardersDefaultTypeInternal _WGTCPForwarders_default_instance_;
class WGTCPForwardersReq;
struct WGTCPForwardersReqDefaultTypeInternal;
extern WGTCPForwardersReqDefaultTypeInternal _WGTCPForwardersReq_default_instance_;
class WindowsPrivilegeEntry;
struct WindowsPrivilegeEntryDefaultTypeInternal;
extern WindowsPrivilegeEntryDefaultTypeInternal _WindowsPrivilegeEntry_default_instance_;
}  // namespace sliverpb
PROTOBUF_NAMESPACE_OPEN
template<> ::sliverpb::Backdoor* Arena::CreateMaybeMessage<::sliverpb::Backdoor>(Arena*);
template<> ::sliverpb::BackdoorReq* Arena::CreateMaybeMessage<::sliverpb::BackdoorReq>(Arena*);
template<> ::sliverpb::BeaconRegister* Arena::CreateMaybeMessage<::sliverpb::BeaconRegister>(Arena*);
template<> ::sliverpb::BeaconTasks* Arena::CreateMaybeMessage<::sliverpb::BeaconTasks>(Arena*);
template<> ::sliverpb::CallExtension* Arena::CreateMaybeMessage<::sliverpb::CallExtension>(Arena*);
template<> ::sliverpb::CallExtensionReq* Arena::CreateMaybeMessage<::sliverpb::CallExtensionReq>(Arena*);
template<> ::sliverpb::CdReq* Arena::CreateMaybeMessage<::sliverpb::CdReq>(Arena*);
template<> ::sliverpb::CloseSession* Arena::CreateMaybeMessage<::sliverpb::CloseSession>(Arena*);
template<> ::sliverpb::CurrentTokenOwner* Arena::CreateMaybeMessage<::sliverpb::CurrentTokenOwner>(Arena*);
template<> ::sliverpb::CurrentTokenOwnerReq* Arena::CreateMaybeMessage<::sliverpb::CurrentTokenOwnerReq>(Arena*);
template<> ::sliverpb::DNSBlockHeader* Arena::CreateMaybeMessage<::sliverpb::DNSBlockHeader>(Arena*);
template<> ::sliverpb::DNSPoll* Arena::CreateMaybeMessage<::sliverpb::DNSPoll>(Arena*);
template<> ::sliverpb::DNSSessionInit* Arena::CreateMaybeMessage<::sliverpb::DNSSessionInit>(Arena*);
template<> ::sliverpb::Download* Arena::CreateMaybeMessage<::sliverpb::Download>(Arena*);
template<> ::sliverpb::DownloadReq* Arena::CreateMaybeMessage<::sliverpb::DownloadReq>(Arena*);
template<> ::sliverpb::EnvInfo* Arena::CreateMaybeMessage<::sliverpb::EnvInfo>(Arena*);
template<> ::sliverpb::EnvReq* Arena::CreateMaybeMessage<::sliverpb::EnvReq>(Arena*);
template<> ::sliverpb::Envelope* Arena::CreateMaybeMessage<::sliverpb::Envelope>(Arena*);
template<> ::sliverpb::Execute* Arena::CreateMaybeMessage<::sliverpb::Execute>(Arena*);
template<> ::sliverpb::ExecuteAssembly* Arena::CreateMaybeMessage<::sliverpb::ExecuteAssembly>(Arena*);
template<> ::sliverpb::ExecuteAssemblyReq* Arena::CreateMaybeMessage<::sliverpb::ExecuteAssemblyReq>(Arena*);
template<> ::sliverpb::ExecuteReq* Arena::CreateMaybeMessage<::sliverpb::ExecuteReq>(Arena*);
template<> ::sliverpb::ExecuteWindowsReq* Arena::CreateMaybeMessage<::sliverpb::ExecuteWindowsReq>(Arena*);
template<> ::sliverpb::FileInfo* Arena::CreateMaybeMessage<::sliverpb::FileInfo>(Arena*);
template<> ::sliverpb::GetPrivs* Arena::CreateMaybeMessage<::sliverpb::GetPrivs>(Arena*);
template<> ::sliverpb::GetPrivsReq* Arena::CreateMaybeMessage<::sliverpb::GetPrivsReq>(Arena*);
template<> ::sliverpb::GetSystem* Arena::CreateMaybeMessage<::sliverpb::GetSystem>(Arena*);
template<> ::sliverpb::HTTPSessionInit* Arena::CreateMaybeMessage<::sliverpb::HTTPSessionInit>(Arena*);
template<> ::sliverpb::Ifconfig* Arena::CreateMaybeMessage<::sliverpb::Ifconfig>(Arena*);
template<> ::sliverpb::IfconfigReq* Arena::CreateMaybeMessage<::sliverpb::IfconfigReq>(Arena*);
template<> ::sliverpb::Impersonate* Arena::CreateMaybeMessage<::sliverpb::Impersonate>(Arena*);
template<> ::sliverpb::ImpersonateReq* Arena::CreateMaybeMessage<::sliverpb::ImpersonateReq>(Arena*);
template<> ::sliverpb::InvokeExecuteAssemblyReq* Arena::CreateMaybeMessage<::sliverpb::InvokeExecuteAssemblyReq>(Arena*);
template<> ::sliverpb::InvokeGetSystemReq* Arena::CreateMaybeMessage<::sliverpb::InvokeGetSystemReq>(Arena*);
template<> ::sliverpb::InvokeInProcExecuteAssemblyReq* Arena::CreateMaybeMessage<::sliverpb::InvokeInProcExecuteAssemblyReq>(Arena*);
template<> ::sliverpb::InvokeMigrateReq* Arena::CreateMaybeMessage<::sliverpb::InvokeMigrateReq>(Arena*);
template<> ::sliverpb::InvokeSpawnDllReq* Arena::CreateMaybeMessage<::sliverpb::InvokeSpawnDllReq>(Arena*);
template<> ::sliverpb::KillReq* Arena::CreateMaybeMessage<::sliverpb::KillReq>(Arena*);
template<> ::sliverpb::ListExtensions* Arena::CreateMaybeMessage<::sliverpb::ListExtensions>(Arena*);
template<> ::sliverpb::ListExtensionsReq* Arena::CreateMaybeMessage<::sliverpb::ListExtensionsReq>(Arena*);
template<> ::sliverpb::ListTokens* Arena::CreateMaybeMessage<::sliverpb::ListTokens>(Arena*);
template<> ::sliverpb::ListTokensReq* Arena::CreateMaybeMessage<::sliverpb::ListTokensReq>(Arena*);
template<> ::sliverpb::Ls* Arena::CreateMaybeMessage<::sliverpb::Ls>(Arena*);
template<> ::sliverpb::LsReq* Arena::CreateMaybeMessage<::sliverpb::LsReq>(Arena*);
template<> ::sliverpb::MakeToken* Arena::CreateMaybeMessage<::sliverpb::MakeToken>(Arena*);
template<> ::sliverpb::MakeTokenReq* Arena::CreateMaybeMessage<::sliverpb::MakeTokenReq>(Arena*);
template<> ::sliverpb::Migrate* Arena::CreateMaybeMessage<::sliverpb::Migrate>(Arena*);
template<> ::sliverpb::Mkdir* Arena::CreateMaybeMessage<::sliverpb::Mkdir>(Arena*);
template<> ::sliverpb::MkdirReq* Arena::CreateMaybeMessage<::sliverpb::MkdirReq>(Arena*);
template<> ::sliverpb::Mv* Arena::CreateMaybeMessage<::sliverpb::Mv>(Arena*);
template<> ::sliverpb::MvReq* Arena::CreateMaybeMessage<::sliverpb::MvReq>(Arena*);
template<> ::sliverpb::NetConnPivot* Arena::CreateMaybeMessage<::sliverpb::NetConnPivot>(Arena*);
template<> ::sliverpb::NetInterface* Arena::CreateMaybeMessage<::sliverpb::NetInterface>(Arena*);
template<> ::sliverpb::Netstat* Arena::CreateMaybeMessage<::sliverpb::Netstat>(Arena*);
template<> ::sliverpb::NetstatReq* Arena::CreateMaybeMessage<::sliverpb::NetstatReq>(Arena*);
template<> ::sliverpb::OpenSession* Arena::CreateMaybeMessage<::sliverpb::OpenSession>(Arena*);
template<> ::sliverpb::Ping* Arena::CreateMaybeMessage<::sliverpb::Ping>(Arena*);
template<> ::sliverpb::PivotHello* Arena::CreateMaybeMessage<::sliverpb::PivotHello>(Arena*);
template<> ::sliverpb::PivotListener* Arena::CreateMaybeMessage<::sliverpb::PivotListener>(Arena*);
template<> ::sliverpb::PivotListeners* Arena::CreateMaybeMessage<::sliverpb::PivotListeners>(Arena*);
template<> ::sliverpb::PivotListenersReq* Arena::CreateMaybeMessage<::sliverpb::PivotListenersReq>(Arena*);
template<> ::sliverpb::PivotPeer* Arena::CreateMaybeMessage<::sliverpb::PivotPeer>(Arena*);
template<> ::sliverpb::PivotPeerEnvelope* Arena::CreateMaybeMessage<::sliverpb::PivotPeerEnvelope>(Arena*);
template<> ::sliverpb::PivotPeerFailure* Arena::CreateMaybeMessage<::sliverpb::PivotPeerFailure>(Arena*);
template<> ::sliverpb::PivotPing* Arena::CreateMaybeMessage<::sliverpb::PivotPing>(Arena*);
template<> ::sliverpb::PivotServerKeyExchange* Arena::CreateMaybeMessage<::sliverpb::PivotServerKeyExchange>(Arena*);
template<> ::sliverpb::PivotStartListenerReq* Arena::CreateMaybeMessage<::sliverpb::PivotStartListenerReq>(Arena*);
template<> ::sliverpb::PivotStopListenerReq* Arena::CreateMaybeMessage<::sliverpb::PivotStopListenerReq>(Arena*);
template<> ::sliverpb::PollInterval* Arena::CreateMaybeMessage<::sliverpb::PollInterval>(Arena*);
template<> ::sliverpb::PollIntervalReq* Arena::CreateMaybeMessage<::sliverpb::PollIntervalReq>(Arena*);
template<> ::sliverpb::Portfwd* Arena::CreateMaybeMessage<::sliverpb::Portfwd>(Arena*);
template<> ::sliverpb::PortfwdReq* Arena::CreateMaybeMessage<::sliverpb::PortfwdReq>(Arena*);
template<> ::sliverpb::ProcessDump* Arena::CreateMaybeMessage<::sliverpb::ProcessDump>(Arena*);
template<> ::sliverpb::ProcessDumpReq* Arena::CreateMaybeMessage<::sliverpb::ProcessDumpReq>(Arena*);
template<> ::sliverpb::Ps* Arena::CreateMaybeMessage<::sliverpb::Ps>(Arena*);
template<> ::sliverpb::PsReq* Arena::CreateMaybeMessage<::sliverpb::PsReq>(Arena*);
template<> ::sliverpb::Pwd* Arena::CreateMaybeMessage<::sliverpb::Pwd>(Arena*);
template<> ::sliverpb::PwdReq* Arena::CreateMaybeMessage<::sliverpb::PwdReq>(Arena*);
template<> ::sliverpb::RPortfwd* Arena::CreateMaybeMessage<::sliverpb::RPortfwd>(Arena*);
template<> ::sliverpb::RPortfwdReq* Arena::CreateMaybeMessage<::sliverpb::RPortfwdReq>(Arena*);
template<> ::sliverpb::Reconfigure* Arena::CreateMaybeMessage<::sliverpb::Reconfigure>(Arena*);
template<> ::sliverpb::ReconfigureReq* Arena::CreateMaybeMessage<::sliverpb::ReconfigureReq>(Arena*);
template<> ::sliverpb::Register* Arena::CreateMaybeMessage<::sliverpb::Register>(Arena*);
template<> ::sliverpb::RegisterExtension* Arena::CreateMaybeMessage<::sliverpb::RegisterExtension>(Arena*);
template<> ::sliverpb::RegisterExtensionReq* Arena::CreateMaybeMessage<::sliverpb::RegisterExtensionReq>(Arena*);
template<> ::sliverpb::RegistryCreateKey* Arena::CreateMaybeMessage<::sliverpb::RegistryCreateKey>(Arena*);
template<> ::sliverpb::RegistryCreateKeyReq* Arena::CreateMaybeMessage<::sliverpb::RegistryCreateKeyReq>(Arena*);
template<> ::sliverpb::RegistryDeleteKey* Arena::CreateMaybeMessage<::sliverpb::RegistryDeleteKey>(Arena*);
template<> ::sliverpb::RegistryDeleteKeyReq* Arena::CreateMaybeMessage<::sliverpb::RegistryDeleteKeyReq>(Arena*);
template<> ::sliverpb::RegistryListValuesReq* Arena::CreateMaybeMessage<::sliverpb::RegistryListValuesReq>(Arena*);
template<> ::sliverpb::RegistryRead* Arena::CreateMaybeMessage<::sliverpb::RegistryRead>(Arena*);
template<> ::sliverpb::RegistryReadReq* Arena::CreateMaybeMessage<::sliverpb::RegistryReadReq>(Arena*);
template<> ::sliverpb::RegistrySubKeyList* Arena::CreateMaybeMessage<::sliverpb::RegistrySubKeyList>(Arena*);
template<> ::sliverpb::RegistrySubKeyListReq* Arena::CreateMaybeMessage<::sliverpb::RegistrySubKeyListReq>(Arena*);
template<> ::sliverpb::RegistryValuesList* Arena::CreateMaybeMessage<::sliverpb::RegistryValuesList>(Arena*);
template<> ::sliverpb::RegistryWrite* Arena::CreateMaybeMessage<::sliverpb::RegistryWrite>(Arena*);
template<> ::sliverpb::RegistryWriteReq* Arena::CreateMaybeMessage<::sliverpb::RegistryWriteReq>(Arena*);
template<> ::sliverpb::RemoveServiceReq* Arena::CreateMaybeMessage<::sliverpb::RemoveServiceReq>(Arena*);
template<> ::sliverpb::RevToSelf* Arena::CreateMaybeMessage<::sliverpb::RevToSelf>(Arena*);
template<> ::sliverpb::RevToSelfReq* Arena::CreateMaybeMessage<::sliverpb::RevToSelfReq>(Arena*);
template<> ::sliverpb::Rm* Arena::CreateMaybeMessage<::sliverpb::Rm>(Arena*);
template<> ::sliverpb::RmReq* Arena::CreateMaybeMessage<::sliverpb::RmReq>(Arena*);
template<> ::sliverpb::RportFwdListener* Arena::CreateMaybeMessage<::sliverpb::RportFwdListener>(Arena*);
template<> ::sliverpb::RportFwdListeners* Arena::CreateMaybeMessage<::sliverpb::RportFwdListeners>(Arena*);
template<> ::sliverpb::RportFwdListenersReq* Arena::CreateMaybeMessage<::sliverpb::RportFwdListenersReq>(Arena*);
template<> ::sliverpb::RportFwdStartListenerReq* Arena::CreateMaybeMessage<::sliverpb::RportFwdStartListenerReq>(Arena*);
template<> ::sliverpb::RportFwdStopListenerReq* Arena::CreateMaybeMessage<::sliverpb::RportFwdStopListenerReq>(Arena*);
template<> ::sliverpb::RunAs* Arena::CreateMaybeMessage<::sliverpb::RunAs>(Arena*);
template<> ::sliverpb::RunAsReq* Arena::CreateMaybeMessage<::sliverpb::RunAsReq>(Arena*);
template<> ::sliverpb::SSHCommand* Arena::CreateMaybeMessage<::sliverpb::SSHCommand>(Arena*);
template<> ::sliverpb::SSHCommandReq* Arena::CreateMaybeMessage<::sliverpb::SSHCommandReq>(Arena*);
template<> ::sliverpb::Screenshot* Arena::CreateMaybeMessage<::sliverpb::Screenshot>(Arena*);
template<> ::sliverpb::ScreenshotReq* Arena::CreateMaybeMessage<::sliverpb::ScreenshotReq>(Arena*);
template<> ::sliverpb::ServiceInfo* Arena::CreateMaybeMessage<::sliverpb::ServiceInfo>(Arena*);
template<> ::sliverpb::ServiceInfoReq* Arena::CreateMaybeMessage<::sliverpb::ServiceInfoReq>(Arena*);
template<> ::sliverpb::SessionRegister* Arena::CreateMaybeMessage<::sliverpb::SessionRegister>(Arena*);
template<> ::sliverpb::SetEnv* Arena::CreateMaybeMessage<::sliverpb::SetEnv>(Arena*);
template<> ::sliverpb::SetEnvReq* Arena::CreateMaybeMessage<::sliverpb::SetEnvReq>(Arena*);
template<> ::sliverpb::Shell* Arena::CreateMaybeMessage<::sliverpb::Shell>(Arena*);
template<> ::sliverpb::ShellReq* Arena::CreateMaybeMessage<::sliverpb::ShellReq>(Arena*);
template<> ::sliverpb::Sideload* Arena::CreateMaybeMessage<::sliverpb::Sideload>(Arena*);
template<> ::sliverpb::SideloadReq* Arena::CreateMaybeMessage<::sliverpb::SideloadReq>(Arena*);
template<> ::sliverpb::SockTabEntry* Arena::CreateMaybeMessage<::sliverpb::SockTabEntry>(Arena*);
template<> ::sliverpb::SockTabEntry_SockAddr* Arena::CreateMaybeMessage<::sliverpb::SockTabEntry_SockAddr>(Arena*);
template<> ::sliverpb::Socks* Arena::CreateMaybeMessage<::sliverpb::Socks>(Arena*);
template<> ::sliverpb::SocksData* Arena::CreateMaybeMessage<::sliverpb::SocksData>(Arena*);
template<> ::sliverpb::SpawnDll* Arena::CreateMaybeMessage<::sliverpb::SpawnDll>(Arena*);
template<> ::sliverpb::SpawnDllReq* Arena::CreateMaybeMessage<::sliverpb::SpawnDllReq>(Arena*);
template<> ::sliverpb::StartServiceReq* Arena::CreateMaybeMessage<::sliverpb::StartServiceReq>(Arena*);
template<> ::sliverpb::StopServiceReq* Arena::CreateMaybeMessage<::sliverpb::StopServiceReq>(Arena*);
template<> ::sliverpb::Task* Arena::CreateMaybeMessage<::sliverpb::Task>(Arena*);
template<> ::sliverpb::TaskReq* Arena::CreateMaybeMessage<::sliverpb::TaskReq>(Arena*);
template<> ::sliverpb::Terminate* Arena::CreateMaybeMessage<::sliverpb::Terminate>(Arena*);
template<> ::sliverpb::TerminateReq* Arena::CreateMaybeMessage<::sliverpb::TerminateReq>(Arena*);
template<> ::sliverpb::Token* Arena::CreateMaybeMessage<::sliverpb::Token>(Arena*);
template<> ::sliverpb::Tunnel* Arena::CreateMaybeMessage<::sliverpb::Tunnel>(Arena*);
template<> ::sliverpb::TunnelData* Arena::CreateMaybeMessage<::sliverpb::TunnelData>(Arena*);
template<> ::sliverpb::UnsetEnv* Arena::CreateMaybeMessage<::sliverpb::UnsetEnv>(Arena*);
template<> ::sliverpb::UnsetEnvReq* Arena::CreateMaybeMessage<::sliverpb::UnsetEnvReq>(Arena*);
template<> ::sliverpb::Upload* Arena::CreateMaybeMessage<::sliverpb::Upload>(Arena*);
template<> ::sliverpb::UploadReq* Arena::CreateMaybeMessage<::sliverpb::UploadReq>(Arena*);
template<> ::sliverpb::WGPortForward* Arena::CreateMaybeMessage<::sliverpb::WGPortForward>(Arena*);
template<> ::sliverpb::WGPortForwardStartReq* Arena::CreateMaybeMessage<::sliverpb::WGPortForwardStartReq>(Arena*);
template<> ::sliverpb::WGPortForwardStopReq* Arena::CreateMaybeMessage<::sliverpb::WGPortForwardStopReq>(Arena*);
template<> ::sliverpb::WGSocks* Arena::CreateMaybeMessage<::sliverpb::WGSocks>(Arena*);
template<> ::sliverpb::WGSocksServer* Arena::CreateMaybeMessage<::sliverpb::WGSocksServer>(Arena*);
template<> ::sliverpb::WGSocksServers* Arena::CreateMaybeMessage<::sliverpb::WGSocksServers>(Arena*);
template<> ::sliverpb::WGSocksServersReq* Arena::CreateMaybeMessage<::sliverpb::WGSocksServersReq>(Arena*);
template<> ::sliverpb::WGSocksStartReq* Arena::CreateMaybeMessage<::sliverpb::WGSocksStartReq>(Arena*);
template<> ::sliverpb::WGSocksStopReq* Arena::CreateMaybeMessage<::sliverpb::WGSocksStopReq>(Arena*);
template<> ::sliverpb::WGTCPForwarder* Arena::CreateMaybeMessage<::sliverpb::WGTCPForwarder>(Arena*);
template<> ::sliverpb::WGTCPForwarders* Arena::CreateMaybeMessage<::sliverpb::WGTCPForwarders>(Arena*);
template<> ::sliverpb::WGTCPForwardersReq* Arena::CreateMaybeMessage<::sliverpb::WGTCPForwardersReq>(Arena*);
template<> ::sliverpb::WindowsPrivilegeEntry* Arena::CreateMaybeMessage<::sliverpb::WindowsPrivilegeEntry>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sliverpb {

enum RegistryType : int {
  Unknown = 0,
  Binary = 1,
  String = 2,
  DWORD = 3,
  QWORD = 4,
  RegistryType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RegistryType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RegistryType_IsValid(int value);
constexpr RegistryType RegistryType_MIN = Unknown;
constexpr RegistryType RegistryType_MAX = QWORD;
constexpr int RegistryType_ARRAYSIZE = RegistryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RegistryType_descriptor();
template<typename T>
inline const std::string& RegistryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RegistryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RegistryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RegistryType_descriptor(), enum_t_value);
}
inline bool RegistryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RegistryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RegistryType>(
    RegistryType_descriptor(), name, value);
}
enum PivotType : int {
  TCP = 0,
  UDP = 1,
  NamedPipe = 2,
  PivotType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PivotType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PivotType_IsValid(int value);
constexpr PivotType PivotType_MIN = TCP;
constexpr PivotType PivotType_MAX = NamedPipe;
constexpr int PivotType_ARRAYSIZE = PivotType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PivotType_descriptor();
template<typename T>
inline const std::string& PivotType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PivotType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PivotType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PivotType_descriptor(), enum_t_value);
}
inline bool PivotType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PivotType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PivotType>(
    PivotType_descriptor(), name, value);
}
enum PeerFailureType : int {
  SEND_FAILURE = 0,
  DISCONNECT = 1,
  PeerFailureType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PeerFailureType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PeerFailureType_IsValid(int value);
constexpr PeerFailureType PeerFailureType_MIN = SEND_FAILURE;
constexpr PeerFailureType PeerFailureType_MAX = DISCONNECT;
constexpr int PeerFailureType_ARRAYSIZE = PeerFailureType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PeerFailureType_descriptor();
template<typename T>
inline const std::string& PeerFailureType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PeerFailureType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PeerFailureType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PeerFailureType_descriptor(), enum_t_value);
}
inline bool PeerFailureType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PeerFailureType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PeerFailureType>(
    PeerFailureType_descriptor(), name, value);
}
// ===================================================================

class Envelope final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Envelope) */ {
 public:
  inline Envelope() : Envelope(nullptr) {}
  ~Envelope() override;
  explicit PROTOBUF_CONSTEXPR Envelope(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Envelope(const Envelope& from);
  Envelope(Envelope&& from) noexcept
    : Envelope() {
    *this = ::std::move(from);
  }

  inline Envelope& operator=(const Envelope& from) {
    CopyFrom(from);
    return *this;
  }
  inline Envelope& operator=(Envelope&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Envelope& default_instance() {
    return *internal_default_instance();
  }
  static inline const Envelope* internal_default_instance() {
    return reinterpret_cast<const Envelope*>(
               &_Envelope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Envelope& a, Envelope& b) {
    a.Swap(&b);
  }
  inline void Swap(Envelope* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Envelope* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Envelope* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Envelope>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Envelope& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Envelope& from) {
    Envelope::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Envelope* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Envelope";
  }
  protected:
  explicit Envelope(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kIDFieldNumber = 1,
    kTypeFieldNumber = 2,
    kUnknownMessageTypeFieldNumber = 4,
  };
  // bytes Data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int64 ID = 1;
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // uint32 Type = 2;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // bool UnknownMessageType = 4;
  void clear_unknownmessagetype();
  bool unknownmessagetype() const;
  void set_unknownmessagetype(bool value);
  private:
  bool _internal_unknownmessagetype() const;
  void _internal_set_unknownmessagetype(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.Envelope)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int64_t id_;
    uint32_t type_;
    bool unknownmessagetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class BeaconTasks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.BeaconTasks) */ {
 public:
  inline BeaconTasks() : BeaconTasks(nullptr) {}
  ~BeaconTasks() override;
  explicit PROTOBUF_CONSTEXPR BeaconTasks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeaconTasks(const BeaconTasks& from);
  BeaconTasks(BeaconTasks&& from) noexcept
    : BeaconTasks() {
    *this = ::std::move(from);
  }

  inline BeaconTasks& operator=(const BeaconTasks& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeaconTasks& operator=(BeaconTasks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeaconTasks& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeaconTasks* internal_default_instance() {
    return reinterpret_cast<const BeaconTasks*>(
               &_BeaconTasks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BeaconTasks& a, BeaconTasks& b) {
    a.Swap(&b);
  }
  inline void Swap(BeaconTasks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeaconTasks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeaconTasks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeaconTasks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeaconTasks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeaconTasks& from) {
    BeaconTasks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeaconTasks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.BeaconTasks";
  }
  protected:
  explicit BeaconTasks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTasksFieldNumber = 2,
    kIDFieldNumber = 1,
    kNextCheckinFieldNumber = 3,
  };
  // repeated .sliverpb.Envelope Tasks = 2;
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;
  public:
  void clear_tasks();
  ::sliverpb::Envelope* mutable_tasks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::Envelope >*
      mutable_tasks();
  private:
  const ::sliverpb::Envelope& _internal_tasks(int index) const;
  ::sliverpb::Envelope* _internal_add_tasks();
  public:
  const ::sliverpb::Envelope& tasks(int index) const;
  ::sliverpb::Envelope* add_tasks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::Envelope >&
      tasks() const;

  // string ID = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // int64 NextCheckin = 3;
  void clear_nextcheckin();
  int64_t nextcheckin() const;
  void set_nextcheckin(int64_t value);
  private:
  int64_t _internal_nextcheckin() const;
  void _internal_set_nextcheckin(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.BeaconTasks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::Envelope > tasks_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    int64_t nextcheckin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Register final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Register) */ {
 public:
  inline Register() : Register(nullptr) {}
  ~Register() override;
  explicit PROTOBUF_CONSTEXPR Register(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Register(const Register& from);
  Register(Register&& from) noexcept
    : Register() {
    *this = ::std::move(from);
  }

  inline Register& operator=(const Register& from) {
    CopyFrom(from);
    return *this;
  }
  inline Register& operator=(Register&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Register& default_instance() {
    return *internal_default_instance();
  }
  static inline const Register* internal_default_instance() {
    return reinterpret_cast<const Register*>(
               &_Register_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Register& a, Register& b) {
    a.Swap(&b);
  }
  inline void Swap(Register* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Register* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Register* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Register>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Register& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Register& from) {
    Register::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Register* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Register";
  }
  protected:
  explicit Register(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kHostnameFieldNumber = 2,
    kUuidFieldNumber = 3,
    kUsernameFieldNumber = 4,
    kUidFieldNumber = 5,
    kGidFieldNumber = 6,
    kOsFieldNumber = 7,
    kArchFieldNumber = 8,
    kFilenameFieldNumber = 10,
    kActiveC2FieldNumber = 11,
    kVersionFieldNumber = 12,
    kProxyURLFieldNumber = 14,
    kConfigIDFieldNumber = 16,
    kLocaleFieldNumber = 18,
    kReconnectIntervalFieldNumber = 13,
    kPeerIDFieldNumber = 17,
    kPidFieldNumber = 9,
  };
  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string Hostname = 2;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // string Uuid = 3;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // string Username = 4;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string Uid = 5;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // string Gid = 6;
  void clear_gid();
  const std::string& gid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gid();
  PROTOBUF_NODISCARD std::string* release_gid();
  void set_allocated_gid(std::string* gid);
  private:
  const std::string& _internal_gid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gid(const std::string& value);
  std::string* _internal_mutable_gid();
  public:

  // string Os = 7;
  void clear_os();
  const std::string& os() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os();
  PROTOBUF_NODISCARD std::string* release_os();
  void set_allocated_os(std::string* os);
  private:
  const std::string& _internal_os() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os(const std::string& value);
  std::string* _internal_mutable_os();
  public:

  // string Arch = 8;
  void clear_arch();
  const std::string& arch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arch();
  PROTOBUF_NODISCARD std::string* release_arch();
  void set_allocated_arch(std::string* arch);
  private:
  const std::string& _internal_arch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arch(const std::string& value);
  std::string* _internal_mutable_arch();
  public:

  // string Filename = 10;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // string ActiveC2 = 11;
  void clear_activec2();
  const std::string& activec2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_activec2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_activec2();
  PROTOBUF_NODISCARD std::string* release_activec2();
  void set_allocated_activec2(std::string* activec2);
  private:
  const std::string& _internal_activec2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_activec2(const std::string& value);
  std::string* _internal_mutable_activec2();
  public:

  // string Version = 12;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string ProxyURL = 14;
  void clear_proxyurl();
  const std::string& proxyurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proxyurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proxyurl();
  PROTOBUF_NODISCARD std::string* release_proxyurl();
  void set_allocated_proxyurl(std::string* proxyurl);
  private:
  const std::string& _internal_proxyurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proxyurl(const std::string& value);
  std::string* _internal_mutable_proxyurl();
  public:

  // string ConfigID = 16;
  void clear_configid();
  const std::string& configid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_configid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_configid();
  PROTOBUF_NODISCARD std::string* release_configid();
  void set_allocated_configid(std::string* configid);
  private:
  const std::string& _internal_configid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_configid(const std::string& value);
  std::string* _internal_mutable_configid();
  public:

  // string Locale = 18;
  void clear_locale();
  const std::string& locale() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_locale(ArgT0&& arg0, ArgT... args);
  std::string* mutable_locale();
  PROTOBUF_NODISCARD std::string* release_locale();
  void set_allocated_locale(std::string* locale);
  private:
  const std::string& _internal_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(const std::string& value);
  std::string* _internal_mutable_locale();
  public:

  // int64 ReconnectInterval = 13;
  void clear_reconnectinterval();
  int64_t reconnectinterval() const;
  void set_reconnectinterval(int64_t value);
  private:
  int64_t _internal_reconnectinterval() const;
  void _internal_set_reconnectinterval(int64_t value);
  public:

  // int64 PeerID = 17;
  void clear_peerid();
  int64_t peerid() const;
  void set_peerid(int64_t value);
  private:
  int64_t _internal_peerid() const;
  void _internal_set_peerid(int64_t value);
  public:

  // int32 Pid = 9;
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.Register)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr activec2_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proxyurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr configid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_;
    int64_t reconnectinterval_;
    int64_t peerid_;
    int32_t pid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class BeaconRegister final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.BeaconRegister) */ {
 public:
  inline BeaconRegister() : BeaconRegister(nullptr) {}
  ~BeaconRegister() override;
  explicit PROTOBUF_CONSTEXPR BeaconRegister(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeaconRegister(const BeaconRegister& from);
  BeaconRegister(BeaconRegister&& from) noexcept
    : BeaconRegister() {
    *this = ::std::move(from);
  }

  inline BeaconRegister& operator=(const BeaconRegister& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeaconRegister& operator=(BeaconRegister&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeaconRegister& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeaconRegister* internal_default_instance() {
    return reinterpret_cast<const BeaconRegister*>(
               &_BeaconRegister_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BeaconRegister& a, BeaconRegister& b) {
    a.Swap(&b);
  }
  inline void Swap(BeaconRegister* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeaconRegister* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeaconRegister* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeaconRegister>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeaconRegister& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeaconRegister& from) {
    BeaconRegister::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeaconRegister* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.BeaconRegister";
  }
  protected:
  explicit BeaconRegister(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
    kRegisterFieldNumber = 4,
    kIntervalFieldNumber = 2,
    kJitterFieldNumber = 3,
    kNextCheckinFieldNumber = 5,
  };
  // string ID = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .sliverpb.Register Register = 4;
  bool has_register_() const;
  private:
  bool _internal_has_register_() const;
  public:
  void clear_register_();
  const ::sliverpb::Register& register_() const;
  PROTOBUF_NODISCARD ::sliverpb::Register* release_register_();
  ::sliverpb::Register* mutable_register_();
  void set_allocated_register_(::sliverpb::Register* register_);
  private:
  const ::sliverpb::Register& _internal_register_() const;
  ::sliverpb::Register* _internal_mutable_register_();
  public:
  void unsafe_arena_set_allocated_register_(
      ::sliverpb::Register* register_);
  ::sliverpb::Register* unsafe_arena_release_register_();

  // int64 Interval = 2;
  void clear_interval();
  int64_t interval() const;
  void set_interval(int64_t value);
  private:
  int64_t _internal_interval() const;
  void _internal_set_interval(int64_t value);
  public:

  // int64 Jitter = 3;
  void clear_jitter();
  int64_t jitter() const;
  void set_jitter(int64_t value);
  private:
  int64_t _internal_jitter() const;
  void _internal_set_jitter(int64_t value);
  public:

  // int64 NextCheckin = 5;
  void clear_nextcheckin();
  int64_t nextcheckin() const;
  void set_nextcheckin(int64_t value);
  private:
  int64_t _internal_nextcheckin() const;
  void _internal_set_nextcheckin(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.BeaconRegister)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::sliverpb::Register* register__;
    int64_t interval_;
    int64_t jitter_;
    int64_t nextcheckin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class SessionRegister final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.SessionRegister) */ {
 public:
  inline SessionRegister() : SessionRegister(nullptr) {}
  ~SessionRegister() override;
  explicit PROTOBUF_CONSTEXPR SessionRegister(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionRegister(const SessionRegister& from);
  SessionRegister(SessionRegister&& from) noexcept
    : SessionRegister() {
    *this = ::std::move(from);
  }

  inline SessionRegister& operator=(const SessionRegister& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionRegister& operator=(SessionRegister&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionRegister& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionRegister* internal_default_instance() {
    return reinterpret_cast<const SessionRegister*>(
               &_SessionRegister_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SessionRegister& a, SessionRegister& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionRegister* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionRegister* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionRegister* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionRegister>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionRegister& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SessionRegister& from) {
    SessionRegister::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionRegister* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.SessionRegister";
  }
  protected:
  explicit SessionRegister(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
    kRegisterFieldNumber = 2,
  };
  // string ID = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .sliverpb.Register Register = 2;
  bool has_register_() const;
  private:
  bool _internal_has_register_() const;
  public:
  void clear_register_();
  const ::sliverpb::Register& register_() const;
  PROTOBUF_NODISCARD ::sliverpb::Register* release_register_();
  ::sliverpb::Register* mutable_register_();
  void set_allocated_register_(::sliverpb::Register* register_);
  private:
  const ::sliverpb::Register& _internal_register_() const;
  ::sliverpb::Register* _internal_mutable_register_();
  public:
  void unsafe_arena_set_allocated_register_(
      ::sliverpb::Register* register_);
  ::sliverpb::Register* unsafe_arena_release_register_();

  // @@protoc_insertion_point(class_scope:sliverpb.SessionRegister)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::sliverpb::Register* register__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class OpenSession final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.OpenSession) */ {
 public:
  inline OpenSession() : OpenSession(nullptr) {}
  ~OpenSession() override;
  explicit PROTOBUF_CONSTEXPR OpenSession(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenSession(const OpenSession& from);
  OpenSession(OpenSession&& from) noexcept
    : OpenSession() {
    *this = ::std::move(from);
  }

  inline OpenSession& operator=(const OpenSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenSession& operator=(OpenSession&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenSession& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenSession* internal_default_instance() {
    return reinterpret_cast<const OpenSession*>(
               &_OpenSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OpenSession& a, OpenSession& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenSession* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenSession* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenSession>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenSession& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpenSession& from) {
    OpenSession::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenSession* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.OpenSession";
  }
  protected:
  explicit OpenSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kC2SFieldNumber = 1,
    kResponseFieldNumber = 8,
    kRequestFieldNumber = 9,
    kDelayFieldNumber = 2,
  };
  // repeated string C2s = 1;
  int c2s_size() const;
  private:
  int _internal_c2s_size() const;
  public:
  void clear_c2s();
  const std::string& c2s(int index) const;
  std::string* mutable_c2s(int index);
  void set_c2s(int index, const std::string& value);
  void set_c2s(int index, std::string&& value);
  void set_c2s(int index, const char* value);
  void set_c2s(int index, const char* value, size_t size);
  std::string* add_c2s();
  void add_c2s(const std::string& value);
  void add_c2s(std::string&& value);
  void add_c2s(const char* value);
  void add_c2s(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& c2s() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_c2s();
  private:
  const std::string& _internal_c2s(int index) const;
  std::string* _internal_add_c2s();
  public:

  // .sliverpb.Response Response = 8;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // int64 Delay = 2;
  void clear_delay();
  int64_t delay() const;
  void set_delay(int64_t value);
  private:
  int64_t _internal_delay() const;
  void _internal_set_delay(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.OpenSession)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> c2s_;
    ::sliverpb::Response* response_;
    ::sliverpb::Request* request_;
    int64_t delay_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class CloseSession final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.CloseSession) */ {
 public:
  inline CloseSession() : CloseSession(nullptr) {}
  ~CloseSession() override;
  explicit PROTOBUF_CONSTEXPR CloseSession(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseSession(const CloseSession& from);
  CloseSession(CloseSession&& from) noexcept
    : CloseSession() {
    *this = ::std::move(from);
  }

  inline CloseSession& operator=(const CloseSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseSession& operator=(CloseSession&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseSession& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseSession* internal_default_instance() {
    return reinterpret_cast<const CloseSession*>(
               &_CloseSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CloseSession& a, CloseSession& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseSession* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseSession* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseSession>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloseSession& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CloseSession& from) {
    CloseSession::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseSession* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.CloseSession";
  }
  protected:
  explicit CloseSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 8,
    kRequestFieldNumber = 9,
  };
  // .sliverpb.Response Response = 8;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.CloseSession)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Ping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  ~Ping() override;
  explicit PROTOBUF_CONSTEXPR Ping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ping(const Ping& from);
  Ping(Ping&& from) noexcept
    : Ping() {
    *this = ::std::move(from);
  }

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Ping& a, Ping& b) {
    a.Swap(&b);
  }
  inline void Swap(Ping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ping& from) {
    Ping::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Ping";
  }
  protected:
  explicit Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 8,
    kRequestFieldNumber = 9,
    kNonceFieldNumber = 1,
  };
  // .sliverpb.Response Response = 8;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // int32 Nonce = 1;
  void clear_nonce();
  int32_t nonce() const;
  void set_nonce(int32_t value);
  private:
  int32_t _internal_nonce() const;
  void _internal_set_nonce(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.Ping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    ::sliverpb::Request* request_;
    int32_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class KillReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.KillReq) */ {
 public:
  inline KillReq() : KillReq(nullptr) {}
  ~KillReq() override;
  explicit PROTOBUF_CONSTEXPR KillReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KillReq(const KillReq& from);
  KillReq(KillReq&& from) noexcept
    : KillReq() {
    *this = ::std::move(from);
  }

  inline KillReq& operator=(const KillReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline KillReq& operator=(KillReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KillReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const KillReq* internal_default_instance() {
    return reinterpret_cast<const KillReq*>(
               &_KillReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(KillReq& a, KillReq& b) {
    a.Swap(&b);
  }
  inline void Swap(KillReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KillReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KillReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KillReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KillReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KillReq& from) {
    KillReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KillReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.KillReq";
  }
  protected:
  explicit KillReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
    kForceFieldNumber = 1,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // bool Force = 1;
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.KillReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    bool force_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class PsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.PsReq) */ {
 public:
  inline PsReq() : PsReq(nullptr) {}
  ~PsReq() override;
  explicit PROTOBUF_CONSTEXPR PsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PsReq(const PsReq& from);
  PsReq(PsReq&& from) noexcept
    : PsReq() {
    *this = ::std::move(from);
  }

  inline PsReq& operator=(const PsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PsReq& operator=(PsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PsReq* internal_default_instance() {
    return reinterpret_cast<const PsReq*>(
               &_PsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PsReq& a, PsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PsReq& from) {
    PsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.PsReq";
  }
  protected:
  explicit PsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.PsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Ps final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Ps) */ {
 public:
  inline Ps() : Ps(nullptr) {}
  ~Ps() override;
  explicit PROTOBUF_CONSTEXPR Ps(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ps(const Ps& from);
  Ps(Ps&& from) noexcept
    : Ps() {
    *this = ::std::move(from);
  }

  inline Ps& operator=(const Ps& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ps& operator=(Ps&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ps& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ps* internal_default_instance() {
    return reinterpret_cast<const Ps*>(
               &_Ps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Ps& a, Ps& b) {
    a.Swap(&b);
  }
  inline void Swap(Ps* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ps* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ps>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ps& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ps& from) {
    Ps::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ps* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Ps";
  }
  protected:
  explicit Ps(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessesFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // repeated .sliverpb.Process Processes = 1;
  int processes_size() const;
  private:
  int _internal_processes_size() const;
  public:
  void clear_processes();
  ::sliverpb::Process* mutable_processes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::Process >*
      mutable_processes();
  private:
  const ::sliverpb::Process& _internal_processes(int index) const;
  ::sliverpb::Process* _internal_add_processes();
  public:
  const ::sliverpb::Process& processes(int index) const;
  ::sliverpb::Process* add_processes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::Process >&
      processes() const;

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.Ps)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::Process > processes_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class TerminateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.TerminateReq) */ {
 public:
  inline TerminateReq() : TerminateReq(nullptr) {}
  ~TerminateReq() override;
  explicit PROTOBUF_CONSTEXPR TerminateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TerminateReq(const TerminateReq& from);
  TerminateReq(TerminateReq&& from) noexcept
    : TerminateReq() {
    *this = ::std::move(from);
  }

  inline TerminateReq& operator=(const TerminateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TerminateReq& operator=(TerminateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TerminateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TerminateReq* internal_default_instance() {
    return reinterpret_cast<const TerminateReq*>(
               &_TerminateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TerminateReq& a, TerminateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TerminateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TerminateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TerminateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TerminateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TerminateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TerminateReq& from) {
    TerminateReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TerminateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.TerminateReq";
  }
  protected:
  explicit TerminateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
    kPidFieldNumber = 1,
    kForceFieldNumber = 2,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // int32 Pid = 1;
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // bool Force = 2;
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.TerminateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    int32_t pid_;
    bool force_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Terminate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Terminate) */ {
 public:
  inline Terminate() : Terminate(nullptr) {}
  ~Terminate() override;
  explicit PROTOBUF_CONSTEXPR Terminate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Terminate(const Terminate& from);
  Terminate(Terminate&& from) noexcept
    : Terminate() {
    *this = ::std::move(from);
  }

  inline Terminate& operator=(const Terminate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Terminate& operator=(Terminate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Terminate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Terminate* internal_default_instance() {
    return reinterpret_cast<const Terminate*>(
               &_Terminate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Terminate& a, Terminate& b) {
    a.Swap(&b);
  }
  inline void Swap(Terminate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Terminate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Terminate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Terminate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Terminate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Terminate& from) {
    Terminate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Terminate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Terminate";
  }
  protected:
  explicit Terminate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 9,
    kPidFieldNumber = 1,
  };
  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // int32 Pid = 1;
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.Terminate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    int32_t pid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class IfconfigReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.IfconfigReq) */ {
 public:
  inline IfconfigReq() : IfconfigReq(nullptr) {}
  ~IfconfigReq() override;
  explicit PROTOBUF_CONSTEXPR IfconfigReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IfconfigReq(const IfconfigReq& from);
  IfconfigReq(IfconfigReq&& from) noexcept
    : IfconfigReq() {
    *this = ::std::move(from);
  }

  inline IfconfigReq& operator=(const IfconfigReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline IfconfigReq& operator=(IfconfigReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IfconfigReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const IfconfigReq* internal_default_instance() {
    return reinterpret_cast<const IfconfigReq*>(
               &_IfconfigReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(IfconfigReq& a, IfconfigReq& b) {
    a.Swap(&b);
  }
  inline void Swap(IfconfigReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IfconfigReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IfconfigReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IfconfigReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IfconfigReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IfconfigReq& from) {
    IfconfigReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IfconfigReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.IfconfigReq";
  }
  protected:
  explicit IfconfigReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.IfconfigReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Ifconfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Ifconfig) */ {
 public:
  inline Ifconfig() : Ifconfig(nullptr) {}
  ~Ifconfig() override;
  explicit PROTOBUF_CONSTEXPR Ifconfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ifconfig(const Ifconfig& from);
  Ifconfig(Ifconfig&& from) noexcept
    : Ifconfig() {
    *this = ::std::move(from);
  }

  inline Ifconfig& operator=(const Ifconfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ifconfig& operator=(Ifconfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ifconfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ifconfig* internal_default_instance() {
    return reinterpret_cast<const Ifconfig*>(
               &_Ifconfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Ifconfig& a, Ifconfig& b) {
    a.Swap(&b);
  }
  inline void Swap(Ifconfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ifconfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ifconfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ifconfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ifconfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ifconfig& from) {
    Ifconfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ifconfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Ifconfig";
  }
  protected:
  explicit Ifconfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetInterfacesFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // repeated .sliverpb.NetInterface NetInterfaces = 1;
  int netinterfaces_size() const;
  private:
  int _internal_netinterfaces_size() const;
  public:
  void clear_netinterfaces();
  ::sliverpb::NetInterface* mutable_netinterfaces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::NetInterface >*
      mutable_netinterfaces();
  private:
  const ::sliverpb::NetInterface& _internal_netinterfaces(int index) const;
  ::sliverpb::NetInterface* _internal_add_netinterfaces();
  public:
  const ::sliverpb::NetInterface& netinterfaces(int index) const;
  ::sliverpb::NetInterface* add_netinterfaces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::NetInterface >&
      netinterfaces() const;

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.Ifconfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::NetInterface > netinterfaces_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class NetInterface final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.NetInterface) */ {
 public:
  inline NetInterface() : NetInterface(nullptr) {}
  ~NetInterface() override;
  explicit PROTOBUF_CONSTEXPR NetInterface(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetInterface(const NetInterface& from);
  NetInterface(NetInterface&& from) noexcept
    : NetInterface() {
    *this = ::std::move(from);
  }

  inline NetInterface& operator=(const NetInterface& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetInterface& operator=(NetInterface&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetInterface& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetInterface* internal_default_instance() {
    return reinterpret_cast<const NetInterface*>(
               &_NetInterface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(NetInterface& a, NetInterface& b) {
    a.Swap(&b);
  }
  inline void Swap(NetInterface* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetInterface* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetInterface* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetInterface>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetInterface& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetInterface& from) {
    NetInterface::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetInterface* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.NetInterface";
  }
  protected:
  explicit NetInterface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIPAddressesFieldNumber = 4,
    kNameFieldNumber = 2,
    kMACFieldNumber = 3,
    kIndexFieldNumber = 1,
  };
  // repeated string IPAddresses = 4;
  int ipaddresses_size() const;
  private:
  int _internal_ipaddresses_size() const;
  public:
  void clear_ipaddresses();
  const std::string& ipaddresses(int index) const;
  std::string* mutable_ipaddresses(int index);
  void set_ipaddresses(int index, const std::string& value);
  void set_ipaddresses(int index, std::string&& value);
  void set_ipaddresses(int index, const char* value);
  void set_ipaddresses(int index, const char* value, size_t size);
  std::string* add_ipaddresses();
  void add_ipaddresses(const std::string& value);
  void add_ipaddresses(std::string&& value);
  void add_ipaddresses(const char* value);
  void add_ipaddresses(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ipaddresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ipaddresses();
  private:
  const std::string& _internal_ipaddresses(int index) const;
  std::string* _internal_add_ipaddresses();
  public:

  // string Name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string MAC = 3;
  void clear_mac();
  const std::string& mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* mac);
  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(const std::string& value);
  std::string* _internal_mutable_mac();
  public:

  // int32 Index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.NetInterface)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ipaddresses_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_;
    int32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class LsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.LsReq) */ {
 public:
  inline LsReq() : LsReq(nullptr) {}
  ~LsReq() override;
  explicit PROTOBUF_CONSTEXPR LsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LsReq(const LsReq& from);
  LsReq(LsReq&& from) noexcept
    : LsReq() {
    *this = ::std::move(from);
  }

  inline LsReq& operator=(const LsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LsReq& operator=(LsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LsReq* internal_default_instance() {
    return reinterpret_cast<const LsReq*>(
               &_LsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(LsReq& a, LsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LsReq& from) {
    LsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.LsReq";
  }
  protected:
  explicit LsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kRequestFieldNumber = 9,
  };
  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.LsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Ls final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Ls) */ {
 public:
  inline Ls() : Ls(nullptr) {}
  ~Ls() override;
  explicit PROTOBUF_CONSTEXPR Ls(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ls(const Ls& from);
  Ls(Ls&& from) noexcept
    : Ls() {
    *this = ::std::move(from);
  }

  inline Ls& operator=(const Ls& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ls& operator=(Ls&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ls& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ls* internal_default_instance() {
    return reinterpret_cast<const Ls*>(
               &_Ls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Ls& a, Ls& b) {
    a.Swap(&b);
  }
  inline void Swap(Ls* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ls* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ls* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ls>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ls& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ls& from) {
    Ls::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ls* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Ls";
  }
  protected:
  explicit Ls(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 3,
    kPathFieldNumber = 1,
    kTimezoneFieldNumber = 4,
    kResponseFieldNumber = 9,
    kExistsFieldNumber = 2,
    kTimezoneOffsetFieldNumber = 5,
  };
  // repeated .sliverpb.FileInfo Files = 3;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  ::sliverpb::FileInfo* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::FileInfo >*
      mutable_files();
  private:
  const ::sliverpb::FileInfo& _internal_files(int index) const;
  ::sliverpb::FileInfo* _internal_add_files();
  public:
  const ::sliverpb::FileInfo& files(int index) const;
  ::sliverpb::FileInfo* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::FileInfo >&
      files() const;

  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string timezone = 4;
  void clear_timezone();
  const std::string& timezone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timezone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timezone();
  PROTOBUF_NODISCARD std::string* release_timezone();
  void set_allocated_timezone(std::string* timezone);
  private:
  const std::string& _internal_timezone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timezone(const std::string& value);
  std::string* _internal_mutable_timezone();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // bool Exists = 2;
  void clear_exists();
  bool exists() const;
  void set_exists(bool value);
  private:
  bool _internal_exists() const;
  void _internal_set_exists(bool value);
  public:

  // int32 timezoneOffset = 5;
  void clear_timezoneoffset();
  int32_t timezoneoffset() const;
  void set_timezoneoffset(int32_t value);
  private:
  int32_t _internal_timezoneoffset() const;
  void _internal_set_timezoneoffset(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.Ls)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::FileInfo > files_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timezone_;
    ::sliverpb::Response* response_;
    bool exists_;
    int32_t timezoneoffset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class FileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.FileInfo) */ {
 public:
  inline FileInfo() : FileInfo(nullptr) {}
  ~FileInfo() override;
  explicit PROTOBUF_CONSTEXPR FileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileInfo(const FileInfo& from);
  FileInfo(FileInfo&& from) noexcept
    : FileInfo() {
    *this = ::std::move(from);
  }

  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileInfo& operator=(FileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileInfo* internal_default_instance() {
    return reinterpret_cast<const FileInfo*>(
               &_FileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(FileInfo& a, FileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FileInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileInfo& from) {
    FileInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.FileInfo";
  }
  protected:
  explicit FileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kModeFieldNumber = 5,
    kLinkFieldNumber = 6,
    kSizeFieldNumber = 3,
    kModTimeFieldNumber = 4,
    kIsDirFieldNumber = 2,
  };
  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string Mode = 5;
  void clear_mode();
  const std::string& mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mode();
  PROTOBUF_NODISCARD std::string* release_mode();
  void set_allocated_mode(std::string* mode);
  private:
  const std::string& _internal_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mode(const std::string& value);
  std::string* _internal_mutable_mode();
  public:

  // string Link = 6;
  void clear_link();
  const std::string& link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_link();
  PROTOBUF_NODISCARD std::string* release_link();
  void set_allocated_link(std::string* link);
  private:
  const std::string& _internal_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link(const std::string& value);
  std::string* _internal_mutable_link();
  public:

  // int64 Size = 3;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // int64 ModTime = 4;
  void clear_modtime();
  int64_t modtime() const;
  void set_modtime(int64_t value);
  private:
  int64_t _internal_modtime() const;
  void _internal_set_modtime(int64_t value);
  public:

  // bool IsDir = 2;
  void clear_isdir();
  bool isdir() const;
  void set_isdir(bool value);
  private:
  bool _internal_isdir() const;
  void _internal_set_isdir(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.FileInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_;
    int64_t size_;
    int64_t modtime_;
    bool isdir_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class CdReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.CdReq) */ {
 public:
  inline CdReq() : CdReq(nullptr) {}
  ~CdReq() override;
  explicit PROTOBUF_CONSTEXPR CdReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CdReq(const CdReq& from);
  CdReq(CdReq&& from) noexcept
    : CdReq() {
    *this = ::std::move(from);
  }

  inline CdReq& operator=(const CdReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdReq& operator=(CdReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CdReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CdReq* internal_default_instance() {
    return reinterpret_cast<const CdReq*>(
               &_CdReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CdReq& a, CdReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CdReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CdReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CdReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CdReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CdReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CdReq& from) {
    CdReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CdReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.CdReq";
  }
  protected:
  explicit CdReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kRequestFieldNumber = 9,
  };
  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.CdReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class PwdReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.PwdReq) */ {
 public:
  inline PwdReq() : PwdReq(nullptr) {}
  ~PwdReq() override;
  explicit PROTOBUF_CONSTEXPR PwdReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PwdReq(const PwdReq& from);
  PwdReq(PwdReq&& from) noexcept
    : PwdReq() {
    *this = ::std::move(from);
  }

  inline PwdReq& operator=(const PwdReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PwdReq& operator=(PwdReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PwdReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PwdReq* internal_default_instance() {
    return reinterpret_cast<const PwdReq*>(
               &_PwdReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PwdReq& a, PwdReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PwdReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PwdReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PwdReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PwdReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PwdReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PwdReq& from) {
    PwdReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PwdReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.PwdReq";
  }
  protected:
  explicit PwdReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.PwdReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Pwd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Pwd) */ {
 public:
  inline Pwd() : Pwd(nullptr) {}
  ~Pwd() override;
  explicit PROTOBUF_CONSTEXPR Pwd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pwd(const Pwd& from);
  Pwd(Pwd&& from) noexcept
    : Pwd() {
    *this = ::std::move(from);
  }

  inline Pwd& operator=(const Pwd& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pwd& operator=(Pwd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pwd& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pwd* internal_default_instance() {
    return reinterpret_cast<const Pwd*>(
               &_Pwd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Pwd& a, Pwd& b) {
    a.Swap(&b);
  }
  inline void Swap(Pwd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pwd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pwd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pwd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pwd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pwd& from) {
    Pwd::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pwd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Pwd";
  }
  protected:
  explicit Pwd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.Pwd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RmReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RmReq) */ {
 public:
  inline RmReq() : RmReq(nullptr) {}
  ~RmReq() override;
  explicit PROTOBUF_CONSTEXPR RmReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RmReq(const RmReq& from);
  RmReq(RmReq&& from) noexcept
    : RmReq() {
    *this = ::std::move(from);
  }

  inline RmReq& operator=(const RmReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RmReq& operator=(RmReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RmReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RmReq* internal_default_instance() {
    return reinterpret_cast<const RmReq*>(
               &_RmReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(RmReq& a, RmReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RmReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RmReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RmReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RmReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RmReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RmReq& from) {
    RmReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RmReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RmReq";
  }
  protected:
  explicit RmReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kRequestFieldNumber = 9,
    kRecursiveFieldNumber = 2,
    kForceFieldNumber = 3,
  };
  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // bool Recursive = 2;
  void clear_recursive();
  bool recursive() const;
  void set_recursive(bool value);
  private:
  bool _internal_recursive() const;
  void _internal_set_recursive(bool value);
  public:

  // bool Force = 3;
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.RmReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::sliverpb::Request* request_;
    bool recursive_;
    bool force_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Rm final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Rm) */ {
 public:
  inline Rm() : Rm(nullptr) {}
  ~Rm() override;
  explicit PROTOBUF_CONSTEXPR Rm(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rm(const Rm& from);
  Rm(Rm&& from) noexcept
    : Rm() {
    *this = ::std::move(from);
  }

  inline Rm& operator=(const Rm& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rm& operator=(Rm&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rm& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rm* internal_default_instance() {
    return reinterpret_cast<const Rm*>(
               &_Rm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Rm& a, Rm& b) {
    a.Swap(&b);
  }
  inline void Swap(Rm* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rm* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rm>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rm& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rm& from) {
    Rm::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rm* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Rm";
  }
  protected:
  explicit Rm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.Rm)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class MvReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.MvReq) */ {
 public:
  inline MvReq() : MvReq(nullptr) {}
  ~MvReq() override;
  explicit PROTOBUF_CONSTEXPR MvReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MvReq(const MvReq& from);
  MvReq(MvReq&& from) noexcept
    : MvReq() {
    *this = ::std::move(from);
  }

  inline MvReq& operator=(const MvReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MvReq& operator=(MvReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MvReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MvReq* internal_default_instance() {
    return reinterpret_cast<const MvReq*>(
               &_MvReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(MvReq& a, MvReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MvReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MvReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MvReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MvReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MvReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MvReq& from) {
    MvReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MvReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.MvReq";
  }
  protected:
  explicit MvReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kDstFieldNumber = 2,
    kRequestFieldNumber = 9,
  };
  // string Src = 1;
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // string Dst = 2;
  void clear_dst();
  const std::string& dst() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dst(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dst();
  PROTOBUF_NODISCARD std::string* release_dst();
  void set_allocated_dst(std::string* dst);
  private:
  const std::string& _internal_dst() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst(const std::string& value);
  std::string* _internal_mutable_dst();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.MvReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Mv final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Mv) */ {
 public:
  inline Mv() : Mv(nullptr) {}
  ~Mv() override;
  explicit PROTOBUF_CONSTEXPR Mv(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mv(const Mv& from);
  Mv(Mv&& from) noexcept
    : Mv() {
    *this = ::std::move(from);
  }

  inline Mv& operator=(const Mv& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mv& operator=(Mv&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mv& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mv* internal_default_instance() {
    return reinterpret_cast<const Mv*>(
               &_Mv_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Mv& a, Mv& b) {
    a.Swap(&b);
  }
  inline void Swap(Mv* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mv* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mv* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mv>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mv& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mv& from) {
    Mv::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mv* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Mv";
  }
  protected:
  explicit Mv(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kDstFieldNumber = 2,
    kResponseFieldNumber = 9,
  };
  // string Src = 1;
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // string Dst = 2;
  void clear_dst();
  const std::string& dst() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dst(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dst();
  PROTOBUF_NODISCARD std::string* release_dst();
  void set_allocated_dst(std::string* dst);
  private:
  const std::string& _internal_dst() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst(const std::string& value);
  std::string* _internal_mutable_dst();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.Mv)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class MkdirReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.MkdirReq) */ {
 public:
  inline MkdirReq() : MkdirReq(nullptr) {}
  ~MkdirReq() override;
  explicit PROTOBUF_CONSTEXPR MkdirReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MkdirReq(const MkdirReq& from);
  MkdirReq(MkdirReq&& from) noexcept
    : MkdirReq() {
    *this = ::std::move(from);
  }

  inline MkdirReq& operator=(const MkdirReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MkdirReq& operator=(MkdirReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MkdirReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MkdirReq* internal_default_instance() {
    return reinterpret_cast<const MkdirReq*>(
               &_MkdirReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(MkdirReq& a, MkdirReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MkdirReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MkdirReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MkdirReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MkdirReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MkdirReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MkdirReq& from) {
    MkdirReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MkdirReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.MkdirReq";
  }
  protected:
  explicit MkdirReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kRequestFieldNumber = 9,
  };
  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.MkdirReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Mkdir final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Mkdir) */ {
 public:
  inline Mkdir() : Mkdir(nullptr) {}
  ~Mkdir() override;
  explicit PROTOBUF_CONSTEXPR Mkdir(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mkdir(const Mkdir& from);
  Mkdir(Mkdir&& from) noexcept
    : Mkdir() {
    *this = ::std::move(from);
  }

  inline Mkdir& operator=(const Mkdir& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mkdir& operator=(Mkdir&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mkdir& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mkdir* internal_default_instance() {
    return reinterpret_cast<const Mkdir*>(
               &_Mkdir_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Mkdir& a, Mkdir& b) {
    a.Swap(&b);
  }
  inline void Swap(Mkdir* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mkdir* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mkdir* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mkdir>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mkdir& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mkdir& from) {
    Mkdir::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mkdir* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Mkdir";
  }
  protected:
  explicit Mkdir(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.Mkdir)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class DownloadReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.DownloadReq) */ {
 public:
  inline DownloadReq() : DownloadReq(nullptr) {}
  ~DownloadReq() override;
  explicit PROTOBUF_CONSTEXPR DownloadReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadReq(const DownloadReq& from);
  DownloadReq(DownloadReq&& from) noexcept
    : DownloadReq() {
    *this = ::std::move(from);
  }

  inline DownloadReq& operator=(const DownloadReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadReq& operator=(DownloadReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadReq* internal_default_instance() {
    return reinterpret_cast<const DownloadReq*>(
               &_DownloadReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(DownloadReq& a, DownloadReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DownloadReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DownloadReq& from) {
    DownloadReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.DownloadReq";
  }
  protected:
  explicit DownloadReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kRequestFieldNumber = 9,
    kStartFieldNumber = 2,
    kStopFieldNumber = 3,
    kRecurseFieldNumber = 4,
  };
  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // int64 Start = 2;
  void clear_start();
  int64_t start() const;
  void set_start(int64_t value);
  private:
  int64_t _internal_start() const;
  void _internal_set_start(int64_t value);
  public:

  // int64 Stop = 3;
  void clear_stop();
  int64_t stop() const;
  void set_stop(int64_t value);
  private:
  int64_t _internal_stop() const;
  void _internal_set_stop(int64_t value);
  public:

  // bool Recurse = 4;
  void clear_recurse();
  bool recurse() const;
  void set_recurse(bool value);
  private:
  bool _internal_recurse() const;
  void _internal_set_recurse(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.DownloadReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::sliverpb::Request* request_;
    int64_t start_;
    int64_t stop_;
    bool recurse_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Download final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Download) */ {
 public:
  inline Download() : Download(nullptr) {}
  ~Download() override;
  explicit PROTOBUF_CONSTEXPR Download(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Download(const Download& from);
  Download(Download&& from) noexcept
    : Download() {
    *this = ::std::move(from);
  }

  inline Download& operator=(const Download& from) {
    CopyFrom(from);
    return *this;
  }
  inline Download& operator=(Download&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Download& default_instance() {
    return *internal_default_instance();
  }
  static inline const Download* internal_default_instance() {
    return reinterpret_cast<const Download*>(
               &_Download_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Download& a, Download& b) {
    a.Swap(&b);
  }
  inline void Swap(Download* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Download* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Download* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Download>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Download& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Download& from) {
    Download::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Download* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Download";
  }
  protected:
  explicit Download(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kEncoderFieldNumber = 2,
    kDataFieldNumber = 6,
    kResponseFieldNumber = 9,
    kStartFieldNumber = 4,
    kStopFieldNumber = 5,
    kExistsFieldNumber = 3,
    kIsDirFieldNumber = 7,
    kReadFilesFieldNumber = 8,
    kUnreadableFilesFieldNumber = 10,
  };
  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string Encoder = 2;
  void clear_encoder();
  const std::string& encoder() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encoder(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encoder();
  PROTOBUF_NODISCARD std::string* release_encoder();
  void set_allocated_encoder(std::string* encoder);
  private:
  const std::string& _internal_encoder() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoder(const std::string& value);
  std::string* _internal_mutable_encoder();
  public:

  // bytes Data = 6;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // int64 Start = 4;
  void clear_start();
  int64_t start() const;
  void set_start(int64_t value);
  private:
  int64_t _internal_start() const;
  void _internal_set_start(int64_t value);
  public:

  // int64 Stop = 5;
  void clear_stop();
  int64_t stop() const;
  void set_stop(int64_t value);
  private:
  int64_t _internal_stop() const;
  void _internal_set_stop(int64_t value);
  public:

  // bool Exists = 3;
  void clear_exists();
  bool exists() const;
  void set_exists(bool value);
  private:
  bool _internal_exists() const;
  void _internal_set_exists(bool value);
  public:

  // bool IsDir = 7;
  void clear_isdir();
  bool isdir() const;
  void set_isdir(bool value);
  private:
  bool _internal_isdir() const;
  void _internal_set_isdir(bool value);
  public:

  // int32 ReadFiles = 8;
  void clear_readfiles();
  int32_t readfiles() const;
  void set_readfiles(int32_t value);
  private:
  int32_t _internal_readfiles() const;
  void _internal_set_readfiles(int32_t value);
  public:

  // int32 UnreadableFiles = 10;
  void clear_unreadablefiles();
  int32_t unreadablefiles() const;
  void set_unreadablefiles(int32_t value);
  private:
  int32_t _internal_unreadablefiles() const;
  void _internal_set_unreadablefiles(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.Download)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoder_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::sliverpb::Response* response_;
    int64_t start_;
    int64_t stop_;
    bool exists_;
    bool isdir_;
    int32_t readfiles_;
    int32_t unreadablefiles_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class UploadReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.UploadReq) */ {
 public:
  inline UploadReq() : UploadReq(nullptr) {}
  ~UploadReq() override;
  explicit PROTOBUF_CONSTEXPR UploadReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadReq(const UploadReq& from);
  UploadReq(UploadReq&& from) noexcept
    : UploadReq() {
    *this = ::std::move(from);
  }

  inline UploadReq& operator=(const UploadReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadReq& operator=(UploadReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadReq* internal_default_instance() {
    return reinterpret_cast<const UploadReq*>(
               &_UploadReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(UploadReq& a, UploadReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadReq& from) {
    UploadReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.UploadReq";
  }
  protected:
  explicit UploadReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kEncoderFieldNumber = 2,
    kDataFieldNumber = 3,
    kRequestFieldNumber = 9,
    kIsIOCFieldNumber = 4,
  };
  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string Encoder = 2;
  void clear_encoder();
  const std::string& encoder() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encoder(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encoder();
  PROTOBUF_NODISCARD std::string* release_encoder();
  void set_allocated_encoder(std::string* encoder);
  private:
  const std::string& _internal_encoder() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoder(const std::string& value);
  std::string* _internal_mutable_encoder();
  public:

  // bytes Data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // bool IsIOC = 4;
  void clear_isioc();
  bool isioc() const;
  void set_isioc(bool value);
  private:
  bool _internal_isioc() const;
  void _internal_set_isioc(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.UploadReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoder_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::sliverpb::Request* request_;
    bool isioc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Upload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Upload) */ {
 public:
  inline Upload() : Upload(nullptr) {}
  ~Upload() override;
  explicit PROTOBUF_CONSTEXPR Upload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Upload(const Upload& from);
  Upload(Upload&& from) noexcept
    : Upload() {
    *this = ::std::move(from);
  }

  inline Upload& operator=(const Upload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Upload& operator=(Upload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Upload& default_instance() {
    return *internal_default_instance();
  }
  static inline const Upload* internal_default_instance() {
    return reinterpret_cast<const Upload*>(
               &_Upload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Upload& a, Upload& b) {
    a.Swap(&b);
  }
  inline void Swap(Upload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Upload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Upload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Upload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Upload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Upload& from) {
    Upload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Upload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Upload";
  }
  protected:
  explicit Upload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.Upload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class ProcessDumpReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.ProcessDumpReq) */ {
 public:
  inline ProcessDumpReq() : ProcessDumpReq(nullptr) {}
  ~ProcessDumpReq() override;
  explicit PROTOBUF_CONSTEXPR ProcessDumpReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessDumpReq(const ProcessDumpReq& from);
  ProcessDumpReq(ProcessDumpReq&& from) noexcept
    : ProcessDumpReq() {
    *this = ::std::move(from);
  }

  inline ProcessDumpReq& operator=(const ProcessDumpReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessDumpReq& operator=(ProcessDumpReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessDumpReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessDumpReq* internal_default_instance() {
    return reinterpret_cast<const ProcessDumpReq*>(
               &_ProcessDumpReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ProcessDumpReq& a, ProcessDumpReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessDumpReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessDumpReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessDumpReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessDumpReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessDumpReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessDumpReq& from) {
    ProcessDumpReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessDumpReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.ProcessDumpReq";
  }
  protected:
  explicit ProcessDumpReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
    kPidFieldNumber = 1,
    kTimeoutFieldNumber = 2,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // int32 Pid = 1;
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // int32 Timeout = 2;
  void clear_timeout();
  int32_t timeout() const;
  void set_timeout(int32_t value);
  private:
  int32_t _internal_timeout() const;
  void _internal_set_timeout(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.ProcessDumpReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    int32_t pid_;
    int32_t timeout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class ProcessDump final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.ProcessDump) */ {
 public:
  inline ProcessDump() : ProcessDump(nullptr) {}
  ~ProcessDump() override;
  explicit PROTOBUF_CONSTEXPR ProcessDump(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessDump(const ProcessDump& from);
  ProcessDump(ProcessDump&& from) noexcept
    : ProcessDump() {
    *this = ::std::move(from);
  }

  inline ProcessDump& operator=(const ProcessDump& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessDump& operator=(ProcessDump&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessDump& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessDump* internal_default_instance() {
    return reinterpret_cast<const ProcessDump*>(
               &_ProcessDump_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ProcessDump& a, ProcessDump& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessDump* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessDump* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessDump* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessDump>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessDump& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessDump& from) {
    ProcessDump::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessDump* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.ProcessDump";
  }
  protected:
  explicit ProcessDump(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // bytes Data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.ProcessDump)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RunAsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RunAsReq) */ {
 public:
  inline RunAsReq() : RunAsReq(nullptr) {}
  ~RunAsReq() override;
  explicit PROTOBUF_CONSTEXPR RunAsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RunAsReq(const RunAsReq& from);
  RunAsReq(RunAsReq&& from) noexcept
    : RunAsReq() {
    *this = ::std::move(from);
  }

  inline RunAsReq& operator=(const RunAsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunAsReq& operator=(RunAsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunAsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunAsReq* internal_default_instance() {
    return reinterpret_cast<const RunAsReq*>(
               &_RunAsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(RunAsReq& a, RunAsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RunAsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunAsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunAsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RunAsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RunAsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RunAsReq& from) {
    RunAsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunAsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RunAsReq";
  }
  protected:
  explicit RunAsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kProcessNameFieldNumber = 2,
    kArgsFieldNumber = 3,
    kDomainFieldNumber = 4,
    kPasswordFieldNumber = 5,
    kRequestFieldNumber = 9,
    kHideWindowFieldNumber = 6,
    kNetOnlyFieldNumber = 7,
  };
  // string Username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string ProcessName = 2;
  void clear_processname();
  const std::string& processname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_processname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_processname();
  PROTOBUF_NODISCARD std::string* release_processname();
  void set_allocated_processname(std::string* processname);
  private:
  const std::string& _internal_processname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processname(const std::string& value);
  std::string* _internal_mutable_processname();
  public:

  // string Args = 3;
  void clear_args();
  const std::string& args() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_args(ArgT0&& arg0, ArgT... args);
  std::string* mutable_args();
  PROTOBUF_NODISCARD std::string* release_args();
  void set_allocated_args(std::string* args);
  private:
  const std::string& _internal_args() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_args(const std::string& value);
  std::string* _internal_mutable_args();
  public:

  // string Domain = 4;
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // string Password = 5;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // bool HideWindow = 6;
  void clear_hidewindow();
  bool hidewindow() const;
  void set_hidewindow(bool value);
  private:
  bool _internal_hidewindow() const;
  void _internal_set_hidewindow(bool value);
  public:

  // bool NetOnly = 7;
  void clear_netonly();
  bool netonly() const;
  void set_netonly(bool value);
  private:
  bool _internal_netonly() const;
  void _internal_set_netonly(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.RunAsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr processname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::sliverpb::Request* request_;
    bool hidewindow_;
    bool netonly_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RunAs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RunAs) */ {
 public:
  inline RunAs() : RunAs(nullptr) {}
  ~RunAs() override;
  explicit PROTOBUF_CONSTEXPR RunAs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RunAs(const RunAs& from);
  RunAs(RunAs&& from) noexcept
    : RunAs() {
    *this = ::std::move(from);
  }

  inline RunAs& operator=(const RunAs& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunAs& operator=(RunAs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunAs& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunAs* internal_default_instance() {
    return reinterpret_cast<const RunAs*>(
               &_RunAs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(RunAs& a, RunAs& b) {
    a.Swap(&b);
  }
  inline void Swap(RunAs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunAs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunAs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RunAs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RunAs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RunAs& from) {
    RunAs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunAs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RunAs";
  }
  protected:
  explicit RunAs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // string Output = 1;
  void clear_output();
  const std::string& output() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output();
  PROTOBUF_NODISCARD std::string* release_output();
  void set_allocated_output(std::string* output);
  private:
  const std::string& _internal_output() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output(const std::string& value);
  std::string* _internal_mutable_output();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.RunAs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class ImpersonateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.ImpersonateReq) */ {
 public:
  inline ImpersonateReq() : ImpersonateReq(nullptr) {}
  ~ImpersonateReq() override;
  explicit PROTOBUF_CONSTEXPR ImpersonateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImpersonateReq(const ImpersonateReq& from);
  ImpersonateReq(ImpersonateReq&& from) noexcept
    : ImpersonateReq() {
    *this = ::std::move(from);
  }

  inline ImpersonateReq& operator=(const ImpersonateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImpersonateReq& operator=(ImpersonateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImpersonateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImpersonateReq* internal_default_instance() {
    return reinterpret_cast<const ImpersonateReq*>(
               &_ImpersonateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ImpersonateReq& a, ImpersonateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ImpersonateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImpersonateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImpersonateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImpersonateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImpersonateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImpersonateReq& from) {
    ImpersonateReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImpersonateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.ImpersonateReq";
  }
  protected:
  explicit ImpersonateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kRequestFieldNumber = 9,
  };
  // string Username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.ImpersonateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Impersonate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Impersonate) */ {
 public:
  inline Impersonate() : Impersonate(nullptr) {}
  ~Impersonate() override;
  explicit PROTOBUF_CONSTEXPR Impersonate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Impersonate(const Impersonate& from);
  Impersonate(Impersonate&& from) noexcept
    : Impersonate() {
    *this = ::std::move(from);
  }

  inline Impersonate& operator=(const Impersonate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Impersonate& operator=(Impersonate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Impersonate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Impersonate* internal_default_instance() {
    return reinterpret_cast<const Impersonate*>(
               &_Impersonate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(Impersonate& a, Impersonate& b) {
    a.Swap(&b);
  }
  inline void Swap(Impersonate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Impersonate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Impersonate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Impersonate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Impersonate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Impersonate& from) {
    Impersonate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Impersonate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Impersonate";
  }
  protected:
  explicit Impersonate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 9,
  };
  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.Impersonate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RevToSelfReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RevToSelfReq) */ {
 public:
  inline RevToSelfReq() : RevToSelfReq(nullptr) {}
  ~RevToSelfReq() override;
  explicit PROTOBUF_CONSTEXPR RevToSelfReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RevToSelfReq(const RevToSelfReq& from);
  RevToSelfReq(RevToSelfReq&& from) noexcept
    : RevToSelfReq() {
    *this = ::std::move(from);
  }

  inline RevToSelfReq& operator=(const RevToSelfReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RevToSelfReq& operator=(RevToSelfReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RevToSelfReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RevToSelfReq* internal_default_instance() {
    return reinterpret_cast<const RevToSelfReq*>(
               &_RevToSelfReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(RevToSelfReq& a, RevToSelfReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RevToSelfReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RevToSelfReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RevToSelfReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RevToSelfReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RevToSelfReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RevToSelfReq& from) {
    RevToSelfReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RevToSelfReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RevToSelfReq";
  }
  protected:
  explicit RevToSelfReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.RevToSelfReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RevToSelf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RevToSelf) */ {
 public:
  inline RevToSelf() : RevToSelf(nullptr) {}
  ~RevToSelf() override;
  explicit PROTOBUF_CONSTEXPR RevToSelf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RevToSelf(const RevToSelf& from);
  RevToSelf(RevToSelf&& from) noexcept
    : RevToSelf() {
    *this = ::std::move(from);
  }

  inline RevToSelf& operator=(const RevToSelf& from) {
    CopyFrom(from);
    return *this;
  }
  inline RevToSelf& operator=(RevToSelf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RevToSelf& default_instance() {
    return *internal_default_instance();
  }
  static inline const RevToSelf* internal_default_instance() {
    return reinterpret_cast<const RevToSelf*>(
               &_RevToSelf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(RevToSelf& a, RevToSelf& b) {
    a.Swap(&b);
  }
  inline void Swap(RevToSelf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RevToSelf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RevToSelf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RevToSelf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RevToSelf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RevToSelf& from) {
    RevToSelf::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RevToSelf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RevToSelf";
  }
  protected:
  explicit RevToSelf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 9,
  };
  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.RevToSelf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class CurrentTokenOwnerReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.CurrentTokenOwnerReq) */ {
 public:
  inline CurrentTokenOwnerReq() : CurrentTokenOwnerReq(nullptr) {}
  ~CurrentTokenOwnerReq() override;
  explicit PROTOBUF_CONSTEXPR CurrentTokenOwnerReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CurrentTokenOwnerReq(const CurrentTokenOwnerReq& from);
  CurrentTokenOwnerReq(CurrentTokenOwnerReq&& from) noexcept
    : CurrentTokenOwnerReq() {
    *this = ::std::move(from);
  }

  inline CurrentTokenOwnerReq& operator=(const CurrentTokenOwnerReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrentTokenOwnerReq& operator=(CurrentTokenOwnerReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurrentTokenOwnerReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurrentTokenOwnerReq* internal_default_instance() {
    return reinterpret_cast<const CurrentTokenOwnerReq*>(
               &_CurrentTokenOwnerReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(CurrentTokenOwnerReq& a, CurrentTokenOwnerReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrentTokenOwnerReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrentTokenOwnerReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurrentTokenOwnerReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CurrentTokenOwnerReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CurrentTokenOwnerReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CurrentTokenOwnerReq& from) {
    CurrentTokenOwnerReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrentTokenOwnerReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.CurrentTokenOwnerReq";
  }
  protected:
  explicit CurrentTokenOwnerReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.CurrentTokenOwnerReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class CurrentTokenOwner final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.CurrentTokenOwner) */ {
 public:
  inline CurrentTokenOwner() : CurrentTokenOwner(nullptr) {}
  ~CurrentTokenOwner() override;
  explicit PROTOBUF_CONSTEXPR CurrentTokenOwner(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CurrentTokenOwner(const CurrentTokenOwner& from);
  CurrentTokenOwner(CurrentTokenOwner&& from) noexcept
    : CurrentTokenOwner() {
    *this = ::std::move(from);
  }

  inline CurrentTokenOwner& operator=(const CurrentTokenOwner& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrentTokenOwner& operator=(CurrentTokenOwner&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurrentTokenOwner& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurrentTokenOwner* internal_default_instance() {
    return reinterpret_cast<const CurrentTokenOwner*>(
               &_CurrentTokenOwner_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(CurrentTokenOwner& a, CurrentTokenOwner& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrentTokenOwner* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrentTokenOwner* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurrentTokenOwner* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CurrentTokenOwner>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CurrentTokenOwner& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CurrentTokenOwner& from) {
    CurrentTokenOwner::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrentTokenOwner* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.CurrentTokenOwner";
  }
  protected:
  explicit CurrentTokenOwner(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // string Output = 1;
  void clear_output();
  const std::string& output() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output();
  PROTOBUF_NODISCARD std::string* release_output();
  void set_allocated_output(std::string* output);
  private:
  const std::string& _internal_output() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output(const std::string& value);
  std::string* _internal_mutable_output();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.CurrentTokenOwner)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class InvokeGetSystemReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.InvokeGetSystemReq) */ {
 public:
  inline InvokeGetSystemReq() : InvokeGetSystemReq(nullptr) {}
  ~InvokeGetSystemReq() override;
  explicit PROTOBUF_CONSTEXPR InvokeGetSystemReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeGetSystemReq(const InvokeGetSystemReq& from);
  InvokeGetSystemReq(InvokeGetSystemReq&& from) noexcept
    : InvokeGetSystemReq() {
    *this = ::std::move(from);
  }

  inline InvokeGetSystemReq& operator=(const InvokeGetSystemReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeGetSystemReq& operator=(InvokeGetSystemReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeGetSystemReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeGetSystemReq* internal_default_instance() {
    return reinterpret_cast<const InvokeGetSystemReq*>(
               &_InvokeGetSystemReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(InvokeGetSystemReq& a, InvokeGetSystemReq& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeGetSystemReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeGetSystemReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeGetSystemReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeGetSystemReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeGetSystemReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeGetSystemReq& from) {
    InvokeGetSystemReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeGetSystemReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.InvokeGetSystemReq";
  }
  protected:
  explicit InvokeGetSystemReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kHostingProcessFieldNumber = 2,
    kRequestFieldNumber = 9,
  };
  // bytes Data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string HostingProcess = 2;
  void clear_hostingprocess();
  const std::string& hostingprocess() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostingprocess(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostingprocess();
  PROTOBUF_NODISCARD std::string* release_hostingprocess();
  void set_allocated_hostingprocess(std::string* hostingprocess);
  private:
  const std::string& _internal_hostingprocess() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostingprocess(const std::string& value);
  std::string* _internal_mutable_hostingprocess();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.InvokeGetSystemReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostingprocess_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class GetSystem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.GetSystem) */ {
 public:
  inline GetSystem() : GetSystem(nullptr) {}
  ~GetSystem() override;
  explicit PROTOBUF_CONSTEXPR GetSystem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSystem(const GetSystem& from);
  GetSystem(GetSystem&& from) noexcept
    : GetSystem() {
    *this = ::std::move(from);
  }

  inline GetSystem& operator=(const GetSystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSystem& operator=(GetSystem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSystem& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSystem* internal_default_instance() {
    return reinterpret_cast<const GetSystem*>(
               &_GetSystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(GetSystem& a, GetSystem& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSystem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSystem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSystem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSystem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSystem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSystem& from) {
    GetSystem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSystem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.GetSystem";
  }
  protected:
  explicit GetSystem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 9,
  };
  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.GetSystem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class MakeTokenReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.MakeTokenReq) */ {
 public:
  inline MakeTokenReq() : MakeTokenReq(nullptr) {}
  ~MakeTokenReq() override;
  explicit PROTOBUF_CONSTEXPR MakeTokenReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MakeTokenReq(const MakeTokenReq& from);
  MakeTokenReq(MakeTokenReq&& from) noexcept
    : MakeTokenReq() {
    *this = ::std::move(from);
  }

  inline MakeTokenReq& operator=(const MakeTokenReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MakeTokenReq& operator=(MakeTokenReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MakeTokenReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MakeTokenReq* internal_default_instance() {
    return reinterpret_cast<const MakeTokenReq*>(
               &_MakeTokenReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(MakeTokenReq& a, MakeTokenReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MakeTokenReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MakeTokenReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MakeTokenReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MakeTokenReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MakeTokenReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MakeTokenReq& from) {
    MakeTokenReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MakeTokenReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.MakeTokenReq";
  }
  protected:
  explicit MakeTokenReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kDomainFieldNumber = 3,
    kRequestFieldNumber = 9,
    kLogonTypeFieldNumber = 4,
  };
  // string Username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string Password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string Domain = 3;
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // uint32 LogonType = 4;
  void clear_logontype();
  uint32_t logontype() const;
  void set_logontype(uint32_t value);
  private:
  uint32_t _internal_logontype() const;
  void _internal_set_logontype(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.MakeTokenReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
    ::sliverpb::Request* request_;
    uint32_t logontype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class MakeToken final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.MakeToken) */ {
 public:
  inline MakeToken() : MakeToken(nullptr) {}
  ~MakeToken() override;
  explicit PROTOBUF_CONSTEXPR MakeToken(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MakeToken(const MakeToken& from);
  MakeToken(MakeToken&& from) noexcept
    : MakeToken() {
    *this = ::std::move(from);
  }

  inline MakeToken& operator=(const MakeToken& from) {
    CopyFrom(from);
    return *this;
  }
  inline MakeToken& operator=(MakeToken&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MakeToken& default_instance() {
    return *internal_default_instance();
  }
  static inline const MakeToken* internal_default_instance() {
    return reinterpret_cast<const MakeToken*>(
               &_MakeToken_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(MakeToken& a, MakeToken& b) {
    a.Swap(&b);
  }
  inline void Swap(MakeToken* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MakeToken* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MakeToken* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MakeToken>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MakeToken& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MakeToken& from) {
    MakeToken::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MakeToken* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.MakeToken";
  }
  protected:
  explicit MakeToken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 9,
  };
  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.MakeToken)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Token final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Token) */ {
 public:
  inline Token() : Token(nullptr) {}
  ~Token() override;
  explicit PROTOBUF_CONSTEXPR Token(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Token(const Token& from);
  Token(Token&& from) noexcept
    : Token() {
    *this = ::std::move(from);
  }

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  inline Token& operator=(Token&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Token& default_instance() {
    return *internal_default_instance();
  }
  static inline const Token* internal_default_instance() {
    return reinterpret_cast<const Token*>(
               &_Token_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(Token& a, Token& b) {
    a.Swap(&b);
  }
  inline void Swap(Token* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Token* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Token* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Token>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Token& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Token& from) {
    Token::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Token* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Token";
  }
  protected:
  explicit Token(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 4,
    kTokenIdFieldNumber = 1,
    kLogonSessionIdFieldNumber = 2,
    kLogonTypeFieldNumber = 3,
    kTokenTypeFieldNumber = 5,
    kTokenImpLevelFieldNumber = 6,
    kPrivilegesCountFieldNumber = 7,
    kTokenIntegrityFieldNumber = 8,
  };
  // string Username = 4;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // int64 TokenId = 1;
  void clear_tokenid();
  int64_t tokenid() const;
  void set_tokenid(int64_t value);
  private:
  int64_t _internal_tokenid() const;
  void _internal_set_tokenid(int64_t value);
  public:

  // int64 LogonSessionId = 2;
  void clear_logonsessionid();
  int64_t logonsessionid() const;
  void set_logonsessionid(int64_t value);
  private:
  int64_t _internal_logonsessionid() const;
  void _internal_set_logonsessionid(int64_t value);
  public:

  // int32 LogonType = 3;
  void clear_logontype();
  int32_t logontype() const;
  void set_logontype(int32_t value);
  private:
  int32_t _internal_logontype() const;
  void _internal_set_logontype(int32_t value);
  public:

  // int32 TokenType = 5;
  void clear_tokentype();
  int32_t tokentype() const;
  void set_tokentype(int32_t value);
  private:
  int32_t _internal_tokentype() const;
  void _internal_set_tokentype(int32_t value);
  public:

  // int32 TokenImpLevel = 6;
  void clear_tokenimplevel();
  int32_t tokenimplevel() const;
  void set_tokenimplevel(int32_t value);
  private:
  int32_t _internal_tokenimplevel() const;
  void _internal_set_tokenimplevel(int32_t value);
  public:

  // int32 PrivilegesCount = 7;
  void clear_privilegescount();
  int32_t privilegescount() const;
  void set_privilegescount(int32_t value);
  private:
  int32_t _internal_privilegescount() const;
  void _internal_set_privilegescount(int32_t value);
  public:

  // int32 TokenIntegrity = 8;
  void clear_tokenintegrity();
  int32_t tokenintegrity() const;
  void set_tokenintegrity(int32_t value);
  private:
  int32_t _internal_tokenintegrity() const;
  void _internal_set_tokenintegrity(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.Token)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    int64_t tokenid_;
    int64_t logonsessionid_;
    int32_t logontype_;
    int32_t tokentype_;
    int32_t tokenimplevel_;
    int32_t privilegescount_;
    int32_t tokenintegrity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class ListTokensReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.ListTokensReq) */ {
 public:
  inline ListTokensReq() : ListTokensReq(nullptr) {}
  ~ListTokensReq() override;
  explicit PROTOBUF_CONSTEXPR ListTokensReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTokensReq(const ListTokensReq& from);
  ListTokensReq(ListTokensReq&& from) noexcept
    : ListTokensReq() {
    *this = ::std::move(from);
  }

  inline ListTokensReq& operator=(const ListTokensReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTokensReq& operator=(ListTokensReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTokensReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTokensReq* internal_default_instance() {
    return reinterpret_cast<const ListTokensReq*>(
               &_ListTokensReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(ListTokensReq& a, ListTokensReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTokensReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTokensReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTokensReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTokensReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTokensReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListTokensReq& from) {
    ListTokensReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTokensReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.ListTokensReq";
  }
  protected:
  explicit ListTokensReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.ListTokensReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class ListTokens final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.ListTokens) */ {
 public:
  inline ListTokens() : ListTokens(nullptr) {}
  ~ListTokens() override;
  explicit PROTOBUF_CONSTEXPR ListTokens(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTokens(const ListTokens& from);
  ListTokens(ListTokens&& from) noexcept
    : ListTokens() {
    *this = ::std::move(from);
  }

  inline ListTokens& operator=(const ListTokens& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTokens& operator=(ListTokens&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTokens& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTokens* internal_default_instance() {
    return reinterpret_cast<const ListTokens*>(
               &_ListTokens_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(ListTokens& a, ListTokens& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTokens* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTokens* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTokens* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTokens>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTokens& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListTokens& from) {
    ListTokens::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTokens* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.ListTokens";
  }
  protected:
  explicit ListTokens(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokensFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // repeated .sliverpb.Token Tokens = 1;
  int tokens_size() const;
  private:
  int _internal_tokens_size() const;
  public:
  void clear_tokens();
  ::sliverpb::Token* mutable_tokens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::Token >*
      mutable_tokens();
  private:
  const ::sliverpb::Token& _internal_tokens(int index) const;
  ::sliverpb::Token* _internal_add_tokens();
  public:
  const ::sliverpb::Token& tokens(int index) const;
  ::sliverpb::Token* add_tokens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::Token >&
      tokens() const;

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.ListTokens)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::Token > tokens_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class TaskReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.TaskReq) */ {
 public:
  inline TaskReq() : TaskReq(nullptr) {}
  ~TaskReq() override;
  explicit PROTOBUF_CONSTEXPR TaskReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskReq(const TaskReq& from);
  TaskReq(TaskReq&& from) noexcept
    : TaskReq() {
    *this = ::std::move(from);
  }

  inline TaskReq& operator=(const TaskReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskReq& operator=(TaskReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskReq* internal_default_instance() {
    return reinterpret_cast<const TaskReq*>(
               &_TaskReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(TaskReq& a, TaskReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskReq& from) {
    TaskReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.TaskReq";
  }
  protected:
  explicit TaskReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncoderFieldNumber = 1,
    kDataFieldNumber = 4,
    kRequestFieldNumber = 9,
    kRWXPagesFieldNumber = 2,
    kPidFieldNumber = 3,
  };
  // string Encoder = 1;
  void clear_encoder();
  const std::string& encoder() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encoder(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encoder();
  PROTOBUF_NODISCARD std::string* release_encoder();
  void set_allocated_encoder(std::string* encoder);
  private:
  const std::string& _internal_encoder() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoder(const std::string& value);
  std::string* _internal_mutable_encoder();
  public:

  // bytes Data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // bool RWXPages = 2;
  void clear_rwxpages();
  bool rwxpages() const;
  void set_rwxpages(bool value);
  private:
  bool _internal_rwxpages() const;
  void _internal_set_rwxpages(bool value);
  public:

  // uint32 Pid = 3;
  void clear_pid();
  uint32_t pid() const;
  void set_pid(uint32_t value);
  private:
  uint32_t _internal_pid() const;
  void _internal_set_pid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.TaskReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoder_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::sliverpb::Request* request_;
    bool rwxpages_;
    uint32_t pid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Task final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  ~Task() override;
  explicit PROTOBUF_CONSTEXPR Task(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Task(const Task& from);
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Task* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Task* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Task>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Task& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Task& from) {
    Task::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Task";
  }
  protected:
  explicit Task(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 9,
  };
  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.Task)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class ExecuteAssemblyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.ExecuteAssemblyReq) */ {
 public:
  inline ExecuteAssemblyReq() : ExecuteAssemblyReq(nullptr) {}
  ~ExecuteAssemblyReq() override;
  explicit PROTOBUF_CONSTEXPR ExecuteAssemblyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteAssemblyReq(const ExecuteAssemblyReq& from);
  ExecuteAssemblyReq(ExecuteAssemblyReq&& from) noexcept
    : ExecuteAssemblyReq() {
    *this = ::std::move(from);
  }

  inline ExecuteAssemblyReq& operator=(const ExecuteAssemblyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteAssemblyReq& operator=(ExecuteAssemblyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteAssemblyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteAssemblyReq* internal_default_instance() {
    return reinterpret_cast<const ExecuteAssemblyReq*>(
               &_ExecuteAssemblyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(ExecuteAssemblyReq& a, ExecuteAssemblyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteAssemblyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteAssemblyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteAssemblyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteAssemblyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteAssemblyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteAssemblyReq& from) {
    ExecuteAssemblyReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteAssemblyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.ExecuteAssemblyReq";
  }
  protected:
  explicit ExecuteAssemblyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessArgsFieldNumber = 11,
    kAssemblyFieldNumber = 1,
    kArgumentsFieldNumber = 2,
    kProcessFieldNumber = 3,
    kArchFieldNumber = 5,
    kClassNameFieldNumber = 6,
    kMethodFieldNumber = 7,
    kAppDomainFieldNumber = 8,
    kRuntimeFieldNumber = 13,
    kRequestFieldNumber = 9,
    kPPidFieldNumber = 10,
    kIsDLLFieldNumber = 4,
    kInProcessFieldNumber = 12,
    kAmsiBypassFieldNumber = 14,
    kEtwBypassFieldNumber = 15,
  };
  // repeated string ProcessArgs = 11;
  int processargs_size() const;
  private:
  int _internal_processargs_size() const;
  public:
  void clear_processargs();
  const std::string& processargs(int index) const;
  std::string* mutable_processargs(int index);
  void set_processargs(int index, const std::string& value);
  void set_processargs(int index, std::string&& value);
  void set_processargs(int index, const char* value);
  void set_processargs(int index, const char* value, size_t size);
  std::string* add_processargs();
  void add_processargs(const std::string& value);
  void add_processargs(std::string&& value);
  void add_processargs(const char* value);
  void add_processargs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& processargs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_processargs();
  private:
  const std::string& _internal_processargs(int index) const;
  std::string* _internal_add_processargs();
  public:

  // bytes Assembly = 1;
  void clear_assembly();
  const std::string& assembly() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_assembly(ArgT0&& arg0, ArgT... args);
  std::string* mutable_assembly();
  PROTOBUF_NODISCARD std::string* release_assembly();
  void set_allocated_assembly(std::string* assembly);
  private:
  const std::string& _internal_assembly() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assembly(const std::string& value);
  std::string* _internal_mutable_assembly();
  public:

  // string Arguments = 2;
  void clear_arguments();
  const std::string& arguments() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arguments(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arguments();
  PROTOBUF_NODISCARD std::string* release_arguments();
  void set_allocated_arguments(std::string* arguments);
  private:
  const std::string& _internal_arguments() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arguments(const std::string& value);
  std::string* _internal_mutable_arguments();
  public:

  // string Process = 3;
  void clear_process();
  const std::string& process() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_process(ArgT0&& arg0, ArgT... args);
  std::string* mutable_process();
  PROTOBUF_NODISCARD std::string* release_process();
  void set_allocated_process(std::string* process);
  private:
  const std::string& _internal_process() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_process(const std::string& value);
  std::string* _internal_mutable_process();
  public:

  // string Arch = 5;
  void clear_arch();
  const std::string& arch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arch();
  PROTOBUF_NODISCARD std::string* release_arch();
  void set_allocated_arch(std::string* arch);
  private:
  const std::string& _internal_arch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arch(const std::string& value);
  std::string* _internal_mutable_arch();
  public:

  // string ClassName = 6;
  void clear_classname();
  const std::string& classname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_classname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_classname();
  PROTOBUF_NODISCARD std::string* release_classname();
  void set_allocated_classname(std::string* classname);
  private:
  const std::string& _internal_classname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_classname(const std::string& value);
  std::string* _internal_mutable_classname();
  public:

  // string Method = 7;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // string AppDomain = 8;
  void clear_appdomain();
  const std::string& appdomain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appdomain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appdomain();
  PROTOBUF_NODISCARD std::string* release_appdomain();
  void set_allocated_appdomain(std::string* appdomain);
  private:
  const std::string& _internal_appdomain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appdomain(const std::string& value);
  std::string* _internal_mutable_appdomain();
  public:

  // string Runtime = 13;
  void clear_runtime();
  const std::string& runtime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_runtime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_runtime();
  PROTOBUF_NODISCARD std::string* release_runtime();
  void set_allocated_runtime(std::string* runtime);
  private:
  const std::string& _internal_runtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_runtime(const std::string& value);
  std::string* _internal_mutable_runtime();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // uint32 PPid = 10;
  void clear_ppid();
  uint32_t ppid() const;
  void set_ppid(uint32_t value);
  private:
  uint32_t _internal_ppid() const;
  void _internal_set_ppid(uint32_t value);
  public:

  // bool IsDLL = 4;
  void clear_isdll();
  bool isdll() const;
  void set_isdll(bool value);
  private:
  bool _internal_isdll() const;
  void _internal_set_isdll(bool value);
  public:

  // bool InProcess = 12;
  void clear_inprocess();
  bool inprocess() const;
  void set_inprocess(bool value);
  private:
  bool _internal_inprocess() const;
  void _internal_set_inprocess(bool value);
  public:

  // bool AmsiBypass = 14;
  void clear_amsibypass();
  bool amsibypass() const;
  void set_amsibypass(bool value);
  private:
  bool _internal_amsibypass() const;
  void _internal_set_amsibypass(bool value);
  public:

  // bool EtwBypass = 15;
  void clear_etwbypass();
  bool etwbypass() const;
  void set_etwbypass(bool value);
  private:
  bool _internal_etwbypass() const;
  void _internal_set_etwbypass(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.ExecuteAssemblyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> processargs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assembly_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arguments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr process_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr classname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appdomain_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr runtime_;
    ::sliverpb::Request* request_;
    uint32_t ppid_;
    bool isdll_;
    bool inprocess_;
    bool amsibypass_;
    bool etwbypass_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class InvokeExecuteAssemblyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.InvokeExecuteAssemblyReq) */ {
 public:
  inline InvokeExecuteAssemblyReq() : InvokeExecuteAssemblyReq(nullptr) {}
  ~InvokeExecuteAssemblyReq() override;
  explicit PROTOBUF_CONSTEXPR InvokeExecuteAssemblyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeExecuteAssemblyReq(const InvokeExecuteAssemblyReq& from);
  InvokeExecuteAssemblyReq(InvokeExecuteAssemblyReq&& from) noexcept
    : InvokeExecuteAssemblyReq() {
    *this = ::std::move(from);
  }

  inline InvokeExecuteAssemblyReq& operator=(const InvokeExecuteAssemblyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeExecuteAssemblyReq& operator=(InvokeExecuteAssemblyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeExecuteAssemblyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeExecuteAssemblyReq* internal_default_instance() {
    return reinterpret_cast<const InvokeExecuteAssemblyReq*>(
               &_InvokeExecuteAssemblyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(InvokeExecuteAssemblyReq& a, InvokeExecuteAssemblyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeExecuteAssemblyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeExecuteAssemblyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeExecuteAssemblyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeExecuteAssemblyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeExecuteAssemblyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeExecuteAssemblyReq& from) {
    InvokeExecuteAssemblyReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeExecuteAssemblyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.InvokeExecuteAssemblyReq";
  }
  protected:
  explicit InvokeExecuteAssemblyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessArgsFieldNumber = 11,
    kDataFieldNumber = 1,
    kProcessFieldNumber = 2,
    kRequestFieldNumber = 9,
    kPPidFieldNumber = 10,
  };
  // repeated string ProcessArgs = 11;
  int processargs_size() const;
  private:
  int _internal_processargs_size() const;
  public:
  void clear_processargs();
  const std::string& processargs(int index) const;
  std::string* mutable_processargs(int index);
  void set_processargs(int index, const std::string& value);
  void set_processargs(int index, std::string&& value);
  void set_processargs(int index, const char* value);
  void set_processargs(int index, const char* value, size_t size);
  std::string* add_processargs();
  void add_processargs(const std::string& value);
  void add_processargs(std::string&& value);
  void add_processargs(const char* value);
  void add_processargs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& processargs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_processargs();
  private:
  const std::string& _internal_processargs(int index) const;
  std::string* _internal_add_processargs();
  public:

  // bytes Data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string process = 2;
  void clear_process();
  const std::string& process() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_process(ArgT0&& arg0, ArgT... args);
  std::string* mutable_process();
  PROTOBUF_NODISCARD std::string* release_process();
  void set_allocated_process(std::string* process);
  private:
  const std::string& _internal_process() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_process(const std::string& value);
  std::string* _internal_mutable_process();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // uint32 PPid = 10;
  void clear_ppid();
  uint32_t ppid() const;
  void set_ppid(uint32_t value);
  private:
  uint32_t _internal_ppid() const;
  void _internal_set_ppid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.InvokeExecuteAssemblyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> processargs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr process_;
    ::sliverpb::Request* request_;
    uint32_t ppid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class InvokeInProcExecuteAssemblyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.InvokeInProcExecuteAssemblyReq) */ {
 public:
  inline InvokeInProcExecuteAssemblyReq() : InvokeInProcExecuteAssemblyReq(nullptr) {}
  ~InvokeInProcExecuteAssemblyReq() override;
  explicit PROTOBUF_CONSTEXPR InvokeInProcExecuteAssemblyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeInProcExecuteAssemblyReq(const InvokeInProcExecuteAssemblyReq& from);
  InvokeInProcExecuteAssemblyReq(InvokeInProcExecuteAssemblyReq&& from) noexcept
    : InvokeInProcExecuteAssemblyReq() {
    *this = ::std::move(from);
  }

  inline InvokeInProcExecuteAssemblyReq& operator=(const InvokeInProcExecuteAssemblyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeInProcExecuteAssemblyReq& operator=(InvokeInProcExecuteAssemblyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeInProcExecuteAssemblyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeInProcExecuteAssemblyReq* internal_default_instance() {
    return reinterpret_cast<const InvokeInProcExecuteAssemblyReq*>(
               &_InvokeInProcExecuteAssemblyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(InvokeInProcExecuteAssemblyReq& a, InvokeInProcExecuteAssemblyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeInProcExecuteAssemblyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeInProcExecuteAssemblyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeInProcExecuteAssemblyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeInProcExecuteAssemblyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeInProcExecuteAssemblyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeInProcExecuteAssemblyReq& from) {
    InvokeInProcExecuteAssemblyReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeInProcExecuteAssemblyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.InvokeInProcExecuteAssemblyReq";
  }
  protected:
  explicit InvokeInProcExecuteAssemblyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 2,
    kDataFieldNumber = 1,
    kRuntimeFieldNumber = 3,
    kRequestFieldNumber = 9,
    kAmsiBypassFieldNumber = 4,
    kEtwBypassFieldNumber = 5,
  };
  // repeated string Arguments = 2;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  const std::string& arguments(int index) const;
  std::string* mutable_arguments(int index);
  void set_arguments(int index, const std::string& value);
  void set_arguments(int index, std::string&& value);
  void set_arguments(int index, const char* value);
  void set_arguments(int index, const char* value, size_t size);
  std::string* add_arguments();
  void add_arguments(const std::string& value);
  void add_arguments(std::string&& value);
  void add_arguments(const char* value);
  void add_arguments(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& arguments() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_arguments();
  private:
  const std::string& _internal_arguments(int index) const;
  std::string* _internal_add_arguments();
  public:

  // bytes Data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string Runtime = 3;
  void clear_runtime();
  const std::string& runtime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_runtime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_runtime();
  PROTOBUF_NODISCARD std::string* release_runtime();
  void set_allocated_runtime(std::string* runtime);
  private:
  const std::string& _internal_runtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_runtime(const std::string& value);
  std::string* _internal_mutable_runtime();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // bool AmsiBypass = 4;
  void clear_amsibypass();
  bool amsibypass() const;
  void set_amsibypass(bool value);
  private:
  bool _internal_amsibypass() const;
  void _internal_set_amsibypass(bool value);
  public:

  // bool EtwBypass = 5;
  void clear_etwbypass();
  bool etwbypass() const;
  void set_etwbypass(bool value);
  private:
  bool _internal_etwbypass() const;
  void _internal_set_etwbypass(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.InvokeInProcExecuteAssemblyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> arguments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr runtime_;
    ::sliverpb::Request* request_;
    bool amsibypass_;
    bool etwbypass_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class ExecuteAssembly final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.ExecuteAssembly) */ {
 public:
  inline ExecuteAssembly() : ExecuteAssembly(nullptr) {}
  ~ExecuteAssembly() override;
  explicit PROTOBUF_CONSTEXPR ExecuteAssembly(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteAssembly(const ExecuteAssembly& from);
  ExecuteAssembly(ExecuteAssembly&& from) noexcept
    : ExecuteAssembly() {
    *this = ::std::move(from);
  }

  inline ExecuteAssembly& operator=(const ExecuteAssembly& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteAssembly& operator=(ExecuteAssembly&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteAssembly& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteAssembly* internal_default_instance() {
    return reinterpret_cast<const ExecuteAssembly*>(
               &_ExecuteAssembly_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(ExecuteAssembly& a, ExecuteAssembly& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteAssembly* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteAssembly* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteAssembly* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteAssembly>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteAssembly& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteAssembly& from) {
    ExecuteAssembly::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteAssembly* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.ExecuteAssembly";
  }
  protected:
  explicit ExecuteAssembly(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // bytes Output = 1;
  void clear_output();
  const std::string& output() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output();
  PROTOBUF_NODISCARD std::string* release_output();
  void set_allocated_output(std::string* output);
  private:
  const std::string& _internal_output() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output(const std::string& value);
  std::string* _internal_mutable_output();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.ExecuteAssembly)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class InvokeMigrateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.InvokeMigrateReq) */ {
 public:
  inline InvokeMigrateReq() : InvokeMigrateReq(nullptr) {}
  ~InvokeMigrateReq() override;
  explicit PROTOBUF_CONSTEXPR InvokeMigrateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeMigrateReq(const InvokeMigrateReq& from);
  InvokeMigrateReq(InvokeMigrateReq&& from) noexcept
    : InvokeMigrateReq() {
    *this = ::std::move(from);
  }

  inline InvokeMigrateReq& operator=(const InvokeMigrateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeMigrateReq& operator=(InvokeMigrateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeMigrateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeMigrateReq* internal_default_instance() {
    return reinterpret_cast<const InvokeMigrateReq*>(
               &_InvokeMigrateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(InvokeMigrateReq& a, InvokeMigrateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeMigrateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeMigrateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeMigrateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeMigrateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeMigrateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeMigrateReq& from) {
    InvokeMigrateReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeMigrateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.InvokeMigrateReq";
  }
  protected:
  explicit InvokeMigrateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kRequestFieldNumber = 9,
    kPidFieldNumber = 1,
  };
  // bytes Data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // uint32 Pid = 1;
  void clear_pid();
  uint32_t pid() const;
  void set_pid(uint32_t value);
  private:
  uint32_t _internal_pid() const;
  void _internal_set_pid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.InvokeMigrateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::sliverpb::Request* request_;
    uint32_t pid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Migrate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Migrate) */ {
 public:
  inline Migrate() : Migrate(nullptr) {}
  ~Migrate() override;
  explicit PROTOBUF_CONSTEXPR Migrate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Migrate(const Migrate& from);
  Migrate(Migrate&& from) noexcept
    : Migrate() {
    *this = ::std::move(from);
  }

  inline Migrate& operator=(const Migrate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Migrate& operator=(Migrate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Migrate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Migrate* internal_default_instance() {
    return reinterpret_cast<const Migrate*>(
               &_Migrate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(Migrate& a, Migrate& b) {
    a.Swap(&b);
  }
  inline void Swap(Migrate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Migrate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Migrate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Migrate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Migrate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Migrate& from) {
    Migrate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Migrate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Migrate";
  }
  protected:
  explicit Migrate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 9,
    kSuccessFieldNumber = 1,
  };
  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // bool Success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.Migrate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class ExecuteReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.ExecuteReq) */ {
 public:
  inline ExecuteReq() : ExecuteReq(nullptr) {}
  ~ExecuteReq() override;
  explicit PROTOBUF_CONSTEXPR ExecuteReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteReq(const ExecuteReq& from);
  ExecuteReq(ExecuteReq&& from) noexcept
    : ExecuteReq() {
    *this = ::std::move(from);
  }

  inline ExecuteReq& operator=(const ExecuteReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteReq& operator=(ExecuteReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteReq* internal_default_instance() {
    return reinterpret_cast<const ExecuteReq*>(
               &_ExecuteReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(ExecuteReq& a, ExecuteReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteReq& from) {
    ExecuteReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.ExecuteReq";
  }
  protected:
  explicit ExecuteReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 2,
    kPathFieldNumber = 1,
    kStdoutPbFieldNumber = 4,
    kStderrPbFieldNumber = 5,
    kRequestFieldNumber = 9,
    kOutputFieldNumber = 3,
    kPPidFieldNumber = 10,
  };
  // repeated string Args = 2;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string stdout_pb = 4;
  void clear_stdout_pb();
  const std::string& stdout_pb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stdout_pb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stdout_pb();
  PROTOBUF_NODISCARD std::string* release_stdout_pb();
  void set_allocated_stdout_pb(std::string* stdout_pb);
  private:
  const std::string& _internal_stdout_pb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stdout_pb(const std::string& value);
  std::string* _internal_mutable_stdout_pb();
  public:

  // string stderr_pb = 5;
  void clear_stderr_pb();
  const std::string& stderr_pb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stderr_pb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stderr_pb();
  PROTOBUF_NODISCARD std::string* release_stderr_pb();
  void set_allocated_stderr_pb(std::string* stderr_pb);
  private:
  const std::string& _internal_stderr_pb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stderr_pb(const std::string& value);
  std::string* _internal_mutable_stderr_pb();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // bool Output = 3;
  void clear_output();
  bool output() const;
  void set_output(bool value);
  private:
  bool _internal_output() const;
  void _internal_set_output(bool value);
  public:

  // uint32 PPid = 10;
  void clear_ppid();
  uint32_t ppid() const;
  void set_ppid(uint32_t value);
  private:
  uint32_t _internal_ppid() const;
  void _internal_set_ppid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.ExecuteReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stdout_pb_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stderr_pb_;
    ::sliverpb::Request* request_;
    bool output_;
    uint32_t ppid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class ExecuteWindowsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.ExecuteWindowsReq) */ {
 public:
  inline ExecuteWindowsReq() : ExecuteWindowsReq(nullptr) {}
  ~ExecuteWindowsReq() override;
  explicit PROTOBUF_CONSTEXPR ExecuteWindowsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteWindowsReq(const ExecuteWindowsReq& from);
  ExecuteWindowsReq(ExecuteWindowsReq&& from) noexcept
    : ExecuteWindowsReq() {
    *this = ::std::move(from);
  }

  inline ExecuteWindowsReq& operator=(const ExecuteWindowsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteWindowsReq& operator=(ExecuteWindowsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteWindowsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteWindowsReq* internal_default_instance() {
    return reinterpret_cast<const ExecuteWindowsReq*>(
               &_ExecuteWindowsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(ExecuteWindowsReq& a, ExecuteWindowsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteWindowsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteWindowsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteWindowsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteWindowsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteWindowsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteWindowsReq& from) {
    ExecuteWindowsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteWindowsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.ExecuteWindowsReq";
  }
  protected:
  explicit ExecuteWindowsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 2,
    kPathFieldNumber = 1,
    kStdoutPbFieldNumber = 4,
    kStderrPbFieldNumber = 5,
    kRequestFieldNumber = 9,
    kOutputFieldNumber = 3,
    kUseTokenFieldNumber = 6,
    kPPidFieldNumber = 10,
  };
  // repeated string Args = 2;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string stdout_pb = 4;
  void clear_stdout_pb();
  const std::string& stdout_pb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stdout_pb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stdout_pb();
  PROTOBUF_NODISCARD std::string* release_stdout_pb();
  void set_allocated_stdout_pb(std::string* stdout_pb);
  private:
  const std::string& _internal_stdout_pb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stdout_pb(const std::string& value);
  std::string* _internal_mutable_stdout_pb();
  public:

  // string stderr_pb = 5;
  void clear_stderr_pb();
  const std::string& stderr_pb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stderr_pb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stderr_pb();
  PROTOBUF_NODISCARD std::string* release_stderr_pb();
  void set_allocated_stderr_pb(std::string* stderr_pb);
  private:
  const std::string& _internal_stderr_pb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stderr_pb(const std::string& value);
  std::string* _internal_mutable_stderr_pb();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // bool Output = 3;
  void clear_output();
  bool output() const;
  void set_output(bool value);
  private:
  bool _internal_output() const;
  void _internal_set_output(bool value);
  public:

  // bool UseToken = 6;
  void clear_usetoken();
  bool usetoken() const;
  void set_usetoken(bool value);
  private:
  bool _internal_usetoken() const;
  void _internal_set_usetoken(bool value);
  public:

  // uint32 PPid = 10;
  void clear_ppid();
  uint32_t ppid() const;
  void set_ppid(uint32_t value);
  private:
  uint32_t _internal_ppid() const;
  void _internal_set_ppid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.ExecuteWindowsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stdout_pb_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stderr_pb_;
    ::sliverpb::Request* request_;
    bool output_;
    bool usetoken_;
    uint32_t ppid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Execute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Execute) */ {
 public:
  inline Execute() : Execute(nullptr) {}
  ~Execute() override;
  explicit PROTOBUF_CONSTEXPR Execute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Execute(const Execute& from);
  Execute(Execute&& from) noexcept
    : Execute() {
    *this = ::std::move(from);
  }

  inline Execute& operator=(const Execute& from) {
    CopyFrom(from);
    return *this;
  }
  inline Execute& operator=(Execute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Execute& default_instance() {
    return *internal_default_instance();
  }
  static inline const Execute* internal_default_instance() {
    return reinterpret_cast<const Execute*>(
               &_Execute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(Execute& a, Execute& b) {
    a.Swap(&b);
  }
  inline void Swap(Execute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Execute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Execute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Execute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Execute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Execute& from) {
    Execute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Execute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Execute";
  }
  protected:
  explicit Execute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStdoutPbFieldNumber = 2,
    kStderrPbFieldNumber = 3,
    kResponseFieldNumber = 9,
    kStatusFieldNumber = 1,
    kPidFieldNumber = 4,
  };
  // bytes stdout_pb = 2;
  void clear_stdout_pb();
  const std::string& stdout_pb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stdout_pb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stdout_pb();
  PROTOBUF_NODISCARD std::string* release_stdout_pb();
  void set_allocated_stdout_pb(std::string* stdout_pb);
  private:
  const std::string& _internal_stdout_pb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stdout_pb(const std::string& value);
  std::string* _internal_mutable_stdout_pb();
  public:

  // bytes stderr_pb = 3;
  void clear_stderr_pb();
  const std::string& stderr_pb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stderr_pb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stderr_pb();
  PROTOBUF_NODISCARD std::string* release_stderr_pb();
  void set_allocated_stderr_pb(std::string* stderr_pb);
  private:
  const std::string& _internal_stderr_pb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stderr_pb(const std::string& value);
  std::string* _internal_mutable_stderr_pb();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // uint32 Status = 1;
  void clear_status();
  uint32_t status() const;
  void set_status(uint32_t value);
  private:
  uint32_t _internal_status() const;
  void _internal_set_status(uint32_t value);
  public:

  // uint32 Pid = 4;
  void clear_pid();
  uint32_t pid() const;
  void set_pid(uint32_t value);
  private:
  uint32_t _internal_pid() const;
  void _internal_set_pid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.Execute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stdout_pb_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stderr_pb_;
    ::sliverpb::Response* response_;
    uint32_t status_;
    uint32_t pid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class SideloadReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.SideloadReq) */ {
 public:
  inline SideloadReq() : SideloadReq(nullptr) {}
  ~SideloadReq() override;
  explicit PROTOBUF_CONSTEXPR SideloadReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SideloadReq(const SideloadReq& from);
  SideloadReq(SideloadReq&& from) noexcept
    : SideloadReq() {
    *this = ::std::move(from);
  }

  inline SideloadReq& operator=(const SideloadReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SideloadReq& operator=(SideloadReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SideloadReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SideloadReq* internal_default_instance() {
    return reinterpret_cast<const SideloadReq*>(
               &_SideloadReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(SideloadReq& a, SideloadReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SideloadReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SideloadReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SideloadReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SideloadReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SideloadReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SideloadReq& from) {
    SideloadReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SideloadReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.SideloadReq";
  }
  protected:
  explicit SideloadReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessArgsFieldNumber = 11,
    kDataFieldNumber = 1,
    kProcessNameFieldNumber = 2,
    kArgsFieldNumber = 3,
    kEntryPointFieldNumber = 4,
    kRequestFieldNumber = 9,
    kKillFieldNumber = 5,
    kIsDLLFieldNumber = 6,
    kIsUnicodeFieldNumber = 7,
    kPPidFieldNumber = 10,
  };
  // repeated string ProcessArgs = 11;
  int processargs_size() const;
  private:
  int _internal_processargs_size() const;
  public:
  void clear_processargs();
  const std::string& processargs(int index) const;
  std::string* mutable_processargs(int index);
  void set_processargs(int index, const std::string& value);
  void set_processargs(int index, std::string&& value);
  void set_processargs(int index, const char* value);
  void set_processargs(int index, const char* value, size_t size);
  std::string* add_processargs();
  void add_processargs(const std::string& value);
  void add_processargs(std::string&& value);
  void add_processargs(const char* value);
  void add_processargs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& processargs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_processargs();
  private:
  const std::string& _internal_processargs(int index) const;
  std::string* _internal_add_processargs();
  public:

  // bytes Data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string ProcessName = 2;
  void clear_processname();
  const std::string& processname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_processname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_processname();
  PROTOBUF_NODISCARD std::string* release_processname();
  void set_allocated_processname(std::string* processname);
  private:
  const std::string& _internal_processname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processname(const std::string& value);
  std::string* _internal_mutable_processname();
  public:

  // string Args = 3;
  void clear_args();
  const std::string& args() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_args(ArgT0&& arg0, ArgT... args);
  std::string* mutable_args();
  PROTOBUF_NODISCARD std::string* release_args();
  void set_allocated_args(std::string* args);
  private:
  const std::string& _internal_args() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_args(const std::string& value);
  std::string* _internal_mutable_args();
  public:

  // string EntryPoint = 4;
  void clear_entrypoint();
  const std::string& entrypoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entrypoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entrypoint();
  PROTOBUF_NODISCARD std::string* release_entrypoint();
  void set_allocated_entrypoint(std::string* entrypoint);
  private:
  const std::string& _internal_entrypoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entrypoint(const std::string& value);
  std::string* _internal_mutable_entrypoint();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // bool Kill = 5;
  void clear_kill();
  bool kill() const;
  void set_kill(bool value);
  private:
  bool _internal_kill() const;
  void _internal_set_kill(bool value);
  public:

  // bool isDLL = 6;
  void clear_isdll();
  bool isdll() const;
  void set_isdll(bool value);
  private:
  bool _internal_isdll() const;
  void _internal_set_isdll(bool value);
  public:

  // bool isUnicode = 7;
  void clear_isunicode();
  bool isunicode() const;
  void set_isunicode(bool value);
  private:
  bool _internal_isunicode() const;
  void _internal_set_isunicode(bool value);
  public:

  // uint32 PPid = 10;
  void clear_ppid();
  uint32_t ppid() const;
  void set_ppid(uint32_t value);
  private:
  uint32_t _internal_ppid() const;
  void _internal_set_ppid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.SideloadReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> processargs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr processname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entrypoint_;
    ::sliverpb::Request* request_;
    bool kill_;
    bool isdll_;
    bool isunicode_;
    uint32_t ppid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Sideload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Sideload) */ {
 public:
  inline Sideload() : Sideload(nullptr) {}
  ~Sideload() override;
  explicit PROTOBUF_CONSTEXPR Sideload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sideload(const Sideload& from);
  Sideload(Sideload&& from) noexcept
    : Sideload() {
    *this = ::std::move(from);
  }

  inline Sideload& operator=(const Sideload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sideload& operator=(Sideload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sideload& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sideload* internal_default_instance() {
    return reinterpret_cast<const Sideload*>(
               &_Sideload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(Sideload& a, Sideload& b) {
    a.Swap(&b);
  }
  inline void Swap(Sideload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sideload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sideload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sideload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sideload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Sideload& from) {
    Sideload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sideload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Sideload";
  }
  protected:
  explicit Sideload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // string Result = 1;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.Sideload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class InvokeSpawnDllReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.InvokeSpawnDllReq) */ {
 public:
  inline InvokeSpawnDllReq() : InvokeSpawnDllReq(nullptr) {}
  ~InvokeSpawnDllReq() override;
  explicit PROTOBUF_CONSTEXPR InvokeSpawnDllReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeSpawnDllReq(const InvokeSpawnDllReq& from);
  InvokeSpawnDllReq(InvokeSpawnDllReq&& from) noexcept
    : InvokeSpawnDllReq() {
    *this = ::std::move(from);
  }

  inline InvokeSpawnDllReq& operator=(const InvokeSpawnDllReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeSpawnDllReq& operator=(InvokeSpawnDllReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeSpawnDllReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeSpawnDllReq* internal_default_instance() {
    return reinterpret_cast<const InvokeSpawnDllReq*>(
               &_InvokeSpawnDllReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(InvokeSpawnDllReq& a, InvokeSpawnDllReq& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeSpawnDllReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeSpawnDllReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeSpawnDllReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeSpawnDllReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeSpawnDllReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeSpawnDllReq& from) {
    InvokeSpawnDllReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeSpawnDllReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.InvokeSpawnDllReq";
  }
  protected:
  explicit InvokeSpawnDllReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessArgsFieldNumber = 11,
    kDataFieldNumber = 1,
    kProcessNameFieldNumber = 2,
    kArgsFieldNumber = 3,
    kEntryPointFieldNumber = 4,
    kRequestFieldNumber = 9,
    kKillFieldNumber = 5,
    kPPidFieldNumber = 10,
  };
  // repeated string ProcessArgs = 11;
  int processargs_size() const;
  private:
  int _internal_processargs_size() const;
  public:
  void clear_processargs();
  const std::string& processargs(int index) const;
  std::string* mutable_processargs(int index);
  void set_processargs(int index, const std::string& value);
  void set_processargs(int index, std::string&& value);
  void set_processargs(int index, const char* value);
  void set_processargs(int index, const char* value, size_t size);
  std::string* add_processargs();
  void add_processargs(const std::string& value);
  void add_processargs(std::string&& value);
  void add_processargs(const char* value);
  void add_processargs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& processargs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_processargs();
  private:
  const std::string& _internal_processargs(int index) const;
  std::string* _internal_add_processargs();
  public:

  // bytes Data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string ProcessName = 2;
  void clear_processname();
  const std::string& processname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_processname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_processname();
  PROTOBUF_NODISCARD std::string* release_processname();
  void set_allocated_processname(std::string* processname);
  private:
  const std::string& _internal_processname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processname(const std::string& value);
  std::string* _internal_mutable_processname();
  public:

  // string Args = 3;
  void clear_args();
  const std::string& args() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_args(ArgT0&& arg0, ArgT... args);
  std::string* mutable_args();
  PROTOBUF_NODISCARD std::string* release_args();
  void set_allocated_args(std::string* args);
  private:
  const std::string& _internal_args() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_args(const std::string& value);
  std::string* _internal_mutable_args();
  public:

  // string EntryPoint = 4;
  void clear_entrypoint();
  const std::string& entrypoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entrypoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entrypoint();
  PROTOBUF_NODISCARD std::string* release_entrypoint();
  void set_allocated_entrypoint(std::string* entrypoint);
  private:
  const std::string& _internal_entrypoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entrypoint(const std::string& value);
  std::string* _internal_mutable_entrypoint();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // bool Kill = 5;
  void clear_kill();
  bool kill() const;
  void set_kill(bool value);
  private:
  bool _internal_kill() const;
  void _internal_set_kill(bool value);
  public:

  // uint32 PPid = 10;
  void clear_ppid();
  uint32_t ppid() const;
  void set_ppid(uint32_t value);
  private:
  uint32_t _internal_ppid() const;
  void _internal_set_ppid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.InvokeSpawnDllReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> processargs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr processname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entrypoint_;
    ::sliverpb::Request* request_;
    bool kill_;
    uint32_t ppid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class SpawnDllReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.SpawnDllReq) */ {
 public:
  inline SpawnDllReq() : SpawnDllReq(nullptr) {}
  ~SpawnDllReq() override;
  explicit PROTOBUF_CONSTEXPR SpawnDllReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpawnDllReq(const SpawnDllReq& from);
  SpawnDllReq(SpawnDllReq&& from) noexcept
    : SpawnDllReq() {
    *this = ::std::move(from);
  }

  inline SpawnDllReq& operator=(const SpawnDllReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpawnDllReq& operator=(SpawnDllReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpawnDllReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpawnDllReq* internal_default_instance() {
    return reinterpret_cast<const SpawnDllReq*>(
               &_SpawnDllReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(SpawnDllReq& a, SpawnDllReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SpawnDllReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpawnDllReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpawnDllReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpawnDllReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpawnDllReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpawnDllReq& from) {
    SpawnDllReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpawnDllReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.SpawnDllReq";
  }
  protected:
  explicit SpawnDllReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessArgsFieldNumber = 11,
    kDataFieldNumber = 1,
    kProcessNameFieldNumber = 2,
    kArgsFieldNumber = 4,
    kRequestFieldNumber = 9,
    kOffsetFieldNumber = 3,
    kKillFieldNumber = 5,
    kPPidFieldNumber = 10,
  };
  // repeated string ProcessArgs = 11;
  int processargs_size() const;
  private:
  int _internal_processargs_size() const;
  public:
  void clear_processargs();
  const std::string& processargs(int index) const;
  std::string* mutable_processargs(int index);
  void set_processargs(int index, const std::string& value);
  void set_processargs(int index, std::string&& value);
  void set_processargs(int index, const char* value);
  void set_processargs(int index, const char* value, size_t size);
  std::string* add_processargs();
  void add_processargs(const std::string& value);
  void add_processargs(std::string&& value);
  void add_processargs(const char* value);
  void add_processargs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& processargs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_processargs();
  private:
  const std::string& _internal_processargs(int index) const;
  std::string* _internal_add_processargs();
  public:

  // bytes Data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string ProcessName = 2;
  void clear_processname();
  const std::string& processname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_processname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_processname();
  PROTOBUF_NODISCARD std::string* release_processname();
  void set_allocated_processname(std::string* processname);
  private:
  const std::string& _internal_processname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processname(const std::string& value);
  std::string* _internal_mutable_processname();
  public:

  // string Args = 4;
  void clear_args();
  const std::string& args() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_args(ArgT0&& arg0, ArgT... args);
  std::string* mutable_args();
  PROTOBUF_NODISCARD std::string* release_args();
  void set_allocated_args(std::string* args);
  private:
  const std::string& _internal_args() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_args(const std::string& value);
  std::string* _internal_mutable_args();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // uint32 Offset = 3;
  void clear_offset();
  uint32_t offset() const;
  void set_offset(uint32_t value);
  private:
  uint32_t _internal_offset() const;
  void _internal_set_offset(uint32_t value);
  public:

  // bool Kill = 5;
  void clear_kill();
  bool kill() const;
  void set_kill(bool value);
  private:
  bool _internal_kill() const;
  void _internal_set_kill(bool value);
  public:

  // uint32 PPid = 10;
  void clear_ppid();
  uint32_t ppid() const;
  void set_ppid(uint32_t value);
  private:
  uint32_t _internal_ppid() const;
  void _internal_set_ppid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.SpawnDllReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> processargs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr processname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr args_;
    ::sliverpb::Request* request_;
    uint32_t offset_;
    bool kill_;
    uint32_t ppid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class SpawnDll final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.SpawnDll) */ {
 public:
  inline SpawnDll() : SpawnDll(nullptr) {}
  ~SpawnDll() override;
  explicit PROTOBUF_CONSTEXPR SpawnDll(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpawnDll(const SpawnDll& from);
  SpawnDll(SpawnDll&& from) noexcept
    : SpawnDll() {
    *this = ::std::move(from);
  }

  inline SpawnDll& operator=(const SpawnDll& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpawnDll& operator=(SpawnDll&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpawnDll& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpawnDll* internal_default_instance() {
    return reinterpret_cast<const SpawnDll*>(
               &_SpawnDll_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(SpawnDll& a, SpawnDll& b) {
    a.Swap(&b);
  }
  inline void Swap(SpawnDll* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpawnDll* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpawnDll* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpawnDll>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpawnDll& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpawnDll& from) {
    SpawnDll::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpawnDll* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.SpawnDll";
  }
  protected:
  explicit SpawnDll(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // string Result = 1;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.SpawnDll)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class NetstatReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.NetstatReq) */ {
 public:
  inline NetstatReq() : NetstatReq(nullptr) {}
  ~NetstatReq() override;
  explicit PROTOBUF_CONSTEXPR NetstatReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetstatReq(const NetstatReq& from);
  NetstatReq(NetstatReq&& from) noexcept
    : NetstatReq() {
    *this = ::std::move(from);
  }

  inline NetstatReq& operator=(const NetstatReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetstatReq& operator=(NetstatReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetstatReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetstatReq* internal_default_instance() {
    return reinterpret_cast<const NetstatReq*>(
               &_NetstatReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(NetstatReq& a, NetstatReq& b) {
    a.Swap(&b);
  }
  inline void Swap(NetstatReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetstatReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetstatReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetstatReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetstatReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetstatReq& from) {
    NetstatReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetstatReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.NetstatReq";
  }
  protected:
  explicit NetstatReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
    kTCPFieldNumber = 1,
    kUDPFieldNumber = 2,
    kIP4FieldNumber = 3,
    kIP6FieldNumber = 5,
    kListeningFieldNumber = 6,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // bool TCP = 1;
  void clear_tcp();
  bool tcp() const;
  void set_tcp(bool value);
  private:
  bool _internal_tcp() const;
  void _internal_set_tcp(bool value);
  public:

  // bool UDP = 2;
  void clear_udp();
  bool udp() const;
  void set_udp(bool value);
  private:
  bool _internal_udp() const;
  void _internal_set_udp(bool value);
  public:

  // bool IP4 = 3;
  void clear_ip4();
  bool ip4() const;
  void set_ip4(bool value);
  private:
  bool _internal_ip4() const;
  void _internal_set_ip4(bool value);
  public:

  // bool IP6 = 5;
  void clear_ip6();
  bool ip6() const;
  void set_ip6(bool value);
  private:
  bool _internal_ip6() const;
  void _internal_set_ip6(bool value);
  public:

  // bool Listening = 6;
  void clear_listening();
  bool listening() const;
  void set_listening(bool value);
  private:
  bool _internal_listening() const;
  void _internal_set_listening(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.NetstatReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    bool tcp_;
    bool udp_;
    bool ip4_;
    bool ip6_;
    bool listening_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class SockTabEntry_SockAddr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.SockTabEntry.SockAddr) */ {
 public:
  inline SockTabEntry_SockAddr() : SockTabEntry_SockAddr(nullptr) {}
  ~SockTabEntry_SockAddr() override;
  explicit PROTOBUF_CONSTEXPR SockTabEntry_SockAddr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SockTabEntry_SockAddr(const SockTabEntry_SockAddr& from);
  SockTabEntry_SockAddr(SockTabEntry_SockAddr&& from) noexcept
    : SockTabEntry_SockAddr() {
    *this = ::std::move(from);
  }

  inline SockTabEntry_SockAddr& operator=(const SockTabEntry_SockAddr& from) {
    CopyFrom(from);
    return *this;
  }
  inline SockTabEntry_SockAddr& operator=(SockTabEntry_SockAddr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SockTabEntry_SockAddr& default_instance() {
    return *internal_default_instance();
  }
  static inline const SockTabEntry_SockAddr* internal_default_instance() {
    return reinterpret_cast<const SockTabEntry_SockAddr*>(
               &_SockTabEntry_SockAddr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(SockTabEntry_SockAddr& a, SockTabEntry_SockAddr& b) {
    a.Swap(&b);
  }
  inline void Swap(SockTabEntry_SockAddr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SockTabEntry_SockAddr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SockTabEntry_SockAddr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SockTabEntry_SockAddr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SockTabEntry_SockAddr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SockTabEntry_SockAddr& from) {
    SockTabEntry_SockAddr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SockTabEntry_SockAddr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.SockTabEntry.SockAddr";
  }
  protected:
  explicit SockTabEntry_SockAddr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // string Ip = 1;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // uint32 Port = 2;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.SockTabEntry.SockAddr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    uint32_t port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class SockTabEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.SockTabEntry) */ {
 public:
  inline SockTabEntry() : SockTabEntry(nullptr) {}
  ~SockTabEntry() override;
  explicit PROTOBUF_CONSTEXPR SockTabEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SockTabEntry(const SockTabEntry& from);
  SockTabEntry(SockTabEntry&& from) noexcept
    : SockTabEntry() {
    *this = ::std::move(from);
  }

  inline SockTabEntry& operator=(const SockTabEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline SockTabEntry& operator=(SockTabEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SockTabEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const SockTabEntry* internal_default_instance() {
    return reinterpret_cast<const SockTabEntry*>(
               &_SockTabEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(SockTabEntry& a, SockTabEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(SockTabEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SockTabEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SockTabEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SockTabEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SockTabEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SockTabEntry& from) {
    SockTabEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SockTabEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.SockTabEntry";
  }
  protected:
  explicit SockTabEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SockTabEntry_SockAddr SockAddr;

  // accessors -------------------------------------------------------

  enum : int {
    kSkStateFieldNumber = 3,
    kProtocolFieldNumber = 6,
    kLocalAddrFieldNumber = 1,
    kRemoteAddrFieldNumber = 2,
    kProcessFieldNumber = 5,
    kUIDFieldNumber = 4,
  };
  // string SkState = 3;
  void clear_skstate();
  const std::string& skstate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_skstate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_skstate();
  PROTOBUF_NODISCARD std::string* release_skstate();
  void set_allocated_skstate(std::string* skstate);
  private:
  const std::string& _internal_skstate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_skstate(const std::string& value);
  std::string* _internal_mutable_skstate();
  public:

  // string Protocol = 6;
  void clear_protocol();
  const std::string& protocol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocol();
  PROTOBUF_NODISCARD std::string* release_protocol();
  void set_allocated_protocol(std::string* protocol);
  private:
  const std::string& _internal_protocol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol(const std::string& value);
  std::string* _internal_mutable_protocol();
  public:

  // .sliverpb.SockTabEntry.SockAddr LocalAddr = 1;
  bool has_localaddr() const;
  private:
  bool _internal_has_localaddr() const;
  public:
  void clear_localaddr();
  const ::sliverpb::SockTabEntry_SockAddr& localaddr() const;
  PROTOBUF_NODISCARD ::sliverpb::SockTabEntry_SockAddr* release_localaddr();
  ::sliverpb::SockTabEntry_SockAddr* mutable_localaddr();
  void set_allocated_localaddr(::sliverpb::SockTabEntry_SockAddr* localaddr);
  private:
  const ::sliverpb::SockTabEntry_SockAddr& _internal_localaddr() const;
  ::sliverpb::SockTabEntry_SockAddr* _internal_mutable_localaddr();
  public:
  void unsafe_arena_set_allocated_localaddr(
      ::sliverpb::SockTabEntry_SockAddr* localaddr);
  ::sliverpb::SockTabEntry_SockAddr* unsafe_arena_release_localaddr();

  // .sliverpb.SockTabEntry.SockAddr RemoteAddr = 2;
  bool has_remoteaddr() const;
  private:
  bool _internal_has_remoteaddr() const;
  public:
  void clear_remoteaddr();
  const ::sliverpb::SockTabEntry_SockAddr& remoteaddr() const;
  PROTOBUF_NODISCARD ::sliverpb::SockTabEntry_SockAddr* release_remoteaddr();
  ::sliverpb::SockTabEntry_SockAddr* mutable_remoteaddr();
  void set_allocated_remoteaddr(::sliverpb::SockTabEntry_SockAddr* remoteaddr);
  private:
  const ::sliverpb::SockTabEntry_SockAddr& _internal_remoteaddr() const;
  ::sliverpb::SockTabEntry_SockAddr* _internal_mutable_remoteaddr();
  public:
  void unsafe_arena_set_allocated_remoteaddr(
      ::sliverpb::SockTabEntry_SockAddr* remoteaddr);
  ::sliverpb::SockTabEntry_SockAddr* unsafe_arena_release_remoteaddr();

  // .sliverpb.Process Process = 5;
  bool has_process() const;
  private:
  bool _internal_has_process() const;
  public:
  void clear_process();
  const ::sliverpb::Process& process() const;
  PROTOBUF_NODISCARD ::sliverpb::Process* release_process();
  ::sliverpb::Process* mutable_process();
  void set_allocated_process(::sliverpb::Process* process);
  private:
  const ::sliverpb::Process& _internal_process() const;
  ::sliverpb::Process* _internal_mutable_process();
  public:
  void unsafe_arena_set_allocated_process(
      ::sliverpb::Process* process);
  ::sliverpb::Process* unsafe_arena_release_process();

  // uint32 UID = 4;
  void clear_uid();
  uint32_t uid() const;
  void set_uid(uint32_t value);
  private:
  uint32_t _internal_uid() const;
  void _internal_set_uid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.SockTabEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr skstate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocol_;
    ::sliverpb::SockTabEntry_SockAddr* localaddr_;
    ::sliverpb::SockTabEntry_SockAddr* remoteaddr_;
    ::sliverpb::Process* process_;
    uint32_t uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Netstat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Netstat) */ {
 public:
  inline Netstat() : Netstat(nullptr) {}
  ~Netstat() override;
  explicit PROTOBUF_CONSTEXPR Netstat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Netstat(const Netstat& from);
  Netstat(Netstat&& from) noexcept
    : Netstat() {
    *this = ::std::move(from);
  }

  inline Netstat& operator=(const Netstat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Netstat& operator=(Netstat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Netstat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Netstat* internal_default_instance() {
    return reinterpret_cast<const Netstat*>(
               &_Netstat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(Netstat& a, Netstat& b) {
    a.Swap(&b);
  }
  inline void Swap(Netstat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Netstat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Netstat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Netstat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Netstat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Netstat& from) {
    Netstat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Netstat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Netstat";
  }
  protected:
  explicit Netstat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // repeated .sliverpb.SockTabEntry Entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::sliverpb::SockTabEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::SockTabEntry >*
      mutable_entries();
  private:
  const ::sliverpb::SockTabEntry& _internal_entries(int index) const;
  ::sliverpb::SockTabEntry* _internal_add_entries();
  public:
  const ::sliverpb::SockTabEntry& entries(int index) const;
  ::sliverpb::SockTabEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::SockTabEntry >&
      entries() const;

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.Netstat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::SockTabEntry > entries_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class EnvReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.EnvReq) */ {
 public:
  inline EnvReq() : EnvReq(nullptr) {}
  ~EnvReq() override;
  explicit PROTOBUF_CONSTEXPR EnvReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnvReq(const EnvReq& from);
  EnvReq(EnvReq&& from) noexcept
    : EnvReq() {
    *this = ::std::move(from);
  }

  inline EnvReq& operator=(const EnvReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnvReq& operator=(EnvReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnvReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnvReq* internal_default_instance() {
    return reinterpret_cast<const EnvReq*>(
               &_EnvReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(EnvReq& a, EnvReq& b) {
    a.Swap(&b);
  }
  inline void Swap(EnvReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnvReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnvReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnvReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnvReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnvReq& from) {
    EnvReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnvReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.EnvReq";
  }
  protected:
  explicit EnvReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kRequestFieldNumber = 9,
  };
  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.EnvReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class EnvInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.EnvInfo) */ {
 public:
  inline EnvInfo() : EnvInfo(nullptr) {}
  ~EnvInfo() override;
  explicit PROTOBUF_CONSTEXPR EnvInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnvInfo(const EnvInfo& from);
  EnvInfo(EnvInfo&& from) noexcept
    : EnvInfo() {
    *this = ::std::move(from);
  }

  inline EnvInfo& operator=(const EnvInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnvInfo& operator=(EnvInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnvInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnvInfo* internal_default_instance() {
    return reinterpret_cast<const EnvInfo*>(
               &_EnvInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(EnvInfo& a, EnvInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(EnvInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnvInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnvInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnvInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnvInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnvInfo& from) {
    EnvInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnvInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.EnvInfo";
  }
  protected:
  explicit EnvInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVariablesFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // repeated .sliverpb.EnvVar Variables = 1;
  int variables_size() const;
  private:
  int _internal_variables_size() const;
  public:
  void clear_variables();
  ::sliverpb::EnvVar* mutable_variables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::EnvVar >*
      mutable_variables();
  private:
  const ::sliverpb::EnvVar& _internal_variables(int index) const;
  ::sliverpb::EnvVar* _internal_add_variables();
  public:
  const ::sliverpb::EnvVar& variables(int index) const;
  ::sliverpb::EnvVar* add_variables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::EnvVar >&
      variables() const;

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.EnvInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::EnvVar > variables_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class SetEnvReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.SetEnvReq) */ {
 public:
  inline SetEnvReq() : SetEnvReq(nullptr) {}
  ~SetEnvReq() override;
  explicit PROTOBUF_CONSTEXPR SetEnvReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetEnvReq(const SetEnvReq& from);
  SetEnvReq(SetEnvReq&& from) noexcept
    : SetEnvReq() {
    *this = ::std::move(from);
  }

  inline SetEnvReq& operator=(const SetEnvReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetEnvReq& operator=(SetEnvReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetEnvReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetEnvReq* internal_default_instance() {
    return reinterpret_cast<const SetEnvReq*>(
               &_SetEnvReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(SetEnvReq& a, SetEnvReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetEnvReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetEnvReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetEnvReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetEnvReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetEnvReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetEnvReq& from) {
    SetEnvReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetEnvReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.SetEnvReq";
  }
  protected:
  explicit SetEnvReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVariableFieldNumber = 1,
    kRequestFieldNumber = 9,
  };
  // .sliverpb.EnvVar Variable = 1;
  bool has_variable() const;
  private:
  bool _internal_has_variable() const;
  public:
  void clear_variable();
  const ::sliverpb::EnvVar& variable() const;
  PROTOBUF_NODISCARD ::sliverpb::EnvVar* release_variable();
  ::sliverpb::EnvVar* mutable_variable();
  void set_allocated_variable(::sliverpb::EnvVar* variable);
  private:
  const ::sliverpb::EnvVar& _internal_variable() const;
  ::sliverpb::EnvVar* _internal_mutable_variable();
  public:
  void unsafe_arena_set_allocated_variable(
      ::sliverpb::EnvVar* variable);
  ::sliverpb::EnvVar* unsafe_arena_release_variable();

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.SetEnvReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::EnvVar* variable_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class SetEnv final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.SetEnv) */ {
 public:
  inline SetEnv() : SetEnv(nullptr) {}
  ~SetEnv() override;
  explicit PROTOBUF_CONSTEXPR SetEnv(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetEnv(const SetEnv& from);
  SetEnv(SetEnv&& from) noexcept
    : SetEnv() {
    *this = ::std::move(from);
  }

  inline SetEnv& operator=(const SetEnv& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetEnv& operator=(SetEnv&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetEnv& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetEnv* internal_default_instance() {
    return reinterpret_cast<const SetEnv*>(
               &_SetEnv_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(SetEnv& a, SetEnv& b) {
    a.Swap(&b);
  }
  inline void Swap(SetEnv* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetEnv* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetEnv* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetEnv>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetEnv& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetEnv& from) {
    SetEnv::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetEnv* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.SetEnv";
  }
  protected:
  explicit SetEnv(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 9,
  };
  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.SetEnv)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class UnsetEnvReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.UnsetEnvReq) */ {
 public:
  inline UnsetEnvReq() : UnsetEnvReq(nullptr) {}
  ~UnsetEnvReq() override;
  explicit PROTOBUF_CONSTEXPR UnsetEnvReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsetEnvReq(const UnsetEnvReq& from);
  UnsetEnvReq(UnsetEnvReq&& from) noexcept
    : UnsetEnvReq() {
    *this = ::std::move(from);
  }

  inline UnsetEnvReq& operator=(const UnsetEnvReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsetEnvReq& operator=(UnsetEnvReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsetEnvReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsetEnvReq* internal_default_instance() {
    return reinterpret_cast<const UnsetEnvReq*>(
               &_UnsetEnvReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(UnsetEnvReq& a, UnsetEnvReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsetEnvReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsetEnvReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsetEnvReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsetEnvReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsetEnvReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnsetEnvReq& from) {
    UnsetEnvReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsetEnvReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.UnsetEnvReq";
  }
  protected:
  explicit UnsetEnvReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kRequestFieldNumber = 9,
  };
  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.UnsetEnvReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class UnsetEnv final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.UnsetEnv) */ {
 public:
  inline UnsetEnv() : UnsetEnv(nullptr) {}
  ~UnsetEnv() override;
  explicit PROTOBUF_CONSTEXPR UnsetEnv(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsetEnv(const UnsetEnv& from);
  UnsetEnv(UnsetEnv&& from) noexcept
    : UnsetEnv() {
    *this = ::std::move(from);
  }

  inline UnsetEnv& operator=(const UnsetEnv& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsetEnv& operator=(UnsetEnv&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsetEnv& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsetEnv* internal_default_instance() {
    return reinterpret_cast<const UnsetEnv*>(
               &_UnsetEnv_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(UnsetEnv& a, UnsetEnv& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsetEnv* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsetEnv* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsetEnv* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsetEnv>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsetEnv& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnsetEnv& from) {
    UnsetEnv::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsetEnv* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.UnsetEnv";
  }
  protected:
  explicit UnsetEnv(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 9,
  };
  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.UnsetEnv)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class DNSSessionInit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.DNSSessionInit) */ {
 public:
  inline DNSSessionInit() : DNSSessionInit(nullptr) {}
  ~DNSSessionInit() override;
  explicit PROTOBUF_CONSTEXPR DNSSessionInit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DNSSessionInit(const DNSSessionInit& from);
  DNSSessionInit(DNSSessionInit&& from) noexcept
    : DNSSessionInit() {
    *this = ::std::move(from);
  }

  inline DNSSessionInit& operator=(const DNSSessionInit& from) {
    CopyFrom(from);
    return *this;
  }
  inline DNSSessionInit& operator=(DNSSessionInit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DNSSessionInit& default_instance() {
    return *internal_default_instance();
  }
  static inline const DNSSessionInit* internal_default_instance() {
    return reinterpret_cast<const DNSSessionInit*>(
               &_DNSSessionInit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(DNSSessionInit& a, DNSSessionInit& b) {
    a.Swap(&b);
  }
  inline void Swap(DNSSessionInit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DNSSessionInit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DNSSessionInit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DNSSessionInit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DNSSessionInit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DNSSessionInit& from) {
    DNSSessionInit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DNSSessionInit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.DNSSessionInit";
  }
  protected:
  explicit DNSSessionInit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // bytes Key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.DNSSessionInit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class DNSPoll final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.DNSPoll) */ {
 public:
  inline DNSPoll() : DNSPoll(nullptr) {}
  ~DNSPoll() override;
  explicit PROTOBUF_CONSTEXPR DNSPoll(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DNSPoll(const DNSPoll& from);
  DNSPoll(DNSPoll&& from) noexcept
    : DNSPoll() {
    *this = ::std::move(from);
  }

  inline DNSPoll& operator=(const DNSPoll& from) {
    CopyFrom(from);
    return *this;
  }
  inline DNSPoll& operator=(DNSPoll&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DNSPoll& default_instance() {
    return *internal_default_instance();
  }
  static inline const DNSPoll* internal_default_instance() {
    return reinterpret_cast<const DNSPoll*>(
               &_DNSPoll_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(DNSPoll& a, DNSPoll& b) {
    a.Swap(&b);
  }
  inline void Swap(DNSPoll* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DNSPoll* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DNSPoll* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DNSPoll>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DNSPoll& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DNSPoll& from) {
    DNSPoll::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DNSPoll* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.DNSPoll";
  }
  protected:
  explicit DNSPoll(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 1,
  };
  // repeated .sliverpb.DNSBlockHeader blocks = 1;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  ::sliverpb::DNSBlockHeader* mutable_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::DNSBlockHeader >*
      mutable_blocks();
  private:
  const ::sliverpb::DNSBlockHeader& _internal_blocks(int index) const;
  ::sliverpb::DNSBlockHeader* _internal_add_blocks();
  public:
  const ::sliverpb::DNSBlockHeader& blocks(int index) const;
  ::sliverpb::DNSBlockHeader* add_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::DNSBlockHeader >&
      blocks() const;

  // @@protoc_insertion_point(class_scope:sliverpb.DNSPoll)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::DNSBlockHeader > blocks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class DNSBlockHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.DNSBlockHeader) */ {
 public:
  inline DNSBlockHeader() : DNSBlockHeader(nullptr) {}
  ~DNSBlockHeader() override;
  explicit PROTOBUF_CONSTEXPR DNSBlockHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DNSBlockHeader(const DNSBlockHeader& from);
  DNSBlockHeader(DNSBlockHeader&& from) noexcept
    : DNSBlockHeader() {
    *this = ::std::move(from);
  }

  inline DNSBlockHeader& operator=(const DNSBlockHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline DNSBlockHeader& operator=(DNSBlockHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DNSBlockHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const DNSBlockHeader* internal_default_instance() {
    return reinterpret_cast<const DNSBlockHeader*>(
               &_DNSBlockHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(DNSBlockHeader& a, DNSBlockHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(DNSBlockHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DNSBlockHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DNSBlockHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DNSBlockHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DNSBlockHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DNSBlockHeader& from) {
    DNSBlockHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DNSBlockHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.DNSBlockHeader";
  }
  protected:
  explicit DNSBlockHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // string ID = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // uint32 Size = 2;
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.DNSBlockHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    uint32_t size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class HTTPSessionInit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.HTTPSessionInit) */ {
 public:
  inline HTTPSessionInit() : HTTPSessionInit(nullptr) {}
  ~HTTPSessionInit() override;
  explicit PROTOBUF_CONSTEXPR HTTPSessionInit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HTTPSessionInit(const HTTPSessionInit& from);
  HTTPSessionInit(HTTPSessionInit&& from) noexcept
    : HTTPSessionInit() {
    *this = ::std::move(from);
  }

  inline HTTPSessionInit& operator=(const HTTPSessionInit& from) {
    CopyFrom(from);
    return *this;
  }
  inline HTTPSessionInit& operator=(HTTPSessionInit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HTTPSessionInit& default_instance() {
    return *internal_default_instance();
  }
  static inline const HTTPSessionInit* internal_default_instance() {
    return reinterpret_cast<const HTTPSessionInit*>(
               &_HTTPSessionInit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(HTTPSessionInit& a, HTTPSessionInit& b) {
    a.Swap(&b);
  }
  inline void Swap(HTTPSessionInit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HTTPSessionInit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HTTPSessionInit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HTTPSessionInit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HTTPSessionInit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HTTPSessionInit& from) {
    HTTPSessionInit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HTTPSessionInit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.HTTPSessionInit";
  }
  protected:
  explicit HTTPSessionInit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // bytes Key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.HTTPSessionInit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class ScreenshotReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.ScreenshotReq) */ {
 public:
  inline ScreenshotReq() : ScreenshotReq(nullptr) {}
  ~ScreenshotReq() override;
  explicit PROTOBUF_CONSTEXPR ScreenshotReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScreenshotReq(const ScreenshotReq& from);
  ScreenshotReq(ScreenshotReq&& from) noexcept
    : ScreenshotReq() {
    *this = ::std::move(from);
  }

  inline ScreenshotReq& operator=(const ScreenshotReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScreenshotReq& operator=(ScreenshotReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScreenshotReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScreenshotReq* internal_default_instance() {
    return reinterpret_cast<const ScreenshotReq*>(
               &_ScreenshotReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(ScreenshotReq& a, ScreenshotReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ScreenshotReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScreenshotReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScreenshotReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScreenshotReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScreenshotReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ScreenshotReq& from) {
    ScreenshotReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScreenshotReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.ScreenshotReq";
  }
  protected:
  explicit ScreenshotReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.ScreenshotReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Screenshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Screenshot) */ {
 public:
  inline Screenshot() : Screenshot(nullptr) {}
  ~Screenshot() override;
  explicit PROTOBUF_CONSTEXPR Screenshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Screenshot(const Screenshot& from);
  Screenshot(Screenshot&& from) noexcept
    : Screenshot() {
    *this = ::std::move(from);
  }

  inline Screenshot& operator=(const Screenshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Screenshot& operator=(Screenshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Screenshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Screenshot* internal_default_instance() {
    return reinterpret_cast<const Screenshot*>(
               &_Screenshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(Screenshot& a, Screenshot& b) {
    a.Swap(&b);
  }
  inline void Swap(Screenshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Screenshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Screenshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Screenshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Screenshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Screenshot& from) {
    Screenshot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Screenshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Screenshot";
  }
  protected:
  explicit Screenshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // bytes Data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.Screenshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class StartServiceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.StartServiceReq) */ {
 public:
  inline StartServiceReq() : StartServiceReq(nullptr) {}
  ~StartServiceReq() override;
  explicit PROTOBUF_CONSTEXPR StartServiceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartServiceReq(const StartServiceReq& from);
  StartServiceReq(StartServiceReq&& from) noexcept
    : StartServiceReq() {
    *this = ::std::move(from);
  }

  inline StartServiceReq& operator=(const StartServiceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartServiceReq& operator=(StartServiceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartServiceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartServiceReq* internal_default_instance() {
    return reinterpret_cast<const StartServiceReq*>(
               &_StartServiceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(StartServiceReq& a, StartServiceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(StartServiceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartServiceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartServiceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartServiceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartServiceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartServiceReq& from) {
    StartServiceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartServiceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.StartServiceReq";
  }
  protected:
  explicit StartServiceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kServiceDescriptionFieldNumber = 2,
    kBinPathFieldNumber = 3,
    kHostnameFieldNumber = 4,
    kArgumentsFieldNumber = 5,
    kRequestFieldNumber = 9,
  };
  // string ServiceName = 1;
  void clear_servicename();
  const std::string& servicename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servicename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servicename();
  PROTOBUF_NODISCARD std::string* release_servicename();
  void set_allocated_servicename(std::string* servicename);
  private:
  const std::string& _internal_servicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servicename(const std::string& value);
  std::string* _internal_mutable_servicename();
  public:

  // string ServiceDescription = 2;
  void clear_servicedescription();
  const std::string& servicedescription() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servicedescription(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servicedescription();
  PROTOBUF_NODISCARD std::string* release_servicedescription();
  void set_allocated_servicedescription(std::string* servicedescription);
  private:
  const std::string& _internal_servicedescription() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servicedescription(const std::string& value);
  std::string* _internal_mutable_servicedescription();
  public:

  // string BinPath = 3;
  void clear_binpath();
  const std::string& binpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binpath();
  PROTOBUF_NODISCARD std::string* release_binpath();
  void set_allocated_binpath(std::string* binpath);
  private:
  const std::string& _internal_binpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binpath(const std::string& value);
  std::string* _internal_mutable_binpath();
  public:

  // string Hostname = 4;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // string Arguments = 5;
  void clear_arguments();
  const std::string& arguments() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arguments(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arguments();
  PROTOBUF_NODISCARD std::string* release_arguments();
  void set_allocated_arguments(std::string* arguments);
  private:
  const std::string& _internal_arguments() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arguments(const std::string& value);
  std::string* _internal_mutable_arguments();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.StartServiceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servicename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servicedescription_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arguments_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class ServiceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.ServiceInfo) */ {
 public:
  inline ServiceInfo() : ServiceInfo(nullptr) {}
  ~ServiceInfo() override;
  explicit PROTOBUF_CONSTEXPR ServiceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceInfo(const ServiceInfo& from);
  ServiceInfo(ServiceInfo&& from) noexcept
    : ServiceInfo() {
    *this = ::std::move(from);
  }

  inline ServiceInfo& operator=(const ServiceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceInfo& operator=(ServiceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceInfo* internal_default_instance() {
    return reinterpret_cast<const ServiceInfo*>(
               &_ServiceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(ServiceInfo& a, ServiceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceInfo& from) {
    ServiceInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.ServiceInfo";
  }
  protected:
  explicit ServiceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 9,
  };
  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.ServiceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class ServiceInfoReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.ServiceInfoReq) */ {
 public:
  inline ServiceInfoReq() : ServiceInfoReq(nullptr) {}
  ~ServiceInfoReq() override;
  explicit PROTOBUF_CONSTEXPR ServiceInfoReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceInfoReq(const ServiceInfoReq& from);
  ServiceInfoReq(ServiceInfoReq&& from) noexcept
    : ServiceInfoReq() {
    *this = ::std::move(from);
  }

  inline ServiceInfoReq& operator=(const ServiceInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceInfoReq& operator=(ServiceInfoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceInfoReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceInfoReq* internal_default_instance() {
    return reinterpret_cast<const ServiceInfoReq*>(
               &_ServiceInfoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(ServiceInfoReq& a, ServiceInfoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceInfoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceInfoReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceInfoReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceInfoReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceInfoReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceInfoReq& from) {
    ServiceInfoReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceInfoReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.ServiceInfoReq";
  }
  protected:
  explicit ServiceInfoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostnameFieldNumber = 2,
  };
  // string ServiceName = 1;
  void clear_servicename();
  const std::string& servicename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servicename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servicename();
  PROTOBUF_NODISCARD std::string* release_servicename();
  void set_allocated_servicename(std::string* servicename);
  private:
  const std::string& _internal_servicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servicename(const std::string& value);
  std::string* _internal_mutable_servicename();
  public:

  // string Hostname = 2;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.ServiceInfoReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servicename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class StopServiceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.StopServiceReq) */ {
 public:
  inline StopServiceReq() : StopServiceReq(nullptr) {}
  ~StopServiceReq() override;
  explicit PROTOBUF_CONSTEXPR StopServiceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopServiceReq(const StopServiceReq& from);
  StopServiceReq(StopServiceReq&& from) noexcept
    : StopServiceReq() {
    *this = ::std::move(from);
  }

  inline StopServiceReq& operator=(const StopServiceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopServiceReq& operator=(StopServiceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopServiceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopServiceReq* internal_default_instance() {
    return reinterpret_cast<const StopServiceReq*>(
               &_StopServiceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(StopServiceReq& a, StopServiceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(StopServiceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopServiceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopServiceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopServiceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopServiceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopServiceReq& from) {
    StopServiceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopServiceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.StopServiceReq";
  }
  protected:
  explicit StopServiceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceInfoFieldNumber = 1,
    kRequestFieldNumber = 9,
  };
  // .sliverpb.ServiceInfoReq ServiceInfo = 1;
  bool has_serviceinfo() const;
  private:
  bool _internal_has_serviceinfo() const;
  public:
  void clear_serviceinfo();
  const ::sliverpb::ServiceInfoReq& serviceinfo() const;
  PROTOBUF_NODISCARD ::sliverpb::ServiceInfoReq* release_serviceinfo();
  ::sliverpb::ServiceInfoReq* mutable_serviceinfo();
  void set_allocated_serviceinfo(::sliverpb::ServiceInfoReq* serviceinfo);
  private:
  const ::sliverpb::ServiceInfoReq& _internal_serviceinfo() const;
  ::sliverpb::ServiceInfoReq* _internal_mutable_serviceinfo();
  public:
  void unsafe_arena_set_allocated_serviceinfo(
      ::sliverpb::ServiceInfoReq* serviceinfo);
  ::sliverpb::ServiceInfoReq* unsafe_arena_release_serviceinfo();

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.StopServiceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::ServiceInfoReq* serviceinfo_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RemoveServiceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RemoveServiceReq) */ {
 public:
  inline RemoveServiceReq() : RemoveServiceReq(nullptr) {}
  ~RemoveServiceReq() override;
  explicit PROTOBUF_CONSTEXPR RemoveServiceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveServiceReq(const RemoveServiceReq& from);
  RemoveServiceReq(RemoveServiceReq&& from) noexcept
    : RemoveServiceReq() {
    *this = ::std::move(from);
  }

  inline RemoveServiceReq& operator=(const RemoveServiceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveServiceReq& operator=(RemoveServiceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveServiceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveServiceReq* internal_default_instance() {
    return reinterpret_cast<const RemoveServiceReq*>(
               &_RemoveServiceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(RemoveServiceReq& a, RemoveServiceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveServiceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveServiceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveServiceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveServiceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveServiceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveServiceReq& from) {
    RemoveServiceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveServiceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RemoveServiceReq";
  }
  protected:
  explicit RemoveServiceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceInfoFieldNumber = 1,
    kRequestFieldNumber = 9,
  };
  // .sliverpb.ServiceInfoReq ServiceInfo = 1;
  bool has_serviceinfo() const;
  private:
  bool _internal_has_serviceinfo() const;
  public:
  void clear_serviceinfo();
  const ::sliverpb::ServiceInfoReq& serviceinfo() const;
  PROTOBUF_NODISCARD ::sliverpb::ServiceInfoReq* release_serviceinfo();
  ::sliverpb::ServiceInfoReq* mutable_serviceinfo();
  void set_allocated_serviceinfo(::sliverpb::ServiceInfoReq* serviceinfo);
  private:
  const ::sliverpb::ServiceInfoReq& _internal_serviceinfo() const;
  ::sliverpb::ServiceInfoReq* _internal_mutable_serviceinfo();
  public:
  void unsafe_arena_set_allocated_serviceinfo(
      ::sliverpb::ServiceInfoReq* serviceinfo);
  ::sliverpb::ServiceInfoReq* unsafe_arena_release_serviceinfo();

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.RemoveServiceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::ServiceInfoReq* serviceinfo_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class BackdoorReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.BackdoorReq) */ {
 public:
  inline BackdoorReq() : BackdoorReq(nullptr) {}
  ~BackdoorReq() override;
  explicit PROTOBUF_CONSTEXPR BackdoorReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BackdoorReq(const BackdoorReq& from);
  BackdoorReq(BackdoorReq&& from) noexcept
    : BackdoorReq() {
    *this = ::std::move(from);
  }

  inline BackdoorReq& operator=(const BackdoorReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackdoorReq& operator=(BackdoorReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BackdoorReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const BackdoorReq* internal_default_instance() {
    return reinterpret_cast<const BackdoorReq*>(
               &_BackdoorReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(BackdoorReq& a, BackdoorReq& b) {
    a.Swap(&b);
  }
  inline void Swap(BackdoorReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackdoorReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BackdoorReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BackdoorReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BackdoorReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BackdoorReq& from) {
    BackdoorReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BackdoorReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.BackdoorReq";
  }
  protected:
  explicit BackdoorReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilePathFieldNumber = 1,
    kProfileNameFieldNumber = 2,
    kRequestFieldNumber = 9,
  };
  // string FilePath = 1;
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // string ProfileName = 2;
  void clear_profilename();
  const std::string& profilename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_profilename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_profilename();
  PROTOBUF_NODISCARD std::string* release_profilename();
  void set_allocated_profilename(std::string* profilename);
  private:
  const std::string& _internal_profilename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_profilename(const std::string& value);
  std::string* _internal_mutable_profilename();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.BackdoorReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profilename_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Backdoor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Backdoor) */ {
 public:
  inline Backdoor() : Backdoor(nullptr) {}
  ~Backdoor() override;
  explicit PROTOBUF_CONSTEXPR Backdoor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backdoor(const Backdoor& from);
  Backdoor(Backdoor&& from) noexcept
    : Backdoor() {
    *this = ::std::move(from);
  }

  inline Backdoor& operator=(const Backdoor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backdoor& operator=(Backdoor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backdoor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backdoor* internal_default_instance() {
    return reinterpret_cast<const Backdoor*>(
               &_Backdoor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(Backdoor& a, Backdoor& b) {
    a.Swap(&b);
  }
  inline void Swap(Backdoor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backdoor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backdoor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backdoor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backdoor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Backdoor& from) {
    Backdoor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backdoor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Backdoor";
  }
  protected:
  explicit Backdoor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 9,
  };
  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.Backdoor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RegistryReadReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RegistryReadReq) */ {
 public:
  inline RegistryReadReq() : RegistryReadReq(nullptr) {}
  ~RegistryReadReq() override;
  explicit PROTOBUF_CONSTEXPR RegistryReadReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistryReadReq(const RegistryReadReq& from);
  RegistryReadReq(RegistryReadReq&& from) noexcept
    : RegistryReadReq() {
    *this = ::std::move(from);
  }

  inline RegistryReadReq& operator=(const RegistryReadReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistryReadReq& operator=(RegistryReadReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistryReadReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistryReadReq* internal_default_instance() {
    return reinterpret_cast<const RegistryReadReq*>(
               &_RegistryReadReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(RegistryReadReq& a, RegistryReadReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistryReadReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistryReadReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistryReadReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistryReadReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistryReadReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistryReadReq& from) {
    RegistryReadReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistryReadReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RegistryReadReq";
  }
  protected:
  explicit RegistryReadReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiveFieldNumber = 1,
    kPathFieldNumber = 2,
    kKeyFieldNumber = 3,
    kHostnameFieldNumber = 4,
    kRequestFieldNumber = 9,
  };
  // string Hive = 1;
  void clear_hive();
  const std::string& hive() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hive(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hive();
  PROTOBUF_NODISCARD std::string* release_hive();
  void set_allocated_hive(std::string* hive);
  private:
  const std::string& _internal_hive() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hive(const std::string& value);
  std::string* _internal_mutable_hive();
  public:

  // string Path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string Key = 3;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string Hostname = 4;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.RegistryReadReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hive_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RegistryRead final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RegistryRead) */ {
 public:
  inline RegistryRead() : RegistryRead(nullptr) {}
  ~RegistryRead() override;
  explicit PROTOBUF_CONSTEXPR RegistryRead(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistryRead(const RegistryRead& from);
  RegistryRead(RegistryRead&& from) noexcept
    : RegistryRead() {
    *this = ::std::move(from);
  }

  inline RegistryRead& operator=(const RegistryRead& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistryRead& operator=(RegistryRead&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistryRead& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistryRead* internal_default_instance() {
    return reinterpret_cast<const RegistryRead*>(
               &_RegistryRead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(RegistryRead& a, RegistryRead& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistryRead* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistryRead* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistryRead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistryRead>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistryRead& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistryRead& from) {
    RegistryRead::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistryRead* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RegistryRead";
  }
  protected:
  explicit RegistryRead(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // string Value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.RegistryRead)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RegistryWriteReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RegistryWriteReq) */ {
 public:
  inline RegistryWriteReq() : RegistryWriteReq(nullptr) {}
  ~RegistryWriteReq() override;
  explicit PROTOBUF_CONSTEXPR RegistryWriteReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistryWriteReq(const RegistryWriteReq& from);
  RegistryWriteReq(RegistryWriteReq&& from) noexcept
    : RegistryWriteReq() {
    *this = ::std::move(from);
  }

  inline RegistryWriteReq& operator=(const RegistryWriteReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistryWriteReq& operator=(RegistryWriteReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistryWriteReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistryWriteReq* internal_default_instance() {
    return reinterpret_cast<const RegistryWriteReq*>(
               &_RegistryWriteReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(RegistryWriteReq& a, RegistryWriteReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistryWriteReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistryWriteReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistryWriteReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistryWriteReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistryWriteReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistryWriteReq& from) {
    RegistryWriteReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistryWriteReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RegistryWriteReq";
  }
  protected:
  explicit RegistryWriteReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiveFieldNumber = 1,
    kPathFieldNumber = 2,
    kKeyFieldNumber = 3,
    kHostnameFieldNumber = 4,
    kStringValueFieldNumber = 5,
    kByteValueFieldNumber = 6,
    kRequestFieldNumber = 9,
    kQWordValueFieldNumber = 8,
    kDWordValueFieldNumber = 7,
    kTypeFieldNumber = 10,
  };
  // string Hive = 1;
  void clear_hive();
  const std::string& hive() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hive(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hive();
  PROTOBUF_NODISCARD std::string* release_hive();
  void set_allocated_hive(std::string* hive);
  private:
  const std::string& _internal_hive() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hive(const std::string& value);
  std::string* _internal_mutable_hive();
  public:

  // string Path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string Key = 3;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string Hostname = 4;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // string StringValue = 5;
  void clear_stringvalue();
  const std::string& stringvalue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stringvalue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stringvalue();
  PROTOBUF_NODISCARD std::string* release_stringvalue();
  void set_allocated_stringvalue(std::string* stringvalue);
  private:
  const std::string& _internal_stringvalue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stringvalue(const std::string& value);
  std::string* _internal_mutable_stringvalue();
  public:

  // bytes ByteValue = 6;
  void clear_bytevalue();
  const std::string& bytevalue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bytevalue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bytevalue();
  PROTOBUF_NODISCARD std::string* release_bytevalue();
  void set_allocated_bytevalue(std::string* bytevalue);
  private:
  const std::string& _internal_bytevalue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bytevalue(const std::string& value);
  std::string* _internal_mutable_bytevalue();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // uint64 QWordValue = 8;
  void clear_qwordvalue();
  uint64_t qwordvalue() const;
  void set_qwordvalue(uint64_t value);
  private:
  uint64_t _internal_qwordvalue() const;
  void _internal_set_qwordvalue(uint64_t value);
  public:

  // uint32 DWordValue = 7;
  void clear_dwordvalue();
  uint32_t dwordvalue() const;
  void set_dwordvalue(uint32_t value);
  private:
  uint32_t _internal_dwordvalue() const;
  void _internal_set_dwordvalue(uint32_t value);
  public:

  // uint32 Type = 10;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.RegistryWriteReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hive_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stringvalue_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bytevalue_;
    ::sliverpb::Request* request_;
    uint64_t qwordvalue_;
    uint32_t dwordvalue_;
    uint32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RegistryWrite final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RegistryWrite) */ {
 public:
  inline RegistryWrite() : RegistryWrite(nullptr) {}
  ~RegistryWrite() override;
  explicit PROTOBUF_CONSTEXPR RegistryWrite(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistryWrite(const RegistryWrite& from);
  RegistryWrite(RegistryWrite&& from) noexcept
    : RegistryWrite() {
    *this = ::std::move(from);
  }

  inline RegistryWrite& operator=(const RegistryWrite& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistryWrite& operator=(RegistryWrite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistryWrite& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistryWrite* internal_default_instance() {
    return reinterpret_cast<const RegistryWrite*>(
               &_RegistryWrite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(RegistryWrite& a, RegistryWrite& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistryWrite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistryWrite* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistryWrite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistryWrite>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistryWrite& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistryWrite& from) {
    RegistryWrite::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistryWrite* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RegistryWrite";
  }
  protected:
  explicit RegistryWrite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 9,
  };
  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.RegistryWrite)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RegistryCreateKeyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RegistryCreateKeyReq) */ {
 public:
  inline RegistryCreateKeyReq() : RegistryCreateKeyReq(nullptr) {}
  ~RegistryCreateKeyReq() override;
  explicit PROTOBUF_CONSTEXPR RegistryCreateKeyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistryCreateKeyReq(const RegistryCreateKeyReq& from);
  RegistryCreateKeyReq(RegistryCreateKeyReq&& from) noexcept
    : RegistryCreateKeyReq() {
    *this = ::std::move(from);
  }

  inline RegistryCreateKeyReq& operator=(const RegistryCreateKeyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistryCreateKeyReq& operator=(RegistryCreateKeyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistryCreateKeyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistryCreateKeyReq* internal_default_instance() {
    return reinterpret_cast<const RegistryCreateKeyReq*>(
               &_RegistryCreateKeyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(RegistryCreateKeyReq& a, RegistryCreateKeyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistryCreateKeyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistryCreateKeyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistryCreateKeyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistryCreateKeyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistryCreateKeyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistryCreateKeyReq& from) {
    RegistryCreateKeyReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistryCreateKeyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RegistryCreateKeyReq";
  }
  protected:
  explicit RegistryCreateKeyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiveFieldNumber = 1,
    kPathFieldNumber = 2,
    kKeyFieldNumber = 3,
    kHostnameFieldNumber = 4,
    kRequestFieldNumber = 9,
  };
  // string Hive = 1;
  void clear_hive();
  const std::string& hive() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hive(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hive();
  PROTOBUF_NODISCARD std::string* release_hive();
  void set_allocated_hive(std::string* hive);
  private:
  const std::string& _internal_hive() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hive(const std::string& value);
  std::string* _internal_mutable_hive();
  public:

  // string Path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string Key = 3;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string Hostname = 4;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.RegistryCreateKeyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hive_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RegistryCreateKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RegistryCreateKey) */ {
 public:
  inline RegistryCreateKey() : RegistryCreateKey(nullptr) {}
  ~RegistryCreateKey() override;
  explicit PROTOBUF_CONSTEXPR RegistryCreateKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistryCreateKey(const RegistryCreateKey& from);
  RegistryCreateKey(RegistryCreateKey&& from) noexcept
    : RegistryCreateKey() {
    *this = ::std::move(from);
  }

  inline RegistryCreateKey& operator=(const RegistryCreateKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistryCreateKey& operator=(RegistryCreateKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistryCreateKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistryCreateKey* internal_default_instance() {
    return reinterpret_cast<const RegistryCreateKey*>(
               &_RegistryCreateKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(RegistryCreateKey& a, RegistryCreateKey& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistryCreateKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistryCreateKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistryCreateKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistryCreateKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistryCreateKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistryCreateKey& from) {
    RegistryCreateKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistryCreateKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RegistryCreateKey";
  }
  protected:
  explicit RegistryCreateKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 9,
  };
  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.RegistryCreateKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RegistryDeleteKeyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RegistryDeleteKeyReq) */ {
 public:
  inline RegistryDeleteKeyReq() : RegistryDeleteKeyReq(nullptr) {}
  ~RegistryDeleteKeyReq() override;
  explicit PROTOBUF_CONSTEXPR RegistryDeleteKeyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistryDeleteKeyReq(const RegistryDeleteKeyReq& from);
  RegistryDeleteKeyReq(RegistryDeleteKeyReq&& from) noexcept
    : RegistryDeleteKeyReq() {
    *this = ::std::move(from);
  }

  inline RegistryDeleteKeyReq& operator=(const RegistryDeleteKeyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistryDeleteKeyReq& operator=(RegistryDeleteKeyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistryDeleteKeyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistryDeleteKeyReq* internal_default_instance() {
    return reinterpret_cast<const RegistryDeleteKeyReq*>(
               &_RegistryDeleteKeyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(RegistryDeleteKeyReq& a, RegistryDeleteKeyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistryDeleteKeyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistryDeleteKeyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistryDeleteKeyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistryDeleteKeyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistryDeleteKeyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistryDeleteKeyReq& from) {
    RegistryDeleteKeyReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistryDeleteKeyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RegistryDeleteKeyReq";
  }
  protected:
  explicit RegistryDeleteKeyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiveFieldNumber = 1,
    kPathFieldNumber = 2,
    kKeyFieldNumber = 3,
    kHostnameFieldNumber = 4,
    kRequestFieldNumber = 9,
  };
  // string Hive = 1;
  void clear_hive();
  const std::string& hive() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hive(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hive();
  PROTOBUF_NODISCARD std::string* release_hive();
  void set_allocated_hive(std::string* hive);
  private:
  const std::string& _internal_hive() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hive(const std::string& value);
  std::string* _internal_mutable_hive();
  public:

  // string Path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string Key = 3;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string Hostname = 4;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.RegistryDeleteKeyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hive_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RegistryDeleteKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RegistryDeleteKey) */ {
 public:
  inline RegistryDeleteKey() : RegistryDeleteKey(nullptr) {}
  ~RegistryDeleteKey() override;
  explicit PROTOBUF_CONSTEXPR RegistryDeleteKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistryDeleteKey(const RegistryDeleteKey& from);
  RegistryDeleteKey(RegistryDeleteKey&& from) noexcept
    : RegistryDeleteKey() {
    *this = ::std::move(from);
  }

  inline RegistryDeleteKey& operator=(const RegistryDeleteKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistryDeleteKey& operator=(RegistryDeleteKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistryDeleteKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistryDeleteKey* internal_default_instance() {
    return reinterpret_cast<const RegistryDeleteKey*>(
               &_RegistryDeleteKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(RegistryDeleteKey& a, RegistryDeleteKey& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistryDeleteKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistryDeleteKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistryDeleteKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistryDeleteKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistryDeleteKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistryDeleteKey& from) {
    RegistryDeleteKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistryDeleteKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RegistryDeleteKey";
  }
  protected:
  explicit RegistryDeleteKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 9,
  };
  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.RegistryDeleteKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RegistrySubKeyListReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RegistrySubKeyListReq) */ {
 public:
  inline RegistrySubKeyListReq() : RegistrySubKeyListReq(nullptr) {}
  ~RegistrySubKeyListReq() override;
  explicit PROTOBUF_CONSTEXPR RegistrySubKeyListReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistrySubKeyListReq(const RegistrySubKeyListReq& from);
  RegistrySubKeyListReq(RegistrySubKeyListReq&& from) noexcept
    : RegistrySubKeyListReq() {
    *this = ::std::move(from);
  }

  inline RegistrySubKeyListReq& operator=(const RegistrySubKeyListReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistrySubKeyListReq& operator=(RegistrySubKeyListReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistrySubKeyListReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistrySubKeyListReq* internal_default_instance() {
    return reinterpret_cast<const RegistrySubKeyListReq*>(
               &_RegistrySubKeyListReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(RegistrySubKeyListReq& a, RegistrySubKeyListReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistrySubKeyListReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistrySubKeyListReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistrySubKeyListReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistrySubKeyListReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistrySubKeyListReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistrySubKeyListReq& from) {
    RegistrySubKeyListReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistrySubKeyListReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RegistrySubKeyListReq";
  }
  protected:
  explicit RegistrySubKeyListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiveFieldNumber = 1,
    kPathFieldNumber = 2,
    kHostnameFieldNumber = 4,
    kRequestFieldNumber = 9,
  };
  // string Hive = 1;
  void clear_hive();
  const std::string& hive() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hive(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hive();
  PROTOBUF_NODISCARD std::string* release_hive();
  void set_allocated_hive(std::string* hive);
  private:
  const std::string& _internal_hive() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hive(const std::string& value);
  std::string* _internal_mutable_hive();
  public:

  // string Path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string Hostname = 4;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.RegistrySubKeyListReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hive_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RegistrySubKeyList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RegistrySubKeyList) */ {
 public:
  inline RegistrySubKeyList() : RegistrySubKeyList(nullptr) {}
  ~RegistrySubKeyList() override;
  explicit PROTOBUF_CONSTEXPR RegistrySubKeyList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistrySubKeyList(const RegistrySubKeyList& from);
  RegistrySubKeyList(RegistrySubKeyList&& from) noexcept
    : RegistrySubKeyList() {
    *this = ::std::move(from);
  }

  inline RegistrySubKeyList& operator=(const RegistrySubKeyList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistrySubKeyList& operator=(RegistrySubKeyList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistrySubKeyList& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistrySubKeyList* internal_default_instance() {
    return reinterpret_cast<const RegistrySubKeyList*>(
               &_RegistrySubKeyList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(RegistrySubKeyList& a, RegistrySubKeyList& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistrySubKeyList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistrySubKeyList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistrySubKeyList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistrySubKeyList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistrySubKeyList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistrySubKeyList& from) {
    RegistrySubKeyList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistrySubKeyList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RegistrySubKeyList";
  }
  protected:
  explicit RegistrySubKeyList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubkeysFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // repeated string Subkeys = 1;
  int subkeys_size() const;
  private:
  int _internal_subkeys_size() const;
  public:
  void clear_subkeys();
  const std::string& subkeys(int index) const;
  std::string* mutable_subkeys(int index);
  void set_subkeys(int index, const std::string& value);
  void set_subkeys(int index, std::string&& value);
  void set_subkeys(int index, const char* value);
  void set_subkeys(int index, const char* value, size_t size);
  std::string* add_subkeys();
  void add_subkeys(const std::string& value);
  void add_subkeys(std::string&& value);
  void add_subkeys(const char* value);
  void add_subkeys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& subkeys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_subkeys();
  private:
  const std::string& _internal_subkeys(int index) const;
  std::string* _internal_add_subkeys();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.RegistrySubKeyList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> subkeys_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RegistryListValuesReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RegistryListValuesReq) */ {
 public:
  inline RegistryListValuesReq() : RegistryListValuesReq(nullptr) {}
  ~RegistryListValuesReq() override;
  explicit PROTOBUF_CONSTEXPR RegistryListValuesReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistryListValuesReq(const RegistryListValuesReq& from);
  RegistryListValuesReq(RegistryListValuesReq&& from) noexcept
    : RegistryListValuesReq() {
    *this = ::std::move(from);
  }

  inline RegistryListValuesReq& operator=(const RegistryListValuesReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistryListValuesReq& operator=(RegistryListValuesReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistryListValuesReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistryListValuesReq* internal_default_instance() {
    return reinterpret_cast<const RegistryListValuesReq*>(
               &_RegistryListValuesReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(RegistryListValuesReq& a, RegistryListValuesReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistryListValuesReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistryListValuesReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistryListValuesReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistryListValuesReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistryListValuesReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistryListValuesReq& from) {
    RegistryListValuesReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistryListValuesReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RegistryListValuesReq";
  }
  protected:
  explicit RegistryListValuesReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiveFieldNumber = 1,
    kPathFieldNumber = 2,
    kHostnameFieldNumber = 4,
    kRequestFieldNumber = 9,
  };
  // string Hive = 1;
  void clear_hive();
  const std::string& hive() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hive(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hive();
  PROTOBUF_NODISCARD std::string* release_hive();
  void set_allocated_hive(std::string* hive);
  private:
  const std::string& _internal_hive() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hive(const std::string& value);
  std::string* _internal_mutable_hive();
  public:

  // string Path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string Hostname = 4;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.RegistryListValuesReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hive_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RegistryValuesList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RegistryValuesList) */ {
 public:
  inline RegistryValuesList() : RegistryValuesList(nullptr) {}
  ~RegistryValuesList() override;
  explicit PROTOBUF_CONSTEXPR RegistryValuesList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistryValuesList(const RegistryValuesList& from);
  RegistryValuesList(RegistryValuesList&& from) noexcept
    : RegistryValuesList() {
    *this = ::std::move(from);
  }

  inline RegistryValuesList& operator=(const RegistryValuesList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistryValuesList& operator=(RegistryValuesList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistryValuesList& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistryValuesList* internal_default_instance() {
    return reinterpret_cast<const RegistryValuesList*>(
               &_RegistryValuesList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(RegistryValuesList& a, RegistryValuesList& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistryValuesList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistryValuesList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistryValuesList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistryValuesList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistryValuesList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistryValuesList& from) {
    RegistryValuesList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistryValuesList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RegistryValuesList";
  }
  protected:
  explicit RegistryValuesList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueNamesFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // repeated string ValueNames = 1;
  int valuenames_size() const;
  private:
  int _internal_valuenames_size() const;
  public:
  void clear_valuenames();
  const std::string& valuenames(int index) const;
  std::string* mutable_valuenames(int index);
  void set_valuenames(int index, const std::string& value);
  void set_valuenames(int index, std::string&& value);
  void set_valuenames(int index, const char* value);
  void set_valuenames(int index, const char* value, size_t size);
  std::string* add_valuenames();
  void add_valuenames(const std::string& value);
  void add_valuenames(std::string&& value);
  void add_valuenames(const char* value);
  void add_valuenames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& valuenames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_valuenames();
  private:
  const std::string& _internal_valuenames(int index) const;
  std::string* _internal_add_valuenames();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.RegistryValuesList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> valuenames_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Tunnel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Tunnel) */ {
 public:
  inline Tunnel() : Tunnel(nullptr) {}
  ~Tunnel() override;
  explicit PROTOBUF_CONSTEXPR Tunnel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tunnel(const Tunnel& from);
  Tunnel(Tunnel&& from) noexcept
    : Tunnel() {
    *this = ::std::move(from);
  }

  inline Tunnel& operator=(const Tunnel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tunnel& operator=(Tunnel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tunnel& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tunnel* internal_default_instance() {
    return reinterpret_cast<const Tunnel*>(
               &_Tunnel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(Tunnel& a, Tunnel& b) {
    a.Swap(&b);
  }
  inline void Swap(Tunnel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tunnel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tunnel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tunnel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tunnel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tunnel& from) {
    Tunnel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tunnel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Tunnel";
  }
  protected:
  explicit Tunnel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIDFieldNumber = 9,
    kTunnelIDFieldNumber = 8,
  };
  // string SessionID = 9;
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // uint64 TunnelID = 8 [jstype = JS_STRING];
  void clear_tunnelid();
  uint64_t tunnelid() const;
  void set_tunnelid(uint64_t value);
  private:
  uint64_t _internal_tunnelid() const;
  void _internal_set_tunnelid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.Tunnel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
    uint64_t tunnelid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class TunnelData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.TunnelData) */ {
 public:
  inline TunnelData() : TunnelData(nullptr) {}
  ~TunnelData() override;
  explicit PROTOBUF_CONSTEXPR TunnelData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TunnelData(const TunnelData& from);
  TunnelData(TunnelData&& from) noexcept
    : TunnelData() {
    *this = ::std::move(from);
  }

  inline TunnelData& operator=(const TunnelData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TunnelData& operator=(TunnelData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TunnelData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TunnelData* internal_default_instance() {
    return reinterpret_cast<const TunnelData*>(
               &_TunnelData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(TunnelData& a, TunnelData& b) {
    a.Swap(&b);
  }
  inline void Swap(TunnelData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TunnelData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TunnelData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TunnelData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TunnelData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TunnelData& from) {
    TunnelData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TunnelData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.TunnelData";
  }
  protected:
  explicit TunnelData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kSessionIDFieldNumber = 9,
    kRportfwdFieldNumber = 7,
    kSequenceFieldNumber = 3,
    kAckFieldNumber = 4,
    kTunnelIDFieldNumber = 8,
    kClosedFieldNumber = 2,
    kResendFieldNumber = 5,
    kCreateReverseFieldNumber = 6,
  };
  // bytes Data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string SessionID = 9;
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // .sliverpb.RPortfwd rportfwd = 7;
  bool has_rportfwd() const;
  private:
  bool _internal_has_rportfwd() const;
  public:
  void clear_rportfwd();
  const ::sliverpb::RPortfwd& rportfwd() const;
  PROTOBUF_NODISCARD ::sliverpb::RPortfwd* release_rportfwd();
  ::sliverpb::RPortfwd* mutable_rportfwd();
  void set_allocated_rportfwd(::sliverpb::RPortfwd* rportfwd);
  private:
  const ::sliverpb::RPortfwd& _internal_rportfwd() const;
  ::sliverpb::RPortfwd* _internal_mutable_rportfwd();
  public:
  void unsafe_arena_set_allocated_rportfwd(
      ::sliverpb::RPortfwd* rportfwd);
  ::sliverpb::RPortfwd* unsafe_arena_release_rportfwd();

  // uint64 Sequence = 3;
  void clear_sequence();
  uint64_t sequence() const;
  void set_sequence(uint64_t value);
  private:
  uint64_t _internal_sequence() const;
  void _internal_set_sequence(uint64_t value);
  public:

  // uint64 Ack = 4;
  void clear_ack();
  uint64_t ack() const;
  void set_ack(uint64_t value);
  private:
  uint64_t _internal_ack() const;
  void _internal_set_ack(uint64_t value);
  public:

  // uint64 TunnelID = 8 [jstype = JS_STRING];
  void clear_tunnelid();
  uint64_t tunnelid() const;
  void set_tunnelid(uint64_t value);
  private:
  uint64_t _internal_tunnelid() const;
  void _internal_set_tunnelid(uint64_t value);
  public:

  // bool Closed = 2;
  void clear_closed();
  bool closed() const;
  void set_closed(bool value);
  private:
  bool _internal_closed() const;
  void _internal_set_closed(bool value);
  public:

  // bool Resend = 5;
  void clear_resend();
  bool resend() const;
  void set_resend(bool value);
  private:
  bool _internal_resend() const;
  void _internal_set_resend(bool value);
  public:

  // bool CreateReverse = 6;
  void clear_createreverse();
  bool createreverse() const;
  void set_createreverse(bool value);
  private:
  bool _internal_createreverse() const;
  void _internal_set_createreverse(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.TunnelData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
    ::sliverpb::RPortfwd* rportfwd_;
    uint64_t sequence_;
    uint64_t ack_;
    uint64_t tunnelid_;
    bool closed_;
    bool resend_;
    bool createreverse_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class ShellReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.ShellReq) */ {
 public:
  inline ShellReq() : ShellReq(nullptr) {}
  ~ShellReq() override;
  explicit PROTOBUF_CONSTEXPR ShellReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellReq(const ShellReq& from);
  ShellReq(ShellReq&& from) noexcept
    : ShellReq() {
    *this = ::std::move(from);
  }

  inline ShellReq& operator=(const ShellReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellReq& operator=(ShellReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellReq* internal_default_instance() {
    return reinterpret_cast<const ShellReq*>(
               &_ShellReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(ShellReq& a, ShellReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShellReq& from) {
    ShellReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.ShellReq";
  }
  protected:
  explicit ShellReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kRequestFieldNumber = 9,
    kEnablePTYFieldNumber = 2,
    kPidFieldNumber = 3,
    kTunnelIDFieldNumber = 8,
  };
  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // bool EnablePTY = 2;
  void clear_enablepty();
  bool enablepty() const;
  void set_enablepty(bool value);
  private:
  bool _internal_enablepty() const;
  void _internal_set_enablepty(bool value);
  public:

  // uint32 Pid = 3;
  void clear_pid();
  uint32_t pid() const;
  void set_pid(uint32_t value);
  private:
  uint32_t _internal_pid() const;
  void _internal_set_pid(uint32_t value);
  public:

  // uint64 TunnelID = 8 [jstype = JS_STRING];
  void clear_tunnelid();
  uint64_t tunnelid() const;
  void set_tunnelid(uint64_t value);
  private:
  uint64_t _internal_tunnelid() const;
  void _internal_set_tunnelid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.ShellReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::sliverpb::Request* request_;
    bool enablepty_;
    uint32_t pid_;
    uint64_t tunnelid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Shell final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Shell) */ {
 public:
  inline Shell() : Shell(nullptr) {}
  ~Shell() override;
  explicit PROTOBUF_CONSTEXPR Shell(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Shell(const Shell& from);
  Shell(Shell&& from) noexcept
    : Shell() {
    *this = ::std::move(from);
  }

  inline Shell& operator=(const Shell& from) {
    CopyFrom(from);
    return *this;
  }
  inline Shell& operator=(Shell&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Shell& default_instance() {
    return *internal_default_instance();
  }
  static inline const Shell* internal_default_instance() {
    return reinterpret_cast<const Shell*>(
               &_Shell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(Shell& a, Shell& b) {
    a.Swap(&b);
  }
  inline void Swap(Shell* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Shell* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Shell* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Shell>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Shell& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Shell& from) {
    Shell::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Shell* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Shell";
  }
  protected:
  explicit Shell(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kResponseFieldNumber = 9,
    kEnablePTYFieldNumber = 2,
    kPidFieldNumber = 3,
    kTunnelIDFieldNumber = 8,
  };
  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // bool EnablePTY = 2;
  void clear_enablepty();
  bool enablepty() const;
  void set_enablepty(bool value);
  private:
  bool _internal_enablepty() const;
  void _internal_set_enablepty(bool value);
  public:

  // uint32 Pid = 3;
  void clear_pid();
  uint32_t pid() const;
  void set_pid(uint32_t value);
  private:
  uint32_t _internal_pid() const;
  void _internal_set_pid(uint32_t value);
  public:

  // uint64 TunnelID = 8 [jstype = JS_STRING];
  void clear_tunnelid();
  uint64_t tunnelid() const;
  void set_tunnelid(uint64_t value);
  private:
  uint64_t _internal_tunnelid() const;
  void _internal_set_tunnelid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.Shell)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::sliverpb::Response* response_;
    bool enablepty_;
    uint32_t pid_;
    uint64_t tunnelid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class PortfwdReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.PortfwdReq) */ {
 public:
  inline PortfwdReq() : PortfwdReq(nullptr) {}
  ~PortfwdReq() override;
  explicit PROTOBUF_CONSTEXPR PortfwdReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortfwdReq(const PortfwdReq& from);
  PortfwdReq(PortfwdReq&& from) noexcept
    : PortfwdReq() {
    *this = ::std::move(from);
  }

  inline PortfwdReq& operator=(const PortfwdReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortfwdReq& operator=(PortfwdReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortfwdReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortfwdReq* internal_default_instance() {
    return reinterpret_cast<const PortfwdReq*>(
               &_PortfwdReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(PortfwdReq& a, PortfwdReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PortfwdReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortfwdReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortfwdReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortfwdReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortfwdReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PortfwdReq& from) {
    PortfwdReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortfwdReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.PortfwdReq";
  }
  protected:
  explicit PortfwdReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 3,
    kRequestFieldNumber = 9,
    kPortFieldNumber = 1,
    kProtocolFieldNumber = 2,
    kTunnelIDFieldNumber = 8,
  };
  // string Host = 3;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // uint32 Port = 1;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // int32 Protocol = 2;
  void clear_protocol();
  int32_t protocol() const;
  void set_protocol(int32_t value);
  private:
  int32_t _internal_protocol() const;
  void _internal_set_protocol(int32_t value);
  public:

  // uint64 TunnelID = 8 [jstype = JS_STRING];
  void clear_tunnelid();
  uint64_t tunnelid() const;
  void set_tunnelid(uint64_t value);
  private:
  uint64_t _internal_tunnelid() const;
  void _internal_set_tunnelid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.PortfwdReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::sliverpb::Request* request_;
    uint32_t port_;
    int32_t protocol_;
    uint64_t tunnelid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Portfwd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Portfwd) */ {
 public:
  inline Portfwd() : Portfwd(nullptr) {}
  ~Portfwd() override;
  explicit PROTOBUF_CONSTEXPR Portfwd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Portfwd(const Portfwd& from);
  Portfwd(Portfwd&& from) noexcept
    : Portfwd() {
    *this = ::std::move(from);
  }

  inline Portfwd& operator=(const Portfwd& from) {
    CopyFrom(from);
    return *this;
  }
  inline Portfwd& operator=(Portfwd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Portfwd& default_instance() {
    return *internal_default_instance();
  }
  static inline const Portfwd* internal_default_instance() {
    return reinterpret_cast<const Portfwd*>(
               &_Portfwd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(Portfwd& a, Portfwd& b) {
    a.Swap(&b);
  }
  inline void Swap(Portfwd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Portfwd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Portfwd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Portfwd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Portfwd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Portfwd& from) {
    Portfwd::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Portfwd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Portfwd";
  }
  protected:
  explicit Portfwd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 3,
    kResponseFieldNumber = 9,
    kPortFieldNumber = 1,
    kProtocolFieldNumber = 2,
    kTunnelIDFieldNumber = 8,
  };
  // string Host = 3;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // uint32 Port = 1;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // int32 Protocol = 2;
  void clear_protocol();
  int32_t protocol() const;
  void set_protocol(int32_t value);
  private:
  int32_t _internal_protocol() const;
  void _internal_set_protocol(int32_t value);
  public:

  // uint64 TunnelID = 8 [jstype = JS_STRING];
  void clear_tunnelid();
  uint64_t tunnelid() const;
  void set_tunnelid(uint64_t value);
  private:
  uint64_t _internal_tunnelid() const;
  void _internal_set_tunnelid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.Portfwd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::sliverpb::Response* response_;
    uint32_t port_;
    int32_t protocol_;
    uint64_t tunnelid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Socks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Socks) */ {
 public:
  inline Socks() : Socks(nullptr) {}
  ~Socks() override;
  explicit PROTOBUF_CONSTEXPR Socks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Socks(const Socks& from);
  Socks(Socks&& from) noexcept
    : Socks() {
    *this = ::std::move(from);
  }

  inline Socks& operator=(const Socks& from) {
    CopyFrom(from);
    return *this;
  }
  inline Socks& operator=(Socks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Socks& default_instance() {
    return *internal_default_instance();
  }
  static inline const Socks* internal_default_instance() {
    return reinterpret_cast<const Socks*>(
               &_Socks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(Socks& a, Socks& b) {
    a.Swap(&b);
  }
  inline void Swap(Socks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Socks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Socks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Socks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Socks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Socks& from) {
    Socks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Socks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Socks";
  }
  protected:
  explicit Socks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIDFieldNumber = 9,
    kTunnelIDFieldNumber = 8,
  };
  // string SessionID = 9;
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // uint64 TunnelID = 8 [jstype = JS_STRING];
  void clear_tunnelid();
  uint64_t tunnelid() const;
  void set_tunnelid(uint64_t value);
  private:
  uint64_t _internal_tunnelid() const;
  void _internal_set_tunnelid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.Socks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
    uint64_t tunnelid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class SocksData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.SocksData) */ {
 public:
  inline SocksData() : SocksData(nullptr) {}
  ~SocksData() override;
  explicit PROTOBUF_CONSTEXPR SocksData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SocksData(const SocksData& from);
  SocksData(SocksData&& from) noexcept
    : SocksData() {
    *this = ::std::move(from);
  }

  inline SocksData& operator=(const SocksData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SocksData& operator=(SocksData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SocksData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SocksData* internal_default_instance() {
    return reinterpret_cast<const SocksData*>(
               &_SocksData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(SocksData& a, SocksData& b) {
    a.Swap(&b);
  }
  inline void Swap(SocksData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SocksData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SocksData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SocksData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SocksData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SocksData& from) {
    SocksData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SocksData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.SocksData";
  }
  protected:
  explicit SocksData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kUsernameFieldNumber = 3,
    kPasswordFieldNumber = 4,
    kRequestFieldNumber = 9,
    kSequenceFieldNumber = 5,
    kTunnelIDFieldNumber = 8,
    kCloseConnFieldNumber = 2,
  };
  // bytes Data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string Username = 3;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string Password = 4;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // uint64 Sequence = 5;
  void clear_sequence();
  uint64_t sequence() const;
  void set_sequence(uint64_t value);
  private:
  uint64_t _internal_sequence() const;
  void _internal_set_sequence(uint64_t value);
  public:

  // uint64 TunnelID = 8 [jstype = JS_STRING];
  void clear_tunnelid();
  uint64_t tunnelid() const;
  void set_tunnelid(uint64_t value);
  private:
  uint64_t _internal_tunnelid() const;
  void _internal_set_tunnelid(uint64_t value);
  public:

  // bool CloseConn = 2;
  void clear_closeconn();
  bool closeconn() const;
  void set_closeconn(bool value);
  private:
  bool _internal_closeconn() const;
  void _internal_set_closeconn(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.SocksData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::sliverpb::Request* request_;
    uint64_t sequence_;
    uint64_t tunnelid_;
    bool closeconn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class PivotStartListenerReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.PivotStartListenerReq) */ {
 public:
  inline PivotStartListenerReq() : PivotStartListenerReq(nullptr) {}
  ~PivotStartListenerReq() override;
  explicit PROTOBUF_CONSTEXPR PivotStartListenerReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PivotStartListenerReq(const PivotStartListenerReq& from);
  PivotStartListenerReq(PivotStartListenerReq&& from) noexcept
    : PivotStartListenerReq() {
    *this = ::std::move(from);
  }

  inline PivotStartListenerReq& operator=(const PivotStartListenerReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PivotStartListenerReq& operator=(PivotStartListenerReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PivotStartListenerReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PivotStartListenerReq* internal_default_instance() {
    return reinterpret_cast<const PivotStartListenerReq*>(
               &_PivotStartListenerReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(PivotStartListenerReq& a, PivotStartListenerReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PivotStartListenerReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PivotStartListenerReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PivotStartListenerReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PivotStartListenerReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PivotStartListenerReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PivotStartListenerReq& from) {
    PivotStartListenerReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PivotStartListenerReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.PivotStartListenerReq";
  }
  protected:
  explicit PivotStartListenerReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 3,
    kBindAddressFieldNumber = 2,
    kRequestFieldNumber = 9,
    kTypeFieldNumber = 1,
  };
  // repeated bool Options = 3;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  private:
  bool _internal_options(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_options() const;
  void _internal_add_options(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_options();
  public:
  bool options(int index) const;
  void set_options(int index, bool value);
  void add_options(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      options() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_options();

  // string BindAddress = 2;
  void clear_bindaddress();
  const std::string& bindaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bindaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bindaddress();
  PROTOBUF_NODISCARD std::string* release_bindaddress();
  void set_allocated_bindaddress(std::string* bindaddress);
  private:
  const std::string& _internal_bindaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bindaddress(const std::string& value);
  std::string* _internal_mutable_bindaddress();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // .sliverpb.PivotType Type = 1;
  void clear_type();
  ::sliverpb::PivotType type() const;
  void set_type(::sliverpb::PivotType value);
  private:
  ::sliverpb::PivotType _internal_type() const;
  void _internal_set_type(::sliverpb::PivotType value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.PivotStartListenerReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bindaddress_;
    ::sliverpb::Request* request_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class PivotStopListenerReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.PivotStopListenerReq) */ {
 public:
  inline PivotStopListenerReq() : PivotStopListenerReq(nullptr) {}
  ~PivotStopListenerReq() override;
  explicit PROTOBUF_CONSTEXPR PivotStopListenerReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PivotStopListenerReq(const PivotStopListenerReq& from);
  PivotStopListenerReq(PivotStopListenerReq&& from) noexcept
    : PivotStopListenerReq() {
    *this = ::std::move(from);
  }

  inline PivotStopListenerReq& operator=(const PivotStopListenerReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PivotStopListenerReq& operator=(PivotStopListenerReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PivotStopListenerReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PivotStopListenerReq* internal_default_instance() {
    return reinterpret_cast<const PivotStopListenerReq*>(
               &_PivotStopListenerReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(PivotStopListenerReq& a, PivotStopListenerReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PivotStopListenerReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PivotStopListenerReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PivotStopListenerReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PivotStopListenerReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PivotStopListenerReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PivotStopListenerReq& from) {
    PivotStopListenerReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PivotStopListenerReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.PivotStopListenerReq";
  }
  protected:
  explicit PivotStopListenerReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
    kIDFieldNumber = 1,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // uint32 ID = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.PivotStopListenerReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class PivotListener final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.PivotListener) */ {
 public:
  inline PivotListener() : PivotListener(nullptr) {}
  ~PivotListener() override;
  explicit PROTOBUF_CONSTEXPR PivotListener(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PivotListener(const PivotListener& from);
  PivotListener(PivotListener&& from) noexcept
    : PivotListener() {
    *this = ::std::move(from);
  }

  inline PivotListener& operator=(const PivotListener& from) {
    CopyFrom(from);
    return *this;
  }
  inline PivotListener& operator=(PivotListener&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PivotListener& default_instance() {
    return *internal_default_instance();
  }
  static inline const PivotListener* internal_default_instance() {
    return reinterpret_cast<const PivotListener*>(
               &_PivotListener_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(PivotListener& a, PivotListener& b) {
    a.Swap(&b);
  }
  inline void Swap(PivotListener* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PivotListener* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PivotListener* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PivotListener>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PivotListener& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PivotListener& from) {
    PivotListener::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PivotListener* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.PivotListener";
  }
  protected:
  explicit PivotListener(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPivotsFieldNumber = 4,
    kBindAddressFieldNumber = 3,
    kResponseFieldNumber = 9,
    kIDFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // repeated .sliverpb.NetConnPivot Pivots = 4;
  int pivots_size() const;
  private:
  int _internal_pivots_size() const;
  public:
  void clear_pivots();
  ::sliverpb::NetConnPivot* mutable_pivots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::NetConnPivot >*
      mutable_pivots();
  private:
  const ::sliverpb::NetConnPivot& _internal_pivots(int index) const;
  ::sliverpb::NetConnPivot* _internal_add_pivots();
  public:
  const ::sliverpb::NetConnPivot& pivots(int index) const;
  ::sliverpb::NetConnPivot* add_pivots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::NetConnPivot >&
      pivots() const;

  // string BindAddress = 3;
  void clear_bindaddress();
  const std::string& bindaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bindaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bindaddress();
  PROTOBUF_NODISCARD std::string* release_bindaddress();
  void set_allocated_bindaddress(std::string* bindaddress);
  private:
  const std::string& _internal_bindaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bindaddress(const std::string& value);
  std::string* _internal_mutable_bindaddress();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // uint32 ID = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // .sliverpb.PivotType Type = 2;
  void clear_type();
  ::sliverpb::PivotType type() const;
  void set_type(::sliverpb::PivotType value);
  private:
  ::sliverpb::PivotType _internal_type() const;
  void _internal_set_type(::sliverpb::PivotType value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.PivotListener)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::NetConnPivot > pivots_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bindaddress_;
    ::sliverpb::Response* response_;
    uint32_t id_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class PivotHello final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.PivotHello) */ {
 public:
  inline PivotHello() : PivotHello(nullptr) {}
  ~PivotHello() override;
  explicit PROTOBUF_CONSTEXPR PivotHello(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PivotHello(const PivotHello& from);
  PivotHello(PivotHello&& from) noexcept
    : PivotHello() {
    *this = ::std::move(from);
  }

  inline PivotHello& operator=(const PivotHello& from) {
    CopyFrom(from);
    return *this;
  }
  inline PivotHello& operator=(PivotHello&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PivotHello& default_instance() {
    return *internal_default_instance();
  }
  static inline const PivotHello* internal_default_instance() {
    return reinterpret_cast<const PivotHello*>(
               &_PivotHello_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(PivotHello& a, PivotHello& b) {
    a.Swap(&b);
  }
  inline void Swap(PivotHello* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PivotHello* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PivotHello* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PivotHello>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PivotHello& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PivotHello& from) {
    PivotHello::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PivotHello* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.PivotHello";
  }
  protected:
  explicit PivotHello(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kPublicKeySignatureFieldNumber = 3,
    kSessionKeyFieldNumber = 4,
    kPeerIDFieldNumber = 2,
  };
  // bytes PublicKey = 1;
  void clear_publickey();
  const std::string& publickey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publickey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publickey();
  PROTOBUF_NODISCARD std::string* release_publickey();
  void set_allocated_publickey(std::string* publickey);
  private:
  const std::string& _internal_publickey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publickey(const std::string& value);
  std::string* _internal_mutable_publickey();
  public:

  // string PublicKeySignature = 3;
  void clear_publickeysignature();
  const std::string& publickeysignature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publickeysignature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publickeysignature();
  PROTOBUF_NODISCARD std::string* release_publickeysignature();
  void set_allocated_publickeysignature(std::string* publickeysignature);
  private:
  const std::string& _internal_publickeysignature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publickeysignature(const std::string& value);
  std::string* _internal_mutable_publickeysignature();
  public:

  // bytes SessionKey = 4;
  void clear_sessionkey();
  const std::string& sessionkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionkey();
  PROTOBUF_NODISCARD std::string* release_sessionkey();
  void set_allocated_sessionkey(std::string* sessionkey);
  private:
  const std::string& _internal_sessionkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionkey(const std::string& value);
  std::string* _internal_mutable_sessionkey();
  public:

  // int64 PeerID = 2 [jstype = JS_STRING];
  void clear_peerid();
  int64_t peerid() const;
  void set_peerid(int64_t value);
  private:
  int64_t _internal_peerid() const;
  void _internal_set_peerid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.PivotHello)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publickey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publickeysignature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionkey_;
    int64_t peerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class PivotServerKeyExchange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.PivotServerKeyExchange) */ {
 public:
  inline PivotServerKeyExchange() : PivotServerKeyExchange(nullptr) {}
  ~PivotServerKeyExchange() override;
  explicit PROTOBUF_CONSTEXPR PivotServerKeyExchange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PivotServerKeyExchange(const PivotServerKeyExchange& from);
  PivotServerKeyExchange(PivotServerKeyExchange&& from) noexcept
    : PivotServerKeyExchange() {
    *this = ::std::move(from);
  }

  inline PivotServerKeyExchange& operator=(const PivotServerKeyExchange& from) {
    CopyFrom(from);
    return *this;
  }
  inline PivotServerKeyExchange& operator=(PivotServerKeyExchange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PivotServerKeyExchange& default_instance() {
    return *internal_default_instance();
  }
  static inline const PivotServerKeyExchange* internal_default_instance() {
    return reinterpret_cast<const PivotServerKeyExchange*>(
               &_PivotServerKeyExchange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(PivotServerKeyExchange& a, PivotServerKeyExchange& b) {
    a.Swap(&b);
  }
  inline void Swap(PivotServerKeyExchange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PivotServerKeyExchange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PivotServerKeyExchange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PivotServerKeyExchange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PivotServerKeyExchange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PivotServerKeyExchange& from) {
    PivotServerKeyExchange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PivotServerKeyExchange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.PivotServerKeyExchange";
  }
  protected:
  explicit PivotServerKeyExchange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionKeyFieldNumber = 2,
    kOriginIDFieldNumber = 1,
  };
  // bytes SessionKey = 2;
  void clear_sessionkey();
  const std::string& sessionkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionkey();
  PROTOBUF_NODISCARD std::string* release_sessionkey();
  void set_allocated_sessionkey(std::string* sessionkey);
  private:
  const std::string& _internal_sessionkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionkey(const std::string& value);
  std::string* _internal_mutable_sessionkey();
  public:

  // int64 OriginID = 1;
  void clear_originid();
  int64_t originid() const;
  void set_originid(int64_t value);
  private:
  int64_t _internal_originid() const;
  void _internal_set_originid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.PivotServerKeyExchange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionkey_;
    int64_t originid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class PivotPeer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.PivotPeer) */ {
 public:
  inline PivotPeer() : PivotPeer(nullptr) {}
  ~PivotPeer() override;
  explicit PROTOBUF_CONSTEXPR PivotPeer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PivotPeer(const PivotPeer& from);
  PivotPeer(PivotPeer&& from) noexcept
    : PivotPeer() {
    *this = ::std::move(from);
  }

  inline PivotPeer& operator=(const PivotPeer& from) {
    CopyFrom(from);
    return *this;
  }
  inline PivotPeer& operator=(PivotPeer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PivotPeer& default_instance() {
    return *internal_default_instance();
  }
  static inline const PivotPeer* internal_default_instance() {
    return reinterpret_cast<const PivotPeer*>(
               &_PivotPeer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(PivotPeer& a, PivotPeer& b) {
    a.Swap(&b);
  }
  inline void Swap(PivotPeer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PivotPeer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PivotPeer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PivotPeer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PivotPeer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PivotPeer& from) {
    PivotPeer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PivotPeer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.PivotPeer";
  }
  protected:
  explicit PivotPeer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kPeerIDFieldNumber = 1,
  };
  // string Name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 PeerID = 1 [jstype = JS_STRING];
  void clear_peerid();
  int64_t peerid() const;
  void set_peerid(int64_t value);
  private:
  int64_t _internal_peerid() const;
  void _internal_set_peerid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.PivotPeer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int64_t peerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class PivotPeerEnvelope final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.PivotPeerEnvelope) */ {
 public:
  inline PivotPeerEnvelope() : PivotPeerEnvelope(nullptr) {}
  ~PivotPeerEnvelope() override;
  explicit PROTOBUF_CONSTEXPR PivotPeerEnvelope(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PivotPeerEnvelope(const PivotPeerEnvelope& from);
  PivotPeerEnvelope(PivotPeerEnvelope&& from) noexcept
    : PivotPeerEnvelope() {
    *this = ::std::move(from);
  }

  inline PivotPeerEnvelope& operator=(const PivotPeerEnvelope& from) {
    CopyFrom(from);
    return *this;
  }
  inline PivotPeerEnvelope& operator=(PivotPeerEnvelope&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PivotPeerEnvelope& default_instance() {
    return *internal_default_instance();
  }
  static inline const PivotPeerEnvelope* internal_default_instance() {
    return reinterpret_cast<const PivotPeerEnvelope*>(
               &_PivotPeerEnvelope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(PivotPeerEnvelope& a, PivotPeerEnvelope& b) {
    a.Swap(&b);
  }
  inline void Swap(PivotPeerEnvelope* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PivotPeerEnvelope* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PivotPeerEnvelope* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PivotPeerEnvelope>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PivotPeerEnvelope& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PivotPeerEnvelope& from) {
    PivotPeerEnvelope::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PivotPeerEnvelope* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.PivotPeerEnvelope";
  }
  protected:
  explicit PivotPeerEnvelope(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 1,
    kPivotSessionIDFieldNumber = 3,
    kDataFieldNumber = 4,
    kPeerFailureAtFieldNumber = 5,
    kTypeFieldNumber = 2,
  };
  // repeated .sliverpb.PivotPeer Peers = 1;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  ::sliverpb::PivotPeer* mutable_peers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::PivotPeer >*
      mutable_peers();
  private:
  const ::sliverpb::PivotPeer& _internal_peers(int index) const;
  ::sliverpb::PivotPeer* _internal_add_peers();
  public:
  const ::sliverpb::PivotPeer& peers(int index) const;
  ::sliverpb::PivotPeer* add_peers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::PivotPeer >&
      peers() const;

  // bytes PivotSessionID = 3;
  void clear_pivotsessionid();
  const std::string& pivotsessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pivotsessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pivotsessionid();
  PROTOBUF_NODISCARD std::string* release_pivotsessionid();
  void set_allocated_pivotsessionid(std::string* pivotsessionid);
  private:
  const std::string& _internal_pivotsessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pivotsessionid(const std::string& value);
  std::string* _internal_mutable_pivotsessionid();
  public:

  // bytes Data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int64 PeerFailureAt = 5;
  void clear_peerfailureat();
  int64_t peerfailureat() const;
  void set_peerfailureat(int64_t value);
  private:
  int64_t _internal_peerfailureat() const;
  void _internal_set_peerfailureat(int64_t value);
  public:

  // uint32 Type = 2;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.PivotPeerEnvelope)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::PivotPeer > peers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pivotsessionid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int64_t peerfailureat_;
    uint32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class PivotPing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.PivotPing) */ {
 public:
  inline PivotPing() : PivotPing(nullptr) {}
  ~PivotPing() override;
  explicit PROTOBUF_CONSTEXPR PivotPing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PivotPing(const PivotPing& from);
  PivotPing(PivotPing&& from) noexcept
    : PivotPing() {
    *this = ::std::move(from);
  }

  inline PivotPing& operator=(const PivotPing& from) {
    CopyFrom(from);
    return *this;
  }
  inline PivotPing& operator=(PivotPing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PivotPing& default_instance() {
    return *internal_default_instance();
  }
  static inline const PivotPing* internal_default_instance() {
    return reinterpret_cast<const PivotPing*>(
               &_PivotPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(PivotPing& a, PivotPing& b) {
    a.Swap(&b);
  }
  inline void Swap(PivotPing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PivotPing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PivotPing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PivotPing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PivotPing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PivotPing& from) {
    PivotPing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PivotPing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.PivotPing";
  }
  protected:
  explicit PivotPing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
  };
  // uint32 Nonce = 1;
  void clear_nonce();
  uint32_t nonce() const;
  void set_nonce(uint32_t value);
  private:
  uint32_t _internal_nonce() const;
  void _internal_set_nonce(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.PivotPing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class NetConnPivot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.NetConnPivot) */ {
 public:
  inline NetConnPivot() : NetConnPivot(nullptr) {}
  ~NetConnPivot() override;
  explicit PROTOBUF_CONSTEXPR NetConnPivot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetConnPivot(const NetConnPivot& from);
  NetConnPivot(NetConnPivot&& from) noexcept
    : NetConnPivot() {
    *this = ::std::move(from);
  }

  inline NetConnPivot& operator=(const NetConnPivot& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetConnPivot& operator=(NetConnPivot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetConnPivot& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetConnPivot* internal_default_instance() {
    return reinterpret_cast<const NetConnPivot*>(
               &_NetConnPivot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(NetConnPivot& a, NetConnPivot& b) {
    a.Swap(&b);
  }
  inline void Swap(NetConnPivot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetConnPivot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetConnPivot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetConnPivot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetConnPivot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetConnPivot& from) {
    NetConnPivot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetConnPivot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.NetConnPivot";
  }
  protected:
  explicit NetConnPivot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteAddressFieldNumber = 2,
    kPeerIDFieldNumber = 1,
  };
  // string RemoteAddress = 2;
  void clear_remoteaddress();
  const std::string& remoteaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remoteaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remoteaddress();
  PROTOBUF_NODISCARD std::string* release_remoteaddress();
  void set_allocated_remoteaddress(std::string* remoteaddress);
  private:
  const std::string& _internal_remoteaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remoteaddress(const std::string& value);
  std::string* _internal_mutable_remoteaddress();
  public:

  // int64 PeerID = 1 [jstype = JS_STRING];
  void clear_peerid();
  int64_t peerid() const;
  void set_peerid(int64_t value);
  private:
  int64_t _internal_peerid() const;
  void _internal_set_peerid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.NetConnPivot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remoteaddress_;
    int64_t peerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class PivotPeerFailure final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.PivotPeerFailure) */ {
 public:
  inline PivotPeerFailure() : PivotPeerFailure(nullptr) {}
  ~PivotPeerFailure() override;
  explicit PROTOBUF_CONSTEXPR PivotPeerFailure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PivotPeerFailure(const PivotPeerFailure& from);
  PivotPeerFailure(PivotPeerFailure&& from) noexcept
    : PivotPeerFailure() {
    *this = ::std::move(from);
  }

  inline PivotPeerFailure& operator=(const PivotPeerFailure& from) {
    CopyFrom(from);
    return *this;
  }
  inline PivotPeerFailure& operator=(PivotPeerFailure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PivotPeerFailure& default_instance() {
    return *internal_default_instance();
  }
  static inline const PivotPeerFailure* internal_default_instance() {
    return reinterpret_cast<const PivotPeerFailure*>(
               &_PivotPeerFailure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(PivotPeerFailure& a, PivotPeerFailure& b) {
    a.Swap(&b);
  }
  inline void Swap(PivotPeerFailure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PivotPeerFailure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PivotPeerFailure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PivotPeerFailure>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PivotPeerFailure& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PivotPeerFailure& from) {
    PivotPeerFailure::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PivotPeerFailure* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.PivotPeerFailure";
  }
  protected:
  explicit PivotPeerFailure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 3,
    kPeerIDFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string Err = 3;
  void clear_err();
  const std::string& err() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err();
  PROTOBUF_NODISCARD std::string* release_err();
  void set_allocated_err(std::string* err);
  private:
  const std::string& _internal_err() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err(const std::string& value);
  std::string* _internal_mutable_err();
  public:

  // int64 PeerID = 1 [jstype = JS_STRING];
  void clear_peerid();
  int64_t peerid() const;
  void set_peerid(int64_t value);
  private:
  int64_t _internal_peerid() const;
  void _internal_set_peerid(int64_t value);
  public:

  // .sliverpb.PeerFailureType Type = 2;
  void clear_type();
  ::sliverpb::PeerFailureType type() const;
  void set_type(::sliverpb::PeerFailureType value);
  private:
  ::sliverpb::PeerFailureType _internal_type() const;
  void _internal_set_type(::sliverpb::PeerFailureType value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.PivotPeerFailure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_;
    int64_t peerid_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class PivotListenersReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.PivotListenersReq) */ {
 public:
  inline PivotListenersReq() : PivotListenersReq(nullptr) {}
  ~PivotListenersReq() override;
  explicit PROTOBUF_CONSTEXPR PivotListenersReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PivotListenersReq(const PivotListenersReq& from);
  PivotListenersReq(PivotListenersReq&& from) noexcept
    : PivotListenersReq() {
    *this = ::std::move(from);
  }

  inline PivotListenersReq& operator=(const PivotListenersReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PivotListenersReq& operator=(PivotListenersReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PivotListenersReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PivotListenersReq* internal_default_instance() {
    return reinterpret_cast<const PivotListenersReq*>(
               &_PivotListenersReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(PivotListenersReq& a, PivotListenersReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PivotListenersReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PivotListenersReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PivotListenersReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PivotListenersReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PivotListenersReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PivotListenersReq& from) {
    PivotListenersReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PivotListenersReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.PivotListenersReq";
  }
  protected:
  explicit PivotListenersReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.PivotListenersReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class PivotListeners final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.PivotListeners) */ {
 public:
  inline PivotListeners() : PivotListeners(nullptr) {}
  ~PivotListeners() override;
  explicit PROTOBUF_CONSTEXPR PivotListeners(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PivotListeners(const PivotListeners& from);
  PivotListeners(PivotListeners&& from) noexcept
    : PivotListeners() {
    *this = ::std::move(from);
  }

  inline PivotListeners& operator=(const PivotListeners& from) {
    CopyFrom(from);
    return *this;
  }
  inline PivotListeners& operator=(PivotListeners&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PivotListeners& default_instance() {
    return *internal_default_instance();
  }
  static inline const PivotListeners* internal_default_instance() {
    return reinterpret_cast<const PivotListeners*>(
               &_PivotListeners_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(PivotListeners& a, PivotListeners& b) {
    a.Swap(&b);
  }
  inline void Swap(PivotListeners* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PivotListeners* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PivotListeners* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PivotListeners>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PivotListeners& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PivotListeners& from) {
    PivotListeners::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PivotListeners* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.PivotListeners";
  }
  protected:
  explicit PivotListeners(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListenersFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // repeated .sliverpb.PivotListener Listeners = 1;
  int listeners_size() const;
  private:
  int _internal_listeners_size() const;
  public:
  void clear_listeners();
  ::sliverpb::PivotListener* mutable_listeners(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::PivotListener >*
      mutable_listeners();
  private:
  const ::sliverpb::PivotListener& _internal_listeners(int index) const;
  ::sliverpb::PivotListener* _internal_add_listeners();
  public:
  const ::sliverpb::PivotListener& listeners(int index) const;
  ::sliverpb::PivotListener* add_listeners();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::PivotListener >&
      listeners() const;

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.PivotListeners)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::PivotListener > listeners_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class WGPortForwardStartReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.WGPortForwardStartReq) */ {
 public:
  inline WGPortForwardStartReq() : WGPortForwardStartReq(nullptr) {}
  ~WGPortForwardStartReq() override;
  explicit PROTOBUF_CONSTEXPR WGPortForwardStartReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WGPortForwardStartReq(const WGPortForwardStartReq& from);
  WGPortForwardStartReq(WGPortForwardStartReq&& from) noexcept
    : WGPortForwardStartReq() {
    *this = ::std::move(from);
  }

  inline WGPortForwardStartReq& operator=(const WGPortForwardStartReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline WGPortForwardStartReq& operator=(WGPortForwardStartReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WGPortForwardStartReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const WGPortForwardStartReq* internal_default_instance() {
    return reinterpret_cast<const WGPortForwardStartReq*>(
               &_WGPortForwardStartReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(WGPortForwardStartReq& a, WGPortForwardStartReq& b) {
    a.Swap(&b);
  }
  inline void Swap(WGPortForwardStartReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WGPortForwardStartReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WGPortForwardStartReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WGPortForwardStartReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WGPortForwardStartReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WGPortForwardStartReq& from) {
    WGPortForwardStartReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WGPortForwardStartReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.WGPortForwardStartReq";
  }
  protected:
  explicit WGPortForwardStartReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteAddressFieldNumber = 2,
    kRequestFieldNumber = 9,
    kLocalPortFieldNumber = 1,
  };
  // string RemoteAddress = 2;
  void clear_remoteaddress();
  const std::string& remoteaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remoteaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remoteaddress();
  PROTOBUF_NODISCARD std::string* release_remoteaddress();
  void set_allocated_remoteaddress(std::string* remoteaddress);
  private:
  const std::string& _internal_remoteaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remoteaddress(const std::string& value);
  std::string* _internal_mutable_remoteaddress();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // int32 LocalPort = 1;
  void clear_localport();
  int32_t localport() const;
  void set_localport(int32_t value);
  private:
  int32_t _internal_localport() const;
  void _internal_set_localport(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.WGPortForwardStartReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remoteaddress_;
    ::sliverpb::Request* request_;
    int32_t localport_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class WGPortForward final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.WGPortForward) */ {
 public:
  inline WGPortForward() : WGPortForward(nullptr) {}
  ~WGPortForward() override;
  explicit PROTOBUF_CONSTEXPR WGPortForward(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WGPortForward(const WGPortForward& from);
  WGPortForward(WGPortForward&& from) noexcept
    : WGPortForward() {
    *this = ::std::move(from);
  }

  inline WGPortForward& operator=(const WGPortForward& from) {
    CopyFrom(from);
    return *this;
  }
  inline WGPortForward& operator=(WGPortForward&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WGPortForward& default_instance() {
    return *internal_default_instance();
  }
  static inline const WGPortForward* internal_default_instance() {
    return reinterpret_cast<const WGPortForward*>(
               &_WGPortForward_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(WGPortForward& a, WGPortForward& b) {
    a.Swap(&b);
  }
  inline void Swap(WGPortForward* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WGPortForward* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WGPortForward* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WGPortForward>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WGPortForward& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WGPortForward& from) {
    WGPortForward::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WGPortForward* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.WGPortForward";
  }
  protected:
  explicit WGPortForward(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kForwarderFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // .sliverpb.WGTCPForwarder Forwarder = 1;
  bool has_forwarder() const;
  private:
  bool _internal_has_forwarder() const;
  public:
  void clear_forwarder();
  const ::sliverpb::WGTCPForwarder& forwarder() const;
  PROTOBUF_NODISCARD ::sliverpb::WGTCPForwarder* release_forwarder();
  ::sliverpb::WGTCPForwarder* mutable_forwarder();
  void set_allocated_forwarder(::sliverpb::WGTCPForwarder* forwarder);
  private:
  const ::sliverpb::WGTCPForwarder& _internal_forwarder() const;
  ::sliverpb::WGTCPForwarder* _internal_mutable_forwarder();
  public:
  void unsafe_arena_set_allocated_forwarder(
      ::sliverpb::WGTCPForwarder* forwarder);
  ::sliverpb::WGTCPForwarder* unsafe_arena_release_forwarder();

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.WGPortForward)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::WGTCPForwarder* forwarder_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class WGPortForwardStopReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.WGPortForwardStopReq) */ {
 public:
  inline WGPortForwardStopReq() : WGPortForwardStopReq(nullptr) {}
  ~WGPortForwardStopReq() override;
  explicit PROTOBUF_CONSTEXPR WGPortForwardStopReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WGPortForwardStopReq(const WGPortForwardStopReq& from);
  WGPortForwardStopReq(WGPortForwardStopReq&& from) noexcept
    : WGPortForwardStopReq() {
    *this = ::std::move(from);
  }

  inline WGPortForwardStopReq& operator=(const WGPortForwardStopReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline WGPortForwardStopReq& operator=(WGPortForwardStopReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WGPortForwardStopReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const WGPortForwardStopReq* internal_default_instance() {
    return reinterpret_cast<const WGPortForwardStopReq*>(
               &_WGPortForwardStopReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(WGPortForwardStopReq& a, WGPortForwardStopReq& b) {
    a.Swap(&b);
  }
  inline void Swap(WGPortForwardStopReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WGPortForwardStopReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WGPortForwardStopReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WGPortForwardStopReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WGPortForwardStopReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WGPortForwardStopReq& from) {
    WGPortForwardStopReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WGPortForwardStopReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.WGPortForwardStopReq";
  }
  protected:
  explicit WGPortForwardStopReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
    kIDFieldNumber = 1,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // int32 ID = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.WGPortForwardStopReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class WGSocksStartReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.WGSocksStartReq) */ {
 public:
  inline WGSocksStartReq() : WGSocksStartReq(nullptr) {}
  ~WGSocksStartReq() override;
  explicit PROTOBUF_CONSTEXPR WGSocksStartReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WGSocksStartReq(const WGSocksStartReq& from);
  WGSocksStartReq(WGSocksStartReq&& from) noexcept
    : WGSocksStartReq() {
    *this = ::std::move(from);
  }

  inline WGSocksStartReq& operator=(const WGSocksStartReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline WGSocksStartReq& operator=(WGSocksStartReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WGSocksStartReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const WGSocksStartReq* internal_default_instance() {
    return reinterpret_cast<const WGSocksStartReq*>(
               &_WGSocksStartReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(WGSocksStartReq& a, WGSocksStartReq& b) {
    a.Swap(&b);
  }
  inline void Swap(WGSocksStartReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WGSocksStartReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WGSocksStartReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WGSocksStartReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WGSocksStartReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WGSocksStartReq& from) {
    WGSocksStartReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WGSocksStartReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.WGSocksStartReq";
  }
  protected:
  explicit WGSocksStartReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
    kPortFieldNumber = 1,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // int32 Port = 1;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.WGSocksStartReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    int32_t port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class WGSocks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.WGSocks) */ {
 public:
  inline WGSocks() : WGSocks(nullptr) {}
  ~WGSocks() override;
  explicit PROTOBUF_CONSTEXPR WGSocks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WGSocks(const WGSocks& from);
  WGSocks(WGSocks&& from) noexcept
    : WGSocks() {
    *this = ::std::move(from);
  }

  inline WGSocks& operator=(const WGSocks& from) {
    CopyFrom(from);
    return *this;
  }
  inline WGSocks& operator=(WGSocks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WGSocks& default_instance() {
    return *internal_default_instance();
  }
  static inline const WGSocks* internal_default_instance() {
    return reinterpret_cast<const WGSocks*>(
               &_WGSocks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  friend void swap(WGSocks& a, WGSocks& b) {
    a.Swap(&b);
  }
  inline void Swap(WGSocks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WGSocks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WGSocks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WGSocks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WGSocks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WGSocks& from) {
    WGSocks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WGSocks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.WGSocks";
  }
  protected:
  explicit WGSocks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // .sliverpb.WGSocksServer Server = 1;
  bool has_server() const;
  private:
  bool _internal_has_server() const;
  public:
  void clear_server();
  const ::sliverpb::WGSocksServer& server() const;
  PROTOBUF_NODISCARD ::sliverpb::WGSocksServer* release_server();
  ::sliverpb::WGSocksServer* mutable_server();
  void set_allocated_server(::sliverpb::WGSocksServer* server);
  private:
  const ::sliverpb::WGSocksServer& _internal_server() const;
  ::sliverpb::WGSocksServer* _internal_mutable_server();
  public:
  void unsafe_arena_set_allocated_server(
      ::sliverpb::WGSocksServer* server);
  ::sliverpb::WGSocksServer* unsafe_arena_release_server();

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.WGSocks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::WGSocksServer* server_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class WGSocksStopReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.WGSocksStopReq) */ {
 public:
  inline WGSocksStopReq() : WGSocksStopReq(nullptr) {}
  ~WGSocksStopReq() override;
  explicit PROTOBUF_CONSTEXPR WGSocksStopReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WGSocksStopReq(const WGSocksStopReq& from);
  WGSocksStopReq(WGSocksStopReq&& from) noexcept
    : WGSocksStopReq() {
    *this = ::std::move(from);
  }

  inline WGSocksStopReq& operator=(const WGSocksStopReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline WGSocksStopReq& operator=(WGSocksStopReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WGSocksStopReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const WGSocksStopReq* internal_default_instance() {
    return reinterpret_cast<const WGSocksStopReq*>(
               &_WGSocksStopReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    125;

  friend void swap(WGSocksStopReq& a, WGSocksStopReq& b) {
    a.Swap(&b);
  }
  inline void Swap(WGSocksStopReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WGSocksStopReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WGSocksStopReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WGSocksStopReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WGSocksStopReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WGSocksStopReq& from) {
    WGSocksStopReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WGSocksStopReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.WGSocksStopReq";
  }
  protected:
  explicit WGSocksStopReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
    kIDFieldNumber = 1,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // int32 ID = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.WGSocksStopReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class WGTCPForwardersReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.WGTCPForwardersReq) */ {
 public:
  inline WGTCPForwardersReq() : WGTCPForwardersReq(nullptr) {}
  ~WGTCPForwardersReq() override;
  explicit PROTOBUF_CONSTEXPR WGTCPForwardersReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WGTCPForwardersReq(const WGTCPForwardersReq& from);
  WGTCPForwardersReq(WGTCPForwardersReq&& from) noexcept
    : WGTCPForwardersReq() {
    *this = ::std::move(from);
  }

  inline WGTCPForwardersReq& operator=(const WGTCPForwardersReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline WGTCPForwardersReq& operator=(WGTCPForwardersReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WGTCPForwardersReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const WGTCPForwardersReq* internal_default_instance() {
    return reinterpret_cast<const WGTCPForwardersReq*>(
               &_WGTCPForwardersReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    126;

  friend void swap(WGTCPForwardersReq& a, WGTCPForwardersReq& b) {
    a.Swap(&b);
  }
  inline void Swap(WGTCPForwardersReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WGTCPForwardersReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WGTCPForwardersReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WGTCPForwardersReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WGTCPForwardersReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WGTCPForwardersReq& from) {
    WGTCPForwardersReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WGTCPForwardersReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.WGTCPForwardersReq";
  }
  protected:
  explicit WGTCPForwardersReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.WGTCPForwardersReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class WGSocksServersReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.WGSocksServersReq) */ {
 public:
  inline WGSocksServersReq() : WGSocksServersReq(nullptr) {}
  ~WGSocksServersReq() override;
  explicit PROTOBUF_CONSTEXPR WGSocksServersReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WGSocksServersReq(const WGSocksServersReq& from);
  WGSocksServersReq(WGSocksServersReq&& from) noexcept
    : WGSocksServersReq() {
    *this = ::std::move(from);
  }

  inline WGSocksServersReq& operator=(const WGSocksServersReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline WGSocksServersReq& operator=(WGSocksServersReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WGSocksServersReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const WGSocksServersReq* internal_default_instance() {
    return reinterpret_cast<const WGSocksServersReq*>(
               &_WGSocksServersReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    127;

  friend void swap(WGSocksServersReq& a, WGSocksServersReq& b) {
    a.Swap(&b);
  }
  inline void Swap(WGSocksServersReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WGSocksServersReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WGSocksServersReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WGSocksServersReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WGSocksServersReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WGSocksServersReq& from) {
    WGSocksServersReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WGSocksServersReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.WGSocksServersReq";
  }
  protected:
  explicit WGSocksServersReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.WGSocksServersReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class WGTCPForwarder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.WGTCPForwarder) */ {
 public:
  inline WGTCPForwarder() : WGTCPForwarder(nullptr) {}
  ~WGTCPForwarder() override;
  explicit PROTOBUF_CONSTEXPR WGTCPForwarder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WGTCPForwarder(const WGTCPForwarder& from);
  WGTCPForwarder(WGTCPForwarder&& from) noexcept
    : WGTCPForwarder() {
    *this = ::std::move(from);
  }

  inline WGTCPForwarder& operator=(const WGTCPForwarder& from) {
    CopyFrom(from);
    return *this;
  }
  inline WGTCPForwarder& operator=(WGTCPForwarder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WGTCPForwarder& default_instance() {
    return *internal_default_instance();
  }
  static inline const WGTCPForwarder* internal_default_instance() {
    return reinterpret_cast<const WGTCPForwarder*>(
               &_WGTCPForwarder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    128;

  friend void swap(WGTCPForwarder& a, WGTCPForwarder& b) {
    a.Swap(&b);
  }
  inline void Swap(WGTCPForwarder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WGTCPForwarder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WGTCPForwarder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WGTCPForwarder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WGTCPForwarder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WGTCPForwarder& from) {
    WGTCPForwarder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WGTCPForwarder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.WGTCPForwarder";
  }
  protected:
  explicit WGTCPForwarder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalAddrFieldNumber = 2,
    kRemoteAddrFieldNumber = 3,
    kIDFieldNumber = 1,
  };
  // string LocalAddr = 2;
  void clear_localaddr();
  const std::string& localaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_localaddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_localaddr();
  PROTOBUF_NODISCARD std::string* release_localaddr();
  void set_allocated_localaddr(std::string* localaddr);
  private:
  const std::string& _internal_localaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_localaddr(const std::string& value);
  std::string* _internal_mutable_localaddr();
  public:

  // string RemoteAddr = 3;
  void clear_remoteaddr();
  const std::string& remoteaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remoteaddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remoteaddr();
  PROTOBUF_NODISCARD std::string* release_remoteaddr();
  void set_allocated_remoteaddr(std::string* remoteaddr);
  private:
  const std::string& _internal_remoteaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remoteaddr(const std::string& value);
  std::string* _internal_mutable_remoteaddr();
  public:

  // int32 ID = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.WGTCPForwarder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr localaddr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remoteaddr_;
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class WGSocksServer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.WGSocksServer) */ {
 public:
  inline WGSocksServer() : WGSocksServer(nullptr) {}
  ~WGSocksServer() override;
  explicit PROTOBUF_CONSTEXPR WGSocksServer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WGSocksServer(const WGSocksServer& from);
  WGSocksServer(WGSocksServer&& from) noexcept
    : WGSocksServer() {
    *this = ::std::move(from);
  }

  inline WGSocksServer& operator=(const WGSocksServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline WGSocksServer& operator=(WGSocksServer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WGSocksServer& default_instance() {
    return *internal_default_instance();
  }
  static inline const WGSocksServer* internal_default_instance() {
    return reinterpret_cast<const WGSocksServer*>(
               &_WGSocksServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    129;

  friend void swap(WGSocksServer& a, WGSocksServer& b) {
    a.Swap(&b);
  }
  inline void Swap(WGSocksServer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WGSocksServer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WGSocksServer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WGSocksServer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WGSocksServer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WGSocksServer& from) {
    WGSocksServer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WGSocksServer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.WGSocksServer";
  }
  protected:
  explicit WGSocksServer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalAddrFieldNumber = 2,
    kIDFieldNumber = 1,
  };
  // string LocalAddr = 2;
  void clear_localaddr();
  const std::string& localaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_localaddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_localaddr();
  PROTOBUF_NODISCARD std::string* release_localaddr();
  void set_allocated_localaddr(std::string* localaddr);
  private:
  const std::string& _internal_localaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_localaddr(const std::string& value);
  std::string* _internal_mutable_localaddr();
  public:

  // int32 ID = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.WGSocksServer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr localaddr_;
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class WGSocksServers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.WGSocksServers) */ {
 public:
  inline WGSocksServers() : WGSocksServers(nullptr) {}
  ~WGSocksServers() override;
  explicit PROTOBUF_CONSTEXPR WGSocksServers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WGSocksServers(const WGSocksServers& from);
  WGSocksServers(WGSocksServers&& from) noexcept
    : WGSocksServers() {
    *this = ::std::move(from);
  }

  inline WGSocksServers& operator=(const WGSocksServers& from) {
    CopyFrom(from);
    return *this;
  }
  inline WGSocksServers& operator=(WGSocksServers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WGSocksServers& default_instance() {
    return *internal_default_instance();
  }
  static inline const WGSocksServers* internal_default_instance() {
    return reinterpret_cast<const WGSocksServers*>(
               &_WGSocksServers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    130;

  friend void swap(WGSocksServers& a, WGSocksServers& b) {
    a.Swap(&b);
  }
  inline void Swap(WGSocksServers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WGSocksServers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WGSocksServers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WGSocksServers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WGSocksServers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WGSocksServers& from) {
    WGSocksServers::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WGSocksServers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.WGSocksServers";
  }
  protected:
  explicit WGSocksServers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServersFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // repeated .sliverpb.WGSocksServer Servers = 1;
  int servers_size() const;
  private:
  int _internal_servers_size() const;
  public:
  void clear_servers();
  ::sliverpb::WGSocksServer* mutable_servers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::WGSocksServer >*
      mutable_servers();
  private:
  const ::sliverpb::WGSocksServer& _internal_servers(int index) const;
  ::sliverpb::WGSocksServer* _internal_add_servers();
  public:
  const ::sliverpb::WGSocksServer& servers(int index) const;
  ::sliverpb::WGSocksServer* add_servers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::WGSocksServer >&
      servers() const;

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.WGSocksServers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::WGSocksServer > servers_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class WGTCPForwarders final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.WGTCPForwarders) */ {
 public:
  inline WGTCPForwarders() : WGTCPForwarders(nullptr) {}
  ~WGTCPForwarders() override;
  explicit PROTOBUF_CONSTEXPR WGTCPForwarders(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WGTCPForwarders(const WGTCPForwarders& from);
  WGTCPForwarders(WGTCPForwarders&& from) noexcept
    : WGTCPForwarders() {
    *this = ::std::move(from);
  }

  inline WGTCPForwarders& operator=(const WGTCPForwarders& from) {
    CopyFrom(from);
    return *this;
  }
  inline WGTCPForwarders& operator=(WGTCPForwarders&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WGTCPForwarders& default_instance() {
    return *internal_default_instance();
  }
  static inline const WGTCPForwarders* internal_default_instance() {
    return reinterpret_cast<const WGTCPForwarders*>(
               &_WGTCPForwarders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    131;

  friend void swap(WGTCPForwarders& a, WGTCPForwarders& b) {
    a.Swap(&b);
  }
  inline void Swap(WGTCPForwarders* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WGTCPForwarders* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WGTCPForwarders* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WGTCPForwarders>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WGTCPForwarders& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WGTCPForwarders& from) {
    WGTCPForwarders::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WGTCPForwarders* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.WGTCPForwarders";
  }
  protected:
  explicit WGTCPForwarders(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kForwardersFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // repeated .sliverpb.WGTCPForwarder Forwarders = 1;
  int forwarders_size() const;
  private:
  int _internal_forwarders_size() const;
  public:
  void clear_forwarders();
  ::sliverpb::WGTCPForwarder* mutable_forwarders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::WGTCPForwarder >*
      mutable_forwarders();
  private:
  const ::sliverpb::WGTCPForwarder& _internal_forwarders(int index) const;
  ::sliverpb::WGTCPForwarder* _internal_add_forwarders();
  public:
  const ::sliverpb::WGTCPForwarder& forwarders(int index) const;
  ::sliverpb::WGTCPForwarder* add_forwarders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::WGTCPForwarder >&
      forwarders() const;

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.WGTCPForwarders)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::WGTCPForwarder > forwarders_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class ReconfigureReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.ReconfigureReq) */ {
 public:
  inline ReconfigureReq() : ReconfigureReq(nullptr) {}
  ~ReconfigureReq() override;
  explicit PROTOBUF_CONSTEXPR ReconfigureReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReconfigureReq(const ReconfigureReq& from);
  ReconfigureReq(ReconfigureReq&& from) noexcept
    : ReconfigureReq() {
    *this = ::std::move(from);
  }

  inline ReconfigureReq& operator=(const ReconfigureReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReconfigureReq& operator=(ReconfigureReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReconfigureReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReconfigureReq* internal_default_instance() {
    return reinterpret_cast<const ReconfigureReq*>(
               &_ReconfigureReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    132;

  friend void swap(ReconfigureReq& a, ReconfigureReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ReconfigureReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReconfigureReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReconfigureReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReconfigureReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReconfigureReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReconfigureReq& from) {
    ReconfigureReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReconfigureReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.ReconfigureReq";
  }
  protected:
  explicit ReconfigureReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
    kReconnectIntervalFieldNumber = 1,
    kBeaconIntervalFieldNumber = 2,
    kBeaconJitterFieldNumber = 3,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // int64 ReconnectInterval = 1;
  void clear_reconnectinterval();
  int64_t reconnectinterval() const;
  void set_reconnectinterval(int64_t value);
  private:
  int64_t _internal_reconnectinterval() const;
  void _internal_set_reconnectinterval(int64_t value);
  public:

  // int64 BeaconInterval = 2;
  void clear_beaconinterval();
  int64_t beaconinterval() const;
  void set_beaconinterval(int64_t value);
  private:
  int64_t _internal_beaconinterval() const;
  void _internal_set_beaconinterval(int64_t value);
  public:

  // int64 BeaconJitter = 3;
  void clear_beaconjitter();
  int64_t beaconjitter() const;
  void set_beaconjitter(int64_t value);
  private:
  int64_t _internal_beaconjitter() const;
  void _internal_set_beaconjitter(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.ReconfigureReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    int64_t reconnectinterval_;
    int64_t beaconinterval_;
    int64_t beaconjitter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class Reconfigure final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Reconfigure) */ {
 public:
  inline Reconfigure() : Reconfigure(nullptr) {}
  ~Reconfigure() override;
  explicit PROTOBUF_CONSTEXPR Reconfigure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Reconfigure(const Reconfigure& from);
  Reconfigure(Reconfigure&& from) noexcept
    : Reconfigure() {
    *this = ::std::move(from);
  }

  inline Reconfigure& operator=(const Reconfigure& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reconfigure& operator=(Reconfigure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reconfigure& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reconfigure* internal_default_instance() {
    return reinterpret_cast<const Reconfigure*>(
               &_Reconfigure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    133;

  friend void swap(Reconfigure& a, Reconfigure& b) {
    a.Swap(&b);
  }
  inline void Swap(Reconfigure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reconfigure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reconfigure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Reconfigure>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Reconfigure& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Reconfigure& from) {
    Reconfigure::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reconfigure* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Reconfigure";
  }
  protected:
  explicit Reconfigure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 9,
  };
  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.Reconfigure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class PollIntervalReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.PollIntervalReq) */ {
 public:
  inline PollIntervalReq() : PollIntervalReq(nullptr) {}
  ~PollIntervalReq() override;
  explicit PROTOBUF_CONSTEXPR PollIntervalReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PollIntervalReq(const PollIntervalReq& from);
  PollIntervalReq(PollIntervalReq&& from) noexcept
    : PollIntervalReq() {
    *this = ::std::move(from);
  }

  inline PollIntervalReq& operator=(const PollIntervalReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PollIntervalReq& operator=(PollIntervalReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PollIntervalReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PollIntervalReq* internal_default_instance() {
    return reinterpret_cast<const PollIntervalReq*>(
               &_PollIntervalReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    134;

  friend void swap(PollIntervalReq& a, PollIntervalReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PollIntervalReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PollIntervalReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PollIntervalReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PollIntervalReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PollIntervalReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PollIntervalReq& from) {
    PollIntervalReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PollIntervalReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.PollIntervalReq";
  }
  protected:
  explicit PollIntervalReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
    kPollIntervalFieldNumber = 1,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // int64 PollInterval = 1;
  void clear_pollinterval();
  int64_t pollinterval() const;
  void set_pollinterval(int64_t value);
  private:
  int64_t _internal_pollinterval() const;
  void _internal_set_pollinterval(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.PollIntervalReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    int64_t pollinterval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class PollInterval final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.PollInterval) */ {
 public:
  inline PollInterval() : PollInterval(nullptr) {}
  ~PollInterval() override;
  explicit PROTOBUF_CONSTEXPR PollInterval(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PollInterval(const PollInterval& from);
  PollInterval(PollInterval&& from) noexcept
    : PollInterval() {
    *this = ::std::move(from);
  }

  inline PollInterval& operator=(const PollInterval& from) {
    CopyFrom(from);
    return *this;
  }
  inline PollInterval& operator=(PollInterval&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PollInterval& default_instance() {
    return *internal_default_instance();
  }
  static inline const PollInterval* internal_default_instance() {
    return reinterpret_cast<const PollInterval*>(
               &_PollInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    135;

  friend void swap(PollInterval& a, PollInterval& b) {
    a.Swap(&b);
  }
  inline void Swap(PollInterval* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PollInterval* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PollInterval* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PollInterval>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PollInterval& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PollInterval& from) {
    PollInterval::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PollInterval* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.PollInterval";
  }
  protected:
  explicit PollInterval(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 9,
  };
  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.PollInterval)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class SSHCommandReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.SSHCommandReq) */ {
 public:
  inline SSHCommandReq() : SSHCommandReq(nullptr) {}
  ~SSHCommandReq() override;
  explicit PROTOBUF_CONSTEXPR SSHCommandReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SSHCommandReq(const SSHCommandReq& from);
  SSHCommandReq(SSHCommandReq&& from) noexcept
    : SSHCommandReq() {
    *this = ::std::move(from);
  }

  inline SSHCommandReq& operator=(const SSHCommandReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SSHCommandReq& operator=(SSHCommandReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SSHCommandReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SSHCommandReq* internal_default_instance() {
    return reinterpret_cast<const SSHCommandReq*>(
               &_SSHCommandReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    136;

  friend void swap(SSHCommandReq& a, SSHCommandReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SSHCommandReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SSHCommandReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SSHCommandReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SSHCommandReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SSHCommandReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SSHCommandReq& from) {
    SSHCommandReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SSHCommandReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.SSHCommandReq";
  }
  protected:
  explicit SSHCommandReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kHostnameFieldNumber = 2,
    kCommandFieldNumber = 4,
    kPasswordFieldNumber = 5,
    kPrivKeyFieldNumber = 6,
    kKrb5ConfFieldNumber = 7,
    kKeytabFieldNumber = 8,
    kRealmFieldNumber = 10,
    kRequestFieldNumber = 9,
    kPortFieldNumber = 3,
  };
  // string Username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string Hostname = 2;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // string Command = 4;
  void clear_command();
  const std::string& command() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_command(ArgT0&& arg0, ArgT... args);
  std::string* mutable_command();
  PROTOBUF_NODISCARD std::string* release_command();
  void set_allocated_command(std::string* command);
  private:
  const std::string& _internal_command() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_command(const std::string& value);
  std::string* _internal_mutable_command();
  public:

  // string Password = 5;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // bytes PrivKey = 6;
  void clear_privkey();
  const std::string& privkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_privkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_privkey();
  PROTOBUF_NODISCARD std::string* release_privkey();
  void set_allocated_privkey(std::string* privkey);
  private:
  const std::string& _internal_privkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_privkey(const std::string& value);
  std::string* _internal_mutable_privkey();
  public:

  // string Krb5Conf = 7;
  void clear_krb5conf();
  const std::string& krb5conf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_krb5conf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_krb5conf();
  PROTOBUF_NODISCARD std::string* release_krb5conf();
  void set_allocated_krb5conf(std::string* krb5conf);
  private:
  const std::string& _internal_krb5conf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_krb5conf(const std::string& value);
  std::string* _internal_mutable_krb5conf();
  public:

  // bytes Keytab = 8;
  void clear_keytab();
  const std::string& keytab() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keytab(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keytab();
  PROTOBUF_NODISCARD std::string* release_keytab();
  void set_allocated_keytab(std::string* keytab);
  private:
  const std::string& _internal_keytab() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keytab(const std::string& value);
  std::string* _internal_mutable_keytab();
  public:

  // string Realm = 10;
  void clear_realm();
  const std::string& realm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_realm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_realm();
  PROTOBUF_NODISCARD std::string* release_realm();
  void set_allocated_realm(std::string* realm);
  private:
  const std::string& _internal_realm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realm(const std::string& value);
  std::string* _internal_mutable_realm();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // uint32 Port = 3;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.SSHCommandReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr privkey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr krb5conf_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keytab_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr realm_;
    ::sliverpb::Request* request_;
    uint32_t port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class SSHCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.SSHCommand) */ {
 public:
  inline SSHCommand() : SSHCommand(nullptr) {}
  ~SSHCommand() override;
  explicit PROTOBUF_CONSTEXPR SSHCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SSHCommand(const SSHCommand& from);
  SSHCommand(SSHCommand&& from) noexcept
    : SSHCommand() {
    *this = ::std::move(from);
  }

  inline SSHCommand& operator=(const SSHCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SSHCommand& operator=(SSHCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SSHCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const SSHCommand* internal_default_instance() {
    return reinterpret_cast<const SSHCommand*>(
               &_SSHCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    137;

  friend void swap(SSHCommand& a, SSHCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SSHCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SSHCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SSHCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SSHCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SSHCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SSHCommand& from) {
    SSHCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SSHCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.SSHCommand";
  }
  protected:
  explicit SSHCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStdoutPbFieldNumber = 1,
    kStderrPbFieldNumber = 2,
    kResponseFieldNumber = 9,
  };
  // string stdout_pb = 1;
  void clear_stdout_pb();
  const std::string& stdout_pb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stdout_pb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stdout_pb();
  PROTOBUF_NODISCARD std::string* release_stdout_pb();
  void set_allocated_stdout_pb(std::string* stdout_pb);
  private:
  const std::string& _internal_stdout_pb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stdout_pb(const std::string& value);
  std::string* _internal_mutable_stdout_pb();
  public:

  // string stderr_pb = 2;
  void clear_stderr_pb();
  const std::string& stderr_pb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stderr_pb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stderr_pb();
  PROTOBUF_NODISCARD std::string* release_stderr_pb();
  void set_allocated_stderr_pb(std::string* stderr_pb);
  private:
  const std::string& _internal_stderr_pb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stderr_pb(const std::string& value);
  std::string* _internal_mutable_stderr_pb();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.SSHCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stdout_pb_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stderr_pb_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class GetPrivsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.GetPrivsReq) */ {
 public:
  inline GetPrivsReq() : GetPrivsReq(nullptr) {}
  ~GetPrivsReq() override;
  explicit PROTOBUF_CONSTEXPR GetPrivsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPrivsReq(const GetPrivsReq& from);
  GetPrivsReq(GetPrivsReq&& from) noexcept
    : GetPrivsReq() {
    *this = ::std::move(from);
  }

  inline GetPrivsReq& operator=(const GetPrivsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPrivsReq& operator=(GetPrivsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPrivsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPrivsReq* internal_default_instance() {
    return reinterpret_cast<const GetPrivsReq*>(
               &_GetPrivsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    138;

  friend void swap(GetPrivsReq& a, GetPrivsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPrivsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPrivsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPrivsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPrivsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPrivsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPrivsReq& from) {
    GetPrivsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPrivsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.GetPrivsReq";
  }
  protected:
  explicit GetPrivsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.GetPrivsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class WindowsPrivilegeEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.WindowsPrivilegeEntry) */ {
 public:
  inline WindowsPrivilegeEntry() : WindowsPrivilegeEntry(nullptr) {}
  ~WindowsPrivilegeEntry() override;
  explicit PROTOBUF_CONSTEXPR WindowsPrivilegeEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WindowsPrivilegeEntry(const WindowsPrivilegeEntry& from);
  WindowsPrivilegeEntry(WindowsPrivilegeEntry&& from) noexcept
    : WindowsPrivilegeEntry() {
    *this = ::std::move(from);
  }

  inline WindowsPrivilegeEntry& operator=(const WindowsPrivilegeEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowsPrivilegeEntry& operator=(WindowsPrivilegeEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WindowsPrivilegeEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const WindowsPrivilegeEntry* internal_default_instance() {
    return reinterpret_cast<const WindowsPrivilegeEntry*>(
               &_WindowsPrivilegeEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    139;

  friend void swap(WindowsPrivilegeEntry& a, WindowsPrivilegeEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowsPrivilegeEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowsPrivilegeEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WindowsPrivilegeEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WindowsPrivilegeEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WindowsPrivilegeEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WindowsPrivilegeEntry& from) {
    WindowsPrivilegeEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WindowsPrivilegeEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.WindowsPrivilegeEntry";
  }
  protected:
  explicit WindowsPrivilegeEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kEnabledFieldNumber = 3,
    kEnabledByDefaultFieldNumber = 4,
    kRemovedFieldNumber = 5,
    kUsedForAccessFieldNumber = 6,
  };
  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string Description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // bool Enabled = 3;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // bool EnabledByDefault = 4;
  void clear_enabledbydefault();
  bool enabledbydefault() const;
  void set_enabledbydefault(bool value);
  private:
  bool _internal_enabledbydefault() const;
  void _internal_set_enabledbydefault(bool value);
  public:

  // bool Removed = 5;
  void clear_removed();
  bool removed() const;
  void set_removed(bool value);
  private:
  bool _internal_removed() const;
  void _internal_set_removed(bool value);
  public:

  // bool UsedForAccess = 6;
  void clear_usedforaccess();
  bool usedforaccess() const;
  void set_usedforaccess(bool value);
  private:
  bool _internal_usedforaccess() const;
  void _internal_set_usedforaccess(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.WindowsPrivilegeEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    bool enabled_;
    bool enabledbydefault_;
    bool removed_;
    bool usedforaccess_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class GetPrivs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.GetPrivs) */ {
 public:
  inline GetPrivs() : GetPrivs(nullptr) {}
  ~GetPrivs() override;
  explicit PROTOBUF_CONSTEXPR GetPrivs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPrivs(const GetPrivs& from);
  GetPrivs(GetPrivs&& from) noexcept
    : GetPrivs() {
    *this = ::std::move(from);
  }

  inline GetPrivs& operator=(const GetPrivs& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPrivs& operator=(GetPrivs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPrivs& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPrivs* internal_default_instance() {
    return reinterpret_cast<const GetPrivs*>(
               &_GetPrivs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    140;

  friend void swap(GetPrivs& a, GetPrivs& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPrivs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPrivs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPrivs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPrivs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPrivs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPrivs& from) {
    GetPrivs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPrivs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.GetPrivs";
  }
  protected:
  explicit GetPrivs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrivInfoFieldNumber = 1,
    kProcessIntegrityFieldNumber = 2,
    kProcessNameFieldNumber = 3,
    kResponseFieldNumber = 9,
  };
  // repeated .sliverpb.WindowsPrivilegeEntry PrivInfo = 1;
  int privinfo_size() const;
  private:
  int _internal_privinfo_size() const;
  public:
  void clear_privinfo();
  ::sliverpb::WindowsPrivilegeEntry* mutable_privinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::WindowsPrivilegeEntry >*
      mutable_privinfo();
  private:
  const ::sliverpb::WindowsPrivilegeEntry& _internal_privinfo(int index) const;
  ::sliverpb::WindowsPrivilegeEntry* _internal_add_privinfo();
  public:
  const ::sliverpb::WindowsPrivilegeEntry& privinfo(int index) const;
  ::sliverpb::WindowsPrivilegeEntry* add_privinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::WindowsPrivilegeEntry >&
      privinfo() const;

  // string ProcessIntegrity = 2;
  void clear_processintegrity();
  const std::string& processintegrity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_processintegrity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_processintegrity();
  PROTOBUF_NODISCARD std::string* release_processintegrity();
  void set_allocated_processintegrity(std::string* processintegrity);
  private:
  const std::string& _internal_processintegrity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processintegrity(const std::string& value);
  std::string* _internal_mutable_processintegrity();
  public:

  // string ProcessName = 3;
  void clear_processname();
  const std::string& processname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_processname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_processname();
  PROTOBUF_NODISCARD std::string* release_processname();
  void set_allocated_processname(std::string* processname);
  private:
  const std::string& _internal_processname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processname(const std::string& value);
  std::string* _internal_mutable_processname();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.GetPrivs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::WindowsPrivilegeEntry > privinfo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr processintegrity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr processname_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RegisterExtensionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RegisterExtensionReq) */ {
 public:
  inline RegisterExtensionReq() : RegisterExtensionReq(nullptr) {}
  ~RegisterExtensionReq() override;
  explicit PROTOBUF_CONSTEXPR RegisterExtensionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterExtensionReq(const RegisterExtensionReq& from);
  RegisterExtensionReq(RegisterExtensionReq&& from) noexcept
    : RegisterExtensionReq() {
    *this = ::std::move(from);
  }

  inline RegisterExtensionReq& operator=(const RegisterExtensionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterExtensionReq& operator=(RegisterExtensionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterExtensionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterExtensionReq* internal_default_instance() {
    return reinterpret_cast<const RegisterExtensionReq*>(
               &_RegisterExtensionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    141;

  friend void swap(RegisterExtensionReq& a, RegisterExtensionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterExtensionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterExtensionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterExtensionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterExtensionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterExtensionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterExtensionReq& from) {
    RegisterExtensionReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterExtensionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RegisterExtensionReq";
  }
  protected:
  explicit RegisterExtensionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDataFieldNumber = 2,
    kOSFieldNumber = 3,
    kInitFieldNumber = 4,
    kRequestFieldNumber = 9,
  };
  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes Data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string OS = 3;
  void clear_os();
  const std::string& os() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os();
  PROTOBUF_NODISCARD std::string* release_os();
  void set_allocated_os(std::string* os);
  private:
  const std::string& _internal_os() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os(const std::string& value);
  std::string* _internal_mutable_os();
  public:

  // string Init = 4;
  void clear_init();
  const std::string& init() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_init(ArgT0&& arg0, ArgT... args);
  std::string* mutable_init();
  PROTOBUF_NODISCARD std::string* release_init();
  void set_allocated_init(std::string* init);
  private:
  const std::string& _internal_init() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_init(const std::string& value);
  std::string* _internal_mutable_init();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.RegisterExtensionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr init_;
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RegisterExtension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RegisterExtension) */ {
 public:
  inline RegisterExtension() : RegisterExtension(nullptr) {}
  ~RegisterExtension() override;
  explicit PROTOBUF_CONSTEXPR RegisterExtension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterExtension(const RegisterExtension& from);
  RegisterExtension(RegisterExtension&& from) noexcept
    : RegisterExtension() {
    *this = ::std::move(from);
  }

  inline RegisterExtension& operator=(const RegisterExtension& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterExtension& operator=(RegisterExtension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterExtension& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterExtension* internal_default_instance() {
    return reinterpret_cast<const RegisterExtension*>(
               &_RegisterExtension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    142;

  friend void swap(RegisterExtension& a, RegisterExtension& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterExtension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterExtension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterExtension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterExtension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterExtension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterExtension& from) {
    RegisterExtension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterExtension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RegisterExtension";
  }
  protected:
  explicit RegisterExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 9,
  };
  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.RegisterExtension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class CallExtensionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.CallExtensionReq) */ {
 public:
  inline CallExtensionReq() : CallExtensionReq(nullptr) {}
  ~CallExtensionReq() override;
  explicit PROTOBUF_CONSTEXPR CallExtensionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallExtensionReq(const CallExtensionReq& from);
  CallExtensionReq(CallExtensionReq&& from) noexcept
    : CallExtensionReq() {
    *this = ::std::move(from);
  }

  inline CallExtensionReq& operator=(const CallExtensionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallExtensionReq& operator=(CallExtensionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallExtensionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallExtensionReq* internal_default_instance() {
    return reinterpret_cast<const CallExtensionReq*>(
               &_CallExtensionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    143;

  friend void swap(CallExtensionReq& a, CallExtensionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CallExtensionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallExtensionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallExtensionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallExtensionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallExtensionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallExtensionReq& from) {
    CallExtensionReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallExtensionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.CallExtensionReq";
  }
  protected:
  explicit CallExtensionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kArgsFieldNumber = 3,
    kExportFieldNumber = 4,
    kRequestFieldNumber = 9,
    kServerStoreFieldNumber = 2,
  };
  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes Args = 3;
  void clear_args();
  const std::string& args() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_args(ArgT0&& arg0, ArgT... args);
  std::string* mutable_args();
  PROTOBUF_NODISCARD std::string* release_args();
  void set_allocated_args(std::string* args);
  private:
  const std::string& _internal_args() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_args(const std::string& value);
  std::string* _internal_mutable_args();
  public:

  // string Export = 4;
  void clear_export_();
  const std::string& export_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_export_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_export_();
  PROTOBUF_NODISCARD std::string* release_export_();
  void set_allocated_export_(std::string* export_);
  private:
  const std::string& _internal_export_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_export_(const std::string& value);
  std::string* _internal_mutable_export_();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // bool ServerStore = 2;
  void clear_serverstore();
  bool serverstore() const;
  void set_serverstore(bool value);
  private:
  bool _internal_serverstore() const;
  void _internal_set_serverstore(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.CallExtensionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr export__;
    ::sliverpb::Request* request_;
    bool serverstore_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class CallExtension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.CallExtension) */ {
 public:
  inline CallExtension() : CallExtension(nullptr) {}
  ~CallExtension() override;
  explicit PROTOBUF_CONSTEXPR CallExtension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallExtension(const CallExtension& from);
  CallExtension(CallExtension&& from) noexcept
    : CallExtension() {
    *this = ::std::move(from);
  }

  inline CallExtension& operator=(const CallExtension& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallExtension& operator=(CallExtension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallExtension& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallExtension* internal_default_instance() {
    return reinterpret_cast<const CallExtension*>(
               &_CallExtension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    144;

  friend void swap(CallExtension& a, CallExtension& b) {
    a.Swap(&b);
  }
  inline void Swap(CallExtension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallExtension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallExtension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallExtension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallExtension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallExtension& from) {
    CallExtension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallExtension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.CallExtension";
  }
  protected:
  explicit CallExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputFieldNumber = 1,
    kResponseFieldNumber = 9,
    kServerStoreFieldNumber = 2,
  };
  // bytes Output = 1;
  void clear_output();
  const std::string& output() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output();
  PROTOBUF_NODISCARD std::string* release_output();
  void set_allocated_output(std::string* output);
  private:
  const std::string& _internal_output() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output(const std::string& value);
  std::string* _internal_mutable_output();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // bool ServerStore = 2;
  void clear_serverstore();
  bool serverstore() const;
  void set_serverstore(bool value);
  private:
  bool _internal_serverstore() const;
  void _internal_set_serverstore(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.CallExtension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_;
    ::sliverpb::Response* response_;
    bool serverstore_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class ListExtensionsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.ListExtensionsReq) */ {
 public:
  inline ListExtensionsReq() : ListExtensionsReq(nullptr) {}
  ~ListExtensionsReq() override;
  explicit PROTOBUF_CONSTEXPR ListExtensionsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListExtensionsReq(const ListExtensionsReq& from);
  ListExtensionsReq(ListExtensionsReq&& from) noexcept
    : ListExtensionsReq() {
    *this = ::std::move(from);
  }

  inline ListExtensionsReq& operator=(const ListExtensionsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListExtensionsReq& operator=(ListExtensionsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListExtensionsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListExtensionsReq* internal_default_instance() {
    return reinterpret_cast<const ListExtensionsReq*>(
               &_ListExtensionsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    145;

  friend void swap(ListExtensionsReq& a, ListExtensionsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ListExtensionsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListExtensionsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListExtensionsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListExtensionsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListExtensionsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListExtensionsReq& from) {
    ListExtensionsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListExtensionsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.ListExtensionsReq";
  }
  protected:
  explicit ListExtensionsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.ListExtensionsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class ListExtensions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.ListExtensions) */ {
 public:
  inline ListExtensions() : ListExtensions(nullptr) {}
  ~ListExtensions() override;
  explicit PROTOBUF_CONSTEXPR ListExtensions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListExtensions(const ListExtensions& from);
  ListExtensions(ListExtensions&& from) noexcept
    : ListExtensions() {
    *this = ::std::move(from);
  }

  inline ListExtensions& operator=(const ListExtensions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListExtensions& operator=(ListExtensions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListExtensions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListExtensions* internal_default_instance() {
    return reinterpret_cast<const ListExtensions*>(
               &_ListExtensions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    146;

  friend void swap(ListExtensions& a, ListExtensions& b) {
    a.Swap(&b);
  }
  inline void Swap(ListExtensions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListExtensions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListExtensions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListExtensions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListExtensions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListExtensions& from) {
    ListExtensions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListExtensions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.ListExtensions";
  }
  protected:
  explicit ListExtensions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamesFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // repeated string Names = 1;
  int names_size() const;
  private:
  int _internal_names_size() const;
  public:
  void clear_names();
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_names();
  private:
  const std::string& _internal_names(int index) const;
  std::string* _internal_add_names();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.ListExtensions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> names_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RportFwdStopListenerReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RportFwdStopListenerReq) */ {
 public:
  inline RportFwdStopListenerReq() : RportFwdStopListenerReq(nullptr) {}
  ~RportFwdStopListenerReq() override;
  explicit PROTOBUF_CONSTEXPR RportFwdStopListenerReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RportFwdStopListenerReq(const RportFwdStopListenerReq& from);
  RportFwdStopListenerReq(RportFwdStopListenerReq&& from) noexcept
    : RportFwdStopListenerReq() {
    *this = ::std::move(from);
  }

  inline RportFwdStopListenerReq& operator=(const RportFwdStopListenerReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RportFwdStopListenerReq& operator=(RportFwdStopListenerReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RportFwdStopListenerReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RportFwdStopListenerReq* internal_default_instance() {
    return reinterpret_cast<const RportFwdStopListenerReq*>(
               &_RportFwdStopListenerReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    147;

  friend void swap(RportFwdStopListenerReq& a, RportFwdStopListenerReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RportFwdStopListenerReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RportFwdStopListenerReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RportFwdStopListenerReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RportFwdStopListenerReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RportFwdStopListenerReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RportFwdStopListenerReq& from) {
    RportFwdStopListenerReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RportFwdStopListenerReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RportFwdStopListenerReq";
  }
  protected:
  explicit RportFwdStopListenerReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
    kIDFieldNumber = 1,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // uint32 ID = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.RportFwdStopListenerReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RportFwdStartListenerReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RportFwdStartListenerReq) */ {
 public:
  inline RportFwdStartListenerReq() : RportFwdStartListenerReq(nullptr) {}
  ~RportFwdStartListenerReq() override;
  explicit PROTOBUF_CONSTEXPR RportFwdStartListenerReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RportFwdStartListenerReq(const RportFwdStartListenerReq& from);
  RportFwdStartListenerReq(RportFwdStartListenerReq&& from) noexcept
    : RportFwdStartListenerReq() {
    *this = ::std::move(from);
  }

  inline RportFwdStartListenerReq& operator=(const RportFwdStartListenerReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RportFwdStartListenerReq& operator=(RportFwdStartListenerReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RportFwdStartListenerReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RportFwdStartListenerReq* internal_default_instance() {
    return reinterpret_cast<const RportFwdStartListenerReq*>(
               &_RportFwdStartListenerReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    148;

  friend void swap(RportFwdStartListenerReq& a, RportFwdStartListenerReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RportFwdStartListenerReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RportFwdStartListenerReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RportFwdStartListenerReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RportFwdStartListenerReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RportFwdStartListenerReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RportFwdStartListenerReq& from) {
    RportFwdStartListenerReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RportFwdStartListenerReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RportFwdStartListenerReq";
  }
  protected:
  explicit RportFwdStartListenerReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBindAddressFieldNumber = 1,
    kForwardAddressFieldNumber = 4,
    kRequestFieldNumber = 9,
    kBindPortFieldNumber = 2,
    kForwardPortFieldNumber = 3,
  };
  // string BindAddress = 1;
  void clear_bindaddress();
  const std::string& bindaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bindaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bindaddress();
  PROTOBUF_NODISCARD std::string* release_bindaddress();
  void set_allocated_bindaddress(std::string* bindaddress);
  private:
  const std::string& _internal_bindaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bindaddress(const std::string& value);
  std::string* _internal_mutable_bindaddress();
  public:

  // string forwardAddress = 4;
  void clear_forwardaddress();
  const std::string& forwardaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_forwardaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_forwardaddress();
  PROTOBUF_NODISCARD std::string* release_forwardaddress();
  void set_allocated_forwardaddress(std::string* forwardaddress);
  private:
  const std::string& _internal_forwardaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_forwardaddress(const std::string& value);
  std::string* _internal_mutable_forwardaddress();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // uint32 BindPort = 2;
  void clear_bindport();
  uint32_t bindport() const;
  void set_bindport(uint32_t value);
  private:
  uint32_t _internal_bindport() const;
  void _internal_set_bindport(uint32_t value);
  public:

  // uint32 forwardPort = 3;
  void clear_forwardport();
  uint32_t forwardport() const;
  void set_forwardport(uint32_t value);
  private:
  uint32_t _internal_forwardport() const;
  void _internal_set_forwardport(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.RportFwdStartListenerReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bindaddress_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr forwardaddress_;
    ::sliverpb::Request* request_;
    uint32_t bindport_;
    uint32_t forwardport_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RportFwdListener final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RportFwdListener) */ {
 public:
  inline RportFwdListener() : RportFwdListener(nullptr) {}
  ~RportFwdListener() override;
  explicit PROTOBUF_CONSTEXPR RportFwdListener(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RportFwdListener(const RportFwdListener& from);
  RportFwdListener(RportFwdListener&& from) noexcept
    : RportFwdListener() {
    *this = ::std::move(from);
  }

  inline RportFwdListener& operator=(const RportFwdListener& from) {
    CopyFrom(from);
    return *this;
  }
  inline RportFwdListener& operator=(RportFwdListener&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RportFwdListener& default_instance() {
    return *internal_default_instance();
  }
  static inline const RportFwdListener* internal_default_instance() {
    return reinterpret_cast<const RportFwdListener*>(
               &_RportFwdListener_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    149;

  friend void swap(RportFwdListener& a, RportFwdListener& b) {
    a.Swap(&b);
  }
  inline void Swap(RportFwdListener* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RportFwdListener* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RportFwdListener* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RportFwdListener>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RportFwdListener& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RportFwdListener& from) {
    RportFwdListener::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RportFwdListener* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RportFwdListener";
  }
  protected:
  explicit RportFwdListener(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBindAddressFieldNumber = 2,
    kForwardAddressFieldNumber = 4,
    kResponseFieldNumber = 9,
    kIDFieldNumber = 1,
    kBindPortFieldNumber = 3,
    kForwardPortFieldNumber = 5,
  };
  // string BindAddress = 2;
  void clear_bindaddress();
  const std::string& bindaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bindaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bindaddress();
  PROTOBUF_NODISCARD std::string* release_bindaddress();
  void set_allocated_bindaddress(std::string* bindaddress);
  private:
  const std::string& _internal_bindaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bindaddress(const std::string& value);
  std::string* _internal_mutable_bindaddress();
  public:

  // string forwardAddress = 4;
  void clear_forwardaddress();
  const std::string& forwardaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_forwardaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_forwardaddress();
  PROTOBUF_NODISCARD std::string* release_forwardaddress();
  void set_allocated_forwardaddress(std::string* forwardaddress);
  private:
  const std::string& _internal_forwardaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_forwardaddress(const std::string& value);
  std::string* _internal_mutable_forwardaddress();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // uint32 ID = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 bindPort = 3;
  void clear_bindport();
  uint32_t bindport() const;
  void set_bindport(uint32_t value);
  private:
  uint32_t _internal_bindport() const;
  void _internal_set_bindport(uint32_t value);
  public:

  // uint32 forwardPort = 5;
  void clear_forwardport();
  uint32_t forwardport() const;
  void set_forwardport(uint32_t value);
  private:
  uint32_t _internal_forwardport() const;
  void _internal_set_forwardport(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.RportFwdListener)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bindaddress_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr forwardaddress_;
    ::sliverpb::Response* response_;
    uint32_t id_;
    uint32_t bindport_;
    uint32_t forwardport_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RportFwdListeners final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RportFwdListeners) */ {
 public:
  inline RportFwdListeners() : RportFwdListeners(nullptr) {}
  ~RportFwdListeners() override;
  explicit PROTOBUF_CONSTEXPR RportFwdListeners(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RportFwdListeners(const RportFwdListeners& from);
  RportFwdListeners(RportFwdListeners&& from) noexcept
    : RportFwdListeners() {
    *this = ::std::move(from);
  }

  inline RportFwdListeners& operator=(const RportFwdListeners& from) {
    CopyFrom(from);
    return *this;
  }
  inline RportFwdListeners& operator=(RportFwdListeners&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RportFwdListeners& default_instance() {
    return *internal_default_instance();
  }
  static inline const RportFwdListeners* internal_default_instance() {
    return reinterpret_cast<const RportFwdListeners*>(
               &_RportFwdListeners_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    150;

  friend void swap(RportFwdListeners& a, RportFwdListeners& b) {
    a.Swap(&b);
  }
  inline void Swap(RportFwdListeners* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RportFwdListeners* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RportFwdListeners* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RportFwdListeners>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RportFwdListeners& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RportFwdListeners& from) {
    RportFwdListeners::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RportFwdListeners* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RportFwdListeners";
  }
  protected:
  explicit RportFwdListeners(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListenersFieldNumber = 1,
    kResponseFieldNumber = 9,
  };
  // repeated .sliverpb.RportFwdListener Listeners = 1;
  int listeners_size() const;
  private:
  int _internal_listeners_size() const;
  public:
  void clear_listeners();
  ::sliverpb::RportFwdListener* mutable_listeners(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::RportFwdListener >*
      mutable_listeners();
  private:
  const ::sliverpb::RportFwdListener& _internal_listeners(int index) const;
  ::sliverpb::RportFwdListener* _internal_add_listeners();
  public:
  const ::sliverpb::RportFwdListener& listeners(int index) const;
  ::sliverpb::RportFwdListener* add_listeners();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::RportFwdListener >&
      listeners() const;

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:sliverpb.RportFwdListeners)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::RportFwdListener > listeners_;
    ::sliverpb::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RportFwdListenersReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RportFwdListenersReq) */ {
 public:
  inline RportFwdListenersReq() : RportFwdListenersReq(nullptr) {}
  ~RportFwdListenersReq() override;
  explicit PROTOBUF_CONSTEXPR RportFwdListenersReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RportFwdListenersReq(const RportFwdListenersReq& from);
  RportFwdListenersReq(RportFwdListenersReq&& from) noexcept
    : RportFwdListenersReq() {
    *this = ::std::move(from);
  }

  inline RportFwdListenersReq& operator=(const RportFwdListenersReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RportFwdListenersReq& operator=(RportFwdListenersReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RportFwdListenersReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RportFwdListenersReq* internal_default_instance() {
    return reinterpret_cast<const RportFwdListenersReq*>(
               &_RportFwdListenersReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    151;

  friend void swap(RportFwdListenersReq& a, RportFwdListenersReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RportFwdListenersReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RportFwdListenersReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RportFwdListenersReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RportFwdListenersReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RportFwdListenersReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RportFwdListenersReq& from) {
    RportFwdListenersReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RportFwdListenersReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RportFwdListenersReq";
  }
  protected:
  explicit RportFwdListenersReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 9,
  };
  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:sliverpb.RportFwdListenersReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sliverpb::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RPortfwd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RPortfwd) */ {
 public:
  inline RPortfwd() : RPortfwd(nullptr) {}
  ~RPortfwd() override;
  explicit PROTOBUF_CONSTEXPR RPortfwd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RPortfwd(const RPortfwd& from);
  RPortfwd(RPortfwd&& from) noexcept
    : RPortfwd() {
    *this = ::std::move(from);
  }

  inline RPortfwd& operator=(const RPortfwd& from) {
    CopyFrom(from);
    return *this;
  }
  inline RPortfwd& operator=(RPortfwd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RPortfwd& default_instance() {
    return *internal_default_instance();
  }
  static inline const RPortfwd* internal_default_instance() {
    return reinterpret_cast<const RPortfwd*>(
               &_RPortfwd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    152;

  friend void swap(RPortfwd& a, RPortfwd& b) {
    a.Swap(&b);
  }
  inline void Swap(RPortfwd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RPortfwd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RPortfwd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RPortfwd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RPortfwd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RPortfwd& from) {
    RPortfwd::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RPortfwd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RPortfwd";
  }
  protected:
  explicit RPortfwd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 3,
    kResponseFieldNumber = 9,
    kPortFieldNumber = 1,
    kProtocolFieldNumber = 2,
    kTunnelIDFieldNumber = 8,
  };
  // string Host = 3;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // .sliverpb.Response Response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::sliverpb::Response& response() const;
  PROTOBUF_NODISCARD ::sliverpb::Response* release_response();
  ::sliverpb::Response* mutable_response();
  void set_allocated_response(::sliverpb::Response* response);
  private:
  const ::sliverpb::Response& _internal_response() const;
  ::sliverpb::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::sliverpb::Response* response);
  ::sliverpb::Response* unsafe_arena_release_response();

  // uint32 Port = 1;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // int32 Protocol = 2;
  void clear_protocol();
  int32_t protocol() const;
  void set_protocol(int32_t value);
  private:
  int32_t _internal_protocol() const;
  void _internal_set_protocol(int32_t value);
  public:

  // uint64 TunnelID = 8 [jstype = JS_STRING];
  void clear_tunnelid();
  uint64_t tunnelid() const;
  void set_tunnelid(uint64_t value);
  private:
  uint64_t _internal_tunnelid() const;
  void _internal_set_tunnelid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.RPortfwd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::sliverpb::Response* response_;
    uint32_t port_;
    int32_t protocol_;
    uint64_t tunnelid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// -------------------------------------------------------------------

class RPortfwdReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.RPortfwdReq) */ {
 public:
  inline RPortfwdReq() : RPortfwdReq(nullptr) {}
  ~RPortfwdReq() override;
  explicit PROTOBUF_CONSTEXPR RPortfwdReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RPortfwdReq(const RPortfwdReq& from);
  RPortfwdReq(RPortfwdReq&& from) noexcept
    : RPortfwdReq() {
    *this = ::std::move(from);
  }

  inline RPortfwdReq& operator=(const RPortfwdReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RPortfwdReq& operator=(RPortfwdReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RPortfwdReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RPortfwdReq* internal_default_instance() {
    return reinterpret_cast<const RPortfwdReq*>(
               &_RPortfwdReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    153;

  friend void swap(RPortfwdReq& a, RPortfwdReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RPortfwdReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RPortfwdReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RPortfwdReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RPortfwdReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RPortfwdReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RPortfwdReq& from) {
    RPortfwdReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RPortfwdReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.RPortfwdReq";
  }
  protected:
  explicit RPortfwdReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 3,
    kRequestFieldNumber = 9,
    kPortFieldNumber = 1,
    kProtocolFieldNumber = 2,
    kTunnelIDFieldNumber = 8,
  };
  // string Host = 3;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // .sliverpb.Request Request = 9;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sliverpb::Request& request() const;
  PROTOBUF_NODISCARD ::sliverpb::Request* release_request();
  ::sliverpb::Request* mutable_request();
  void set_allocated_request(::sliverpb::Request* request);
  private:
  const ::sliverpb::Request& _internal_request() const;
  ::sliverpb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sliverpb::Request* request);
  ::sliverpb::Request* unsafe_arena_release_request();

  // uint32 Port = 1;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // int32 Protocol = 2;
  void clear_protocol();
  int32_t protocol() const;
  void set_protocol(int32_t value);
  private:
  int32_t _internal_protocol() const;
  void _internal_set_protocol(int32_t value);
  public:

  // uint64 TunnelID = 8 [jstype = JS_STRING];
  void clear_tunnelid();
  uint64_t tunnelid() const;
  void set_tunnelid(uint64_t value);
  private:
  uint64_t _internal_tunnelid() const;
  void _internal_set_tunnelid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.RPortfwdReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::sliverpb::Request* request_;
    uint32_t port_;
    int32_t protocol_;
    uint64_t tunnelid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sliver_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Envelope

// int64 ID = 1;
inline void Envelope::clear_id() {
  _impl_.id_ = int64_t{0};
}
inline int64_t Envelope::_internal_id() const {
  return _impl_.id_;
}
inline int64_t Envelope::id() const {
  // @@protoc_insertion_point(field_get:sliverpb.Envelope.ID)
  return _internal_id();
}
inline void Envelope::_internal_set_id(int64_t value) {
  
  _impl_.id_ = value;
}
inline void Envelope::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sliverpb.Envelope.ID)
}

// uint32 Type = 2;
inline void Envelope::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t Envelope::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t Envelope::type() const {
  // @@protoc_insertion_point(field_get:sliverpb.Envelope.Type)
  return _internal_type();
}
inline void Envelope::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void Envelope::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sliverpb.Envelope.Type)
}

// bytes Data = 3;
inline void Envelope::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Envelope::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.Envelope.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Envelope::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Envelope.Data)
}
inline std::string* Envelope::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.Envelope.Data)
  return _s;
}
inline const std::string& Envelope::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Envelope::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Envelope::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Envelope::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.Envelope.Data)
  return _impl_.data_.Release();
}
inline void Envelope::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Envelope.Data)
}

// bool UnknownMessageType = 4;
inline void Envelope::clear_unknownmessagetype() {
  _impl_.unknownmessagetype_ = false;
}
inline bool Envelope::_internal_unknownmessagetype() const {
  return _impl_.unknownmessagetype_;
}
inline bool Envelope::unknownmessagetype() const {
  // @@protoc_insertion_point(field_get:sliverpb.Envelope.UnknownMessageType)
  return _internal_unknownmessagetype();
}
inline void Envelope::_internal_set_unknownmessagetype(bool value) {
  
  _impl_.unknownmessagetype_ = value;
}
inline void Envelope::set_unknownmessagetype(bool value) {
  _internal_set_unknownmessagetype(value);
  // @@protoc_insertion_point(field_set:sliverpb.Envelope.UnknownMessageType)
}

// -------------------------------------------------------------------

// BeaconTasks

// string ID = 1;
inline void BeaconTasks::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& BeaconTasks::id() const {
  // @@protoc_insertion_point(field_get:sliverpb.BeaconTasks.ID)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BeaconTasks::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.BeaconTasks.ID)
}
inline std::string* BeaconTasks::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sliverpb.BeaconTasks.ID)
  return _s;
}
inline const std::string& BeaconTasks::_internal_id() const {
  return _impl_.id_.Get();
}
inline void BeaconTasks::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* BeaconTasks::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* BeaconTasks::release_id() {
  // @@protoc_insertion_point(field_release:sliverpb.BeaconTasks.ID)
  return _impl_.id_.Release();
}
inline void BeaconTasks::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.BeaconTasks.ID)
}

// repeated .sliverpb.Envelope Tasks = 2;
inline int BeaconTasks::_internal_tasks_size() const {
  return _impl_.tasks_.size();
}
inline int BeaconTasks::tasks_size() const {
  return _internal_tasks_size();
}
inline void BeaconTasks::clear_tasks() {
  _impl_.tasks_.Clear();
}
inline ::sliverpb::Envelope* BeaconTasks::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.BeaconTasks.Tasks)
  return _impl_.tasks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::Envelope >*
BeaconTasks::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.BeaconTasks.Tasks)
  return &_impl_.tasks_;
}
inline const ::sliverpb::Envelope& BeaconTasks::_internal_tasks(int index) const {
  return _impl_.tasks_.Get(index);
}
inline const ::sliverpb::Envelope& BeaconTasks::tasks(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.BeaconTasks.Tasks)
  return _internal_tasks(index);
}
inline ::sliverpb::Envelope* BeaconTasks::_internal_add_tasks() {
  return _impl_.tasks_.Add();
}
inline ::sliverpb::Envelope* BeaconTasks::add_tasks() {
  ::sliverpb::Envelope* _add = _internal_add_tasks();
  // @@protoc_insertion_point(field_add:sliverpb.BeaconTasks.Tasks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::Envelope >&
BeaconTasks::tasks() const {
  // @@protoc_insertion_point(field_list:sliverpb.BeaconTasks.Tasks)
  return _impl_.tasks_;
}

// int64 NextCheckin = 3;
inline void BeaconTasks::clear_nextcheckin() {
  _impl_.nextcheckin_ = int64_t{0};
}
inline int64_t BeaconTasks::_internal_nextcheckin() const {
  return _impl_.nextcheckin_;
}
inline int64_t BeaconTasks::nextcheckin() const {
  // @@protoc_insertion_point(field_get:sliverpb.BeaconTasks.NextCheckin)
  return _internal_nextcheckin();
}
inline void BeaconTasks::_internal_set_nextcheckin(int64_t value) {
  
  _impl_.nextcheckin_ = value;
}
inline void BeaconTasks::set_nextcheckin(int64_t value) {
  _internal_set_nextcheckin(value);
  // @@protoc_insertion_point(field_set:sliverpb.BeaconTasks.NextCheckin)
}

// -------------------------------------------------------------------

// Register

// string Name = 1;
inline void Register::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Register::name() const {
  // @@protoc_insertion_point(field_get:sliverpb.Register.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Register.Name)
}
inline std::string* Register::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sliverpb.Register.Name)
  return _s;
}
inline const std::string& Register::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Register::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Register::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Register::release_name() {
  // @@protoc_insertion_point(field_release:sliverpb.Register.Name)
  return _impl_.name_.Release();
}
inline void Register::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Register.Name)
}

// string Hostname = 2;
inline void Register::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& Register::hostname() const {
  // @@protoc_insertion_point(field_get:sliverpb.Register.Hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Register.Hostname)
}
inline std::string* Register::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:sliverpb.Register.Hostname)
  return _s;
}
inline const std::string& Register::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void Register::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* Register::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* Register::release_hostname() {
  // @@protoc_insertion_point(field_release:sliverpb.Register.Hostname)
  return _impl_.hostname_.Release();
}
inline void Register::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Register.Hostname)
}

// string Uuid = 3;
inline void Register::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& Register::uuid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Register.Uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Register.Uuid)
}
inline std::string* Register::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:sliverpb.Register.Uuid)
  return _s;
}
inline const std::string& Register::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void Register::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* Register::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* Register::release_uuid() {
  // @@protoc_insertion_point(field_release:sliverpb.Register.Uuid)
  return _impl_.uuid_.Release();
}
inline void Register::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Register.Uuid)
}

// string Username = 4;
inline void Register::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& Register::username() const {
  // @@protoc_insertion_point(field_get:sliverpb.Register.Username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Register.Username)
}
inline std::string* Register::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:sliverpb.Register.Username)
  return _s;
}
inline const std::string& Register::_internal_username() const {
  return _impl_.username_.Get();
}
inline void Register::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* Register::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* Register::release_username() {
  // @@protoc_insertion_point(field_release:sliverpb.Register.Username)
  return _impl_.username_.Release();
}
inline void Register::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Register.Username)
}

// string Uid = 5;
inline void Register::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& Register::uid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Register.Uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Register.Uid)
}
inline std::string* Register::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:sliverpb.Register.Uid)
  return _s;
}
inline const std::string& Register::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void Register::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* Register::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* Register::release_uid() {
  // @@protoc_insertion_point(field_release:sliverpb.Register.Uid)
  return _impl_.uid_.Release();
}
inline void Register::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Register.Uid)
}

// string Gid = 6;
inline void Register::clear_gid() {
  _impl_.gid_.ClearToEmpty();
}
inline const std::string& Register::gid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Register.Gid)
  return _internal_gid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register::set_gid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Register.Gid)
}
inline std::string* Register::mutable_gid() {
  std::string* _s = _internal_mutable_gid();
  // @@protoc_insertion_point(field_mutable:sliverpb.Register.Gid)
  return _s;
}
inline const std::string& Register::_internal_gid() const {
  return _impl_.gid_.Get();
}
inline void Register::_internal_set_gid(const std::string& value) {
  
  _impl_.gid_.Set(value, GetArenaForAllocation());
}
inline std::string* Register::_internal_mutable_gid() {
  
  return _impl_.gid_.Mutable(GetArenaForAllocation());
}
inline std::string* Register::release_gid() {
  // @@protoc_insertion_point(field_release:sliverpb.Register.Gid)
  return _impl_.gid_.Release();
}
inline void Register::set_allocated_gid(std::string* gid) {
  if (gid != nullptr) {
    
  } else {
    
  }
  _impl_.gid_.SetAllocated(gid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gid_.IsDefault()) {
    _impl_.gid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Register.Gid)
}

// string Os = 7;
inline void Register::clear_os() {
  _impl_.os_.ClearToEmpty();
}
inline const std::string& Register::os() const {
  // @@protoc_insertion_point(field_get:sliverpb.Register.Os)
  return _internal_os();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register::set_os(ArgT0&& arg0, ArgT... args) {
 
 _impl_.os_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Register.Os)
}
inline std::string* Register::mutable_os() {
  std::string* _s = _internal_mutable_os();
  // @@protoc_insertion_point(field_mutable:sliverpb.Register.Os)
  return _s;
}
inline const std::string& Register::_internal_os() const {
  return _impl_.os_.Get();
}
inline void Register::_internal_set_os(const std::string& value) {
  
  _impl_.os_.Set(value, GetArenaForAllocation());
}
inline std::string* Register::_internal_mutable_os() {
  
  return _impl_.os_.Mutable(GetArenaForAllocation());
}
inline std::string* Register::release_os() {
  // @@protoc_insertion_point(field_release:sliverpb.Register.Os)
  return _impl_.os_.Release();
}
inline void Register::set_allocated_os(std::string* os) {
  if (os != nullptr) {
    
  } else {
    
  }
  _impl_.os_.SetAllocated(os, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_.IsDefault()) {
    _impl_.os_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Register.Os)
}

// string Arch = 8;
inline void Register::clear_arch() {
  _impl_.arch_.ClearToEmpty();
}
inline const std::string& Register::arch() const {
  // @@protoc_insertion_point(field_get:sliverpb.Register.Arch)
  return _internal_arch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register::set_arch(ArgT0&& arg0, ArgT... args) {
 
 _impl_.arch_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Register.Arch)
}
inline std::string* Register::mutable_arch() {
  std::string* _s = _internal_mutable_arch();
  // @@protoc_insertion_point(field_mutable:sliverpb.Register.Arch)
  return _s;
}
inline const std::string& Register::_internal_arch() const {
  return _impl_.arch_.Get();
}
inline void Register::_internal_set_arch(const std::string& value) {
  
  _impl_.arch_.Set(value, GetArenaForAllocation());
}
inline std::string* Register::_internal_mutable_arch() {
  
  return _impl_.arch_.Mutable(GetArenaForAllocation());
}
inline std::string* Register::release_arch() {
  // @@protoc_insertion_point(field_release:sliverpb.Register.Arch)
  return _impl_.arch_.Release();
}
inline void Register::set_allocated_arch(std::string* arch) {
  if (arch != nullptr) {
    
  } else {
    
  }
  _impl_.arch_.SetAllocated(arch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.arch_.IsDefault()) {
    _impl_.arch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Register.Arch)
}

// int32 Pid = 9;
inline void Register::clear_pid() {
  _impl_.pid_ = 0;
}
inline int32_t Register::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t Register::pid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Register.Pid)
  return _internal_pid();
}
inline void Register::_internal_set_pid(int32_t value) {
  
  _impl_.pid_ = value;
}
inline void Register::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:sliverpb.Register.Pid)
}

// string Filename = 10;
inline void Register::clear_filename() {
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& Register::filename() const {
  // @@protoc_insertion_point(field_get:sliverpb.Register.Filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register::set_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Register.Filename)
}
inline std::string* Register::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:sliverpb.Register.Filename)
  return _s;
}
inline const std::string& Register::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void Register::_internal_set_filename(const std::string& value) {
  
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* Register::_internal_mutable_filename() {
  
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* Register::release_filename() {
  // @@protoc_insertion_point(field_release:sliverpb.Register.Filename)
  return _impl_.filename_.Release();
}
inline void Register::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Register.Filename)
}

// string ActiveC2 = 11;
inline void Register::clear_activec2() {
  _impl_.activec2_.ClearToEmpty();
}
inline const std::string& Register::activec2() const {
  // @@protoc_insertion_point(field_get:sliverpb.Register.ActiveC2)
  return _internal_activec2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register::set_activec2(ArgT0&& arg0, ArgT... args) {
 
 _impl_.activec2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Register.ActiveC2)
}
inline std::string* Register::mutable_activec2() {
  std::string* _s = _internal_mutable_activec2();
  // @@protoc_insertion_point(field_mutable:sliverpb.Register.ActiveC2)
  return _s;
}
inline const std::string& Register::_internal_activec2() const {
  return _impl_.activec2_.Get();
}
inline void Register::_internal_set_activec2(const std::string& value) {
  
  _impl_.activec2_.Set(value, GetArenaForAllocation());
}
inline std::string* Register::_internal_mutable_activec2() {
  
  return _impl_.activec2_.Mutable(GetArenaForAllocation());
}
inline std::string* Register::release_activec2() {
  // @@protoc_insertion_point(field_release:sliverpb.Register.ActiveC2)
  return _impl_.activec2_.Release();
}
inline void Register::set_allocated_activec2(std::string* activec2) {
  if (activec2 != nullptr) {
    
  } else {
    
  }
  _impl_.activec2_.SetAllocated(activec2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.activec2_.IsDefault()) {
    _impl_.activec2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Register.ActiveC2)
}

// string Version = 12;
inline void Register::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& Register::version() const {
  // @@protoc_insertion_point(field_get:sliverpb.Register.Version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Register.Version)
}
inline std::string* Register::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:sliverpb.Register.Version)
  return _s;
}
inline const std::string& Register::_internal_version() const {
  return _impl_.version_.Get();
}
inline void Register::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Register::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* Register::release_version() {
  // @@protoc_insertion_point(field_release:sliverpb.Register.Version)
  return _impl_.version_.Release();
}
inline void Register::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Register.Version)
}

// int64 ReconnectInterval = 13;
inline void Register::clear_reconnectinterval() {
  _impl_.reconnectinterval_ = int64_t{0};
}
inline int64_t Register::_internal_reconnectinterval() const {
  return _impl_.reconnectinterval_;
}
inline int64_t Register::reconnectinterval() const {
  // @@protoc_insertion_point(field_get:sliverpb.Register.ReconnectInterval)
  return _internal_reconnectinterval();
}
inline void Register::_internal_set_reconnectinterval(int64_t value) {
  
  _impl_.reconnectinterval_ = value;
}
inline void Register::set_reconnectinterval(int64_t value) {
  _internal_set_reconnectinterval(value);
  // @@protoc_insertion_point(field_set:sliverpb.Register.ReconnectInterval)
}

// string ProxyURL = 14;
inline void Register::clear_proxyurl() {
  _impl_.proxyurl_.ClearToEmpty();
}
inline const std::string& Register::proxyurl() const {
  // @@protoc_insertion_point(field_get:sliverpb.Register.ProxyURL)
  return _internal_proxyurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register::set_proxyurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.proxyurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Register.ProxyURL)
}
inline std::string* Register::mutable_proxyurl() {
  std::string* _s = _internal_mutable_proxyurl();
  // @@protoc_insertion_point(field_mutable:sliverpb.Register.ProxyURL)
  return _s;
}
inline const std::string& Register::_internal_proxyurl() const {
  return _impl_.proxyurl_.Get();
}
inline void Register::_internal_set_proxyurl(const std::string& value) {
  
  _impl_.proxyurl_.Set(value, GetArenaForAllocation());
}
inline std::string* Register::_internal_mutable_proxyurl() {
  
  return _impl_.proxyurl_.Mutable(GetArenaForAllocation());
}
inline std::string* Register::release_proxyurl() {
  // @@protoc_insertion_point(field_release:sliverpb.Register.ProxyURL)
  return _impl_.proxyurl_.Release();
}
inline void Register::set_allocated_proxyurl(std::string* proxyurl) {
  if (proxyurl != nullptr) {
    
  } else {
    
  }
  _impl_.proxyurl_.SetAllocated(proxyurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.proxyurl_.IsDefault()) {
    _impl_.proxyurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Register.ProxyURL)
}

// string ConfigID = 16;
inline void Register::clear_configid() {
  _impl_.configid_.ClearToEmpty();
}
inline const std::string& Register::configid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Register.ConfigID)
  return _internal_configid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register::set_configid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.configid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Register.ConfigID)
}
inline std::string* Register::mutable_configid() {
  std::string* _s = _internal_mutable_configid();
  // @@protoc_insertion_point(field_mutable:sliverpb.Register.ConfigID)
  return _s;
}
inline const std::string& Register::_internal_configid() const {
  return _impl_.configid_.Get();
}
inline void Register::_internal_set_configid(const std::string& value) {
  
  _impl_.configid_.Set(value, GetArenaForAllocation());
}
inline std::string* Register::_internal_mutable_configid() {
  
  return _impl_.configid_.Mutable(GetArenaForAllocation());
}
inline std::string* Register::release_configid() {
  // @@protoc_insertion_point(field_release:sliverpb.Register.ConfigID)
  return _impl_.configid_.Release();
}
inline void Register::set_allocated_configid(std::string* configid) {
  if (configid != nullptr) {
    
  } else {
    
  }
  _impl_.configid_.SetAllocated(configid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.configid_.IsDefault()) {
    _impl_.configid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Register.ConfigID)
}

// int64 PeerID = 17;
inline void Register::clear_peerid() {
  _impl_.peerid_ = int64_t{0};
}
inline int64_t Register::_internal_peerid() const {
  return _impl_.peerid_;
}
inline int64_t Register::peerid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Register.PeerID)
  return _internal_peerid();
}
inline void Register::_internal_set_peerid(int64_t value) {
  
  _impl_.peerid_ = value;
}
inline void Register::set_peerid(int64_t value) {
  _internal_set_peerid(value);
  // @@protoc_insertion_point(field_set:sliverpb.Register.PeerID)
}

// string Locale = 18;
inline void Register::clear_locale() {
  _impl_.locale_.ClearToEmpty();
}
inline const std::string& Register::locale() const {
  // @@protoc_insertion_point(field_get:sliverpb.Register.Locale)
  return _internal_locale();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register::set_locale(ArgT0&& arg0, ArgT... args) {
 
 _impl_.locale_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Register.Locale)
}
inline std::string* Register::mutable_locale() {
  std::string* _s = _internal_mutable_locale();
  // @@protoc_insertion_point(field_mutable:sliverpb.Register.Locale)
  return _s;
}
inline const std::string& Register::_internal_locale() const {
  return _impl_.locale_.Get();
}
inline void Register::_internal_set_locale(const std::string& value) {
  
  _impl_.locale_.Set(value, GetArenaForAllocation());
}
inline std::string* Register::_internal_mutable_locale() {
  
  return _impl_.locale_.Mutable(GetArenaForAllocation());
}
inline std::string* Register::release_locale() {
  // @@protoc_insertion_point(field_release:sliverpb.Register.Locale)
  return _impl_.locale_.Release();
}
inline void Register::set_allocated_locale(std::string* locale) {
  if (locale != nullptr) {
    
  } else {
    
  }
  _impl_.locale_.SetAllocated(locale, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.locale_.IsDefault()) {
    _impl_.locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Register.Locale)
}

// -------------------------------------------------------------------

// BeaconRegister

// string ID = 1;
inline void BeaconRegister::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& BeaconRegister::id() const {
  // @@protoc_insertion_point(field_get:sliverpb.BeaconRegister.ID)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BeaconRegister::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.BeaconRegister.ID)
}
inline std::string* BeaconRegister::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sliverpb.BeaconRegister.ID)
  return _s;
}
inline const std::string& BeaconRegister::_internal_id() const {
  return _impl_.id_.Get();
}
inline void BeaconRegister::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* BeaconRegister::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* BeaconRegister::release_id() {
  // @@protoc_insertion_point(field_release:sliverpb.BeaconRegister.ID)
  return _impl_.id_.Release();
}
inline void BeaconRegister::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.BeaconRegister.ID)
}

// int64 Interval = 2;
inline void BeaconRegister::clear_interval() {
  _impl_.interval_ = int64_t{0};
}
inline int64_t BeaconRegister::_internal_interval() const {
  return _impl_.interval_;
}
inline int64_t BeaconRegister::interval() const {
  // @@protoc_insertion_point(field_get:sliverpb.BeaconRegister.Interval)
  return _internal_interval();
}
inline void BeaconRegister::_internal_set_interval(int64_t value) {
  
  _impl_.interval_ = value;
}
inline void BeaconRegister::set_interval(int64_t value) {
  _internal_set_interval(value);
  // @@protoc_insertion_point(field_set:sliverpb.BeaconRegister.Interval)
}

// int64 Jitter = 3;
inline void BeaconRegister::clear_jitter() {
  _impl_.jitter_ = int64_t{0};
}
inline int64_t BeaconRegister::_internal_jitter() const {
  return _impl_.jitter_;
}
inline int64_t BeaconRegister::jitter() const {
  // @@protoc_insertion_point(field_get:sliverpb.BeaconRegister.Jitter)
  return _internal_jitter();
}
inline void BeaconRegister::_internal_set_jitter(int64_t value) {
  
  _impl_.jitter_ = value;
}
inline void BeaconRegister::set_jitter(int64_t value) {
  _internal_set_jitter(value);
  // @@protoc_insertion_point(field_set:sliverpb.BeaconRegister.Jitter)
}

// .sliverpb.Register Register = 4;
inline bool BeaconRegister::_internal_has_register_() const {
  return this != internal_default_instance() && _impl_.register__ != nullptr;
}
inline bool BeaconRegister::has_register_() const {
  return _internal_has_register_();
}
inline void BeaconRegister::clear_register_() {
  if (GetArenaForAllocation() == nullptr && _impl_.register__ != nullptr) {
    delete _impl_.register__;
  }
  _impl_.register__ = nullptr;
}
inline const ::sliverpb::Register& BeaconRegister::_internal_register_() const {
  const ::sliverpb::Register* p = _impl_.register__;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Register&>(
      ::sliverpb::_Register_default_instance_);
}
inline const ::sliverpb::Register& BeaconRegister::register_() const {
  // @@protoc_insertion_point(field_get:sliverpb.BeaconRegister.Register)
  return _internal_register_();
}
inline void BeaconRegister::unsafe_arena_set_allocated_register_(
    ::sliverpb::Register* register_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.register__);
  }
  _impl_.register__ = register_;
  if (register_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.BeaconRegister.Register)
}
inline ::sliverpb::Register* BeaconRegister::release_register_() {
  
  ::sliverpb::Register* temp = _impl_.register__;
  _impl_.register__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Register* BeaconRegister::unsafe_arena_release_register_() {
  // @@protoc_insertion_point(field_release:sliverpb.BeaconRegister.Register)
  
  ::sliverpb::Register* temp = _impl_.register__;
  _impl_.register__ = nullptr;
  return temp;
}
inline ::sliverpb::Register* BeaconRegister::_internal_mutable_register_() {
  
  if (_impl_.register__ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Register>(GetArenaForAllocation());
    _impl_.register__ = p;
  }
  return _impl_.register__;
}
inline ::sliverpb::Register* BeaconRegister::mutable_register_() {
  ::sliverpb::Register* _msg = _internal_mutable_register_();
  // @@protoc_insertion_point(field_mutable:sliverpb.BeaconRegister.Register)
  return _msg;
}
inline void BeaconRegister::set_allocated_register_(::sliverpb::Register* register_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.register__;
  }
  if (register_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(register_);
    if (message_arena != submessage_arena) {
      register_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, register_, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.register__ = register_;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.BeaconRegister.Register)
}

// int64 NextCheckin = 5;
inline void BeaconRegister::clear_nextcheckin() {
  _impl_.nextcheckin_ = int64_t{0};
}
inline int64_t BeaconRegister::_internal_nextcheckin() const {
  return _impl_.nextcheckin_;
}
inline int64_t BeaconRegister::nextcheckin() const {
  // @@protoc_insertion_point(field_get:sliverpb.BeaconRegister.NextCheckin)
  return _internal_nextcheckin();
}
inline void BeaconRegister::_internal_set_nextcheckin(int64_t value) {
  
  _impl_.nextcheckin_ = value;
}
inline void BeaconRegister::set_nextcheckin(int64_t value) {
  _internal_set_nextcheckin(value);
  // @@protoc_insertion_point(field_set:sliverpb.BeaconRegister.NextCheckin)
}

// -------------------------------------------------------------------

// SessionRegister

// string ID = 1;
inline void SessionRegister::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& SessionRegister::id() const {
  // @@protoc_insertion_point(field_get:sliverpb.SessionRegister.ID)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionRegister::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SessionRegister.ID)
}
inline std::string* SessionRegister::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sliverpb.SessionRegister.ID)
  return _s;
}
inline const std::string& SessionRegister::_internal_id() const {
  return _impl_.id_.Get();
}
inline void SessionRegister::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionRegister::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionRegister::release_id() {
  // @@protoc_insertion_point(field_release:sliverpb.SessionRegister.ID)
  return _impl_.id_.Release();
}
inline void SessionRegister::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SessionRegister.ID)
}

// .sliverpb.Register Register = 2;
inline bool SessionRegister::_internal_has_register_() const {
  return this != internal_default_instance() && _impl_.register__ != nullptr;
}
inline bool SessionRegister::has_register_() const {
  return _internal_has_register_();
}
inline void SessionRegister::clear_register_() {
  if (GetArenaForAllocation() == nullptr && _impl_.register__ != nullptr) {
    delete _impl_.register__;
  }
  _impl_.register__ = nullptr;
}
inline const ::sliverpb::Register& SessionRegister::_internal_register_() const {
  const ::sliverpb::Register* p = _impl_.register__;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Register&>(
      ::sliverpb::_Register_default_instance_);
}
inline const ::sliverpb::Register& SessionRegister::register_() const {
  // @@protoc_insertion_point(field_get:sliverpb.SessionRegister.Register)
  return _internal_register_();
}
inline void SessionRegister::unsafe_arena_set_allocated_register_(
    ::sliverpb::Register* register_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.register__);
  }
  _impl_.register__ = register_;
  if (register_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.SessionRegister.Register)
}
inline ::sliverpb::Register* SessionRegister::release_register_() {
  
  ::sliverpb::Register* temp = _impl_.register__;
  _impl_.register__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Register* SessionRegister::unsafe_arena_release_register_() {
  // @@protoc_insertion_point(field_release:sliverpb.SessionRegister.Register)
  
  ::sliverpb::Register* temp = _impl_.register__;
  _impl_.register__ = nullptr;
  return temp;
}
inline ::sliverpb::Register* SessionRegister::_internal_mutable_register_() {
  
  if (_impl_.register__ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Register>(GetArenaForAllocation());
    _impl_.register__ = p;
  }
  return _impl_.register__;
}
inline ::sliverpb::Register* SessionRegister::mutable_register_() {
  ::sliverpb::Register* _msg = _internal_mutable_register_();
  // @@protoc_insertion_point(field_mutable:sliverpb.SessionRegister.Register)
  return _msg;
}
inline void SessionRegister::set_allocated_register_(::sliverpb::Register* register_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.register__;
  }
  if (register_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(register_);
    if (message_arena != submessage_arena) {
      register_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, register_, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.register__ = register_;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SessionRegister.Register)
}

// -------------------------------------------------------------------

// OpenSession

// repeated string C2s = 1;
inline int OpenSession::_internal_c2s_size() const {
  return _impl_.c2s_.size();
}
inline int OpenSession::c2s_size() const {
  return _internal_c2s_size();
}
inline void OpenSession::clear_c2s() {
  _impl_.c2s_.Clear();
}
inline std::string* OpenSession::add_c2s() {
  std::string* _s = _internal_add_c2s();
  // @@protoc_insertion_point(field_add_mutable:sliverpb.OpenSession.C2s)
  return _s;
}
inline const std::string& OpenSession::_internal_c2s(int index) const {
  return _impl_.c2s_.Get(index);
}
inline const std::string& OpenSession::c2s(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.OpenSession.C2s)
  return _internal_c2s(index);
}
inline std::string* OpenSession::mutable_c2s(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.OpenSession.C2s)
  return _impl_.c2s_.Mutable(index);
}
inline void OpenSession::set_c2s(int index, const std::string& value) {
  _impl_.c2s_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sliverpb.OpenSession.C2s)
}
inline void OpenSession::set_c2s(int index, std::string&& value) {
  _impl_.c2s_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sliverpb.OpenSession.C2s)
}
inline void OpenSession::set_c2s(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.c2s_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sliverpb.OpenSession.C2s)
}
inline void OpenSession::set_c2s(int index, const char* value, size_t size) {
  _impl_.c2s_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sliverpb.OpenSession.C2s)
}
inline std::string* OpenSession::_internal_add_c2s() {
  return _impl_.c2s_.Add();
}
inline void OpenSession::add_c2s(const std::string& value) {
  _impl_.c2s_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sliverpb.OpenSession.C2s)
}
inline void OpenSession::add_c2s(std::string&& value) {
  _impl_.c2s_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sliverpb.OpenSession.C2s)
}
inline void OpenSession::add_c2s(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.c2s_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sliverpb.OpenSession.C2s)
}
inline void OpenSession::add_c2s(const char* value, size_t size) {
  _impl_.c2s_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sliverpb.OpenSession.C2s)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OpenSession::c2s() const {
  // @@protoc_insertion_point(field_list:sliverpb.OpenSession.C2s)
  return _impl_.c2s_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OpenSession::mutable_c2s() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.OpenSession.C2s)
  return &_impl_.c2s_;
}

// int64 Delay = 2;
inline void OpenSession::clear_delay() {
  _impl_.delay_ = int64_t{0};
}
inline int64_t OpenSession::_internal_delay() const {
  return _impl_.delay_;
}
inline int64_t OpenSession::delay() const {
  // @@protoc_insertion_point(field_get:sliverpb.OpenSession.Delay)
  return _internal_delay();
}
inline void OpenSession::_internal_set_delay(int64_t value) {
  
  _impl_.delay_ = value;
}
inline void OpenSession::set_delay(int64_t value) {
  _internal_set_delay(value);
  // @@protoc_insertion_point(field_set:sliverpb.OpenSession.Delay)
}

// .sliverpb.Response Response = 8;
inline bool OpenSession::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool OpenSession::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& OpenSession::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& OpenSession::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.OpenSession.Response)
  return _internal_response();
}
inline void OpenSession::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.OpenSession.Response)
}
inline ::sliverpb::Response* OpenSession::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* OpenSession::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.OpenSession.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* OpenSession::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* OpenSession::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.OpenSession.Response)
  return _msg;
}
inline void OpenSession::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.OpenSession.Response)
}

// .sliverpb.Request Request = 9;
inline bool OpenSession::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool OpenSession::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& OpenSession::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& OpenSession::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.OpenSession.Request)
  return _internal_request();
}
inline void OpenSession::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.OpenSession.Request)
}
inline ::sliverpb::Request* OpenSession::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* OpenSession::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.OpenSession.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* OpenSession::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* OpenSession::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.OpenSession.Request)
  return _msg;
}
inline void OpenSession::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.OpenSession.Request)
}

// -------------------------------------------------------------------

// CloseSession

// .sliverpb.Response Response = 8;
inline bool CloseSession::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool CloseSession::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& CloseSession::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& CloseSession::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.CloseSession.Response)
  return _internal_response();
}
inline void CloseSession::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.CloseSession.Response)
}
inline ::sliverpb::Response* CloseSession::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* CloseSession::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.CloseSession.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* CloseSession::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* CloseSession::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.CloseSession.Response)
  return _msg;
}
inline void CloseSession::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.CloseSession.Response)
}

// .sliverpb.Request Request = 9;
inline bool CloseSession::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool CloseSession::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& CloseSession::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& CloseSession::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.CloseSession.Request)
  return _internal_request();
}
inline void CloseSession::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.CloseSession.Request)
}
inline ::sliverpb::Request* CloseSession::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* CloseSession::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.CloseSession.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* CloseSession::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* CloseSession::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.CloseSession.Request)
  return _msg;
}
inline void CloseSession::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.CloseSession.Request)
}

// -------------------------------------------------------------------

// Ping

// int32 Nonce = 1;
inline void Ping::clear_nonce() {
  _impl_.nonce_ = 0;
}
inline int32_t Ping::_internal_nonce() const {
  return _impl_.nonce_;
}
inline int32_t Ping::nonce() const {
  // @@protoc_insertion_point(field_get:sliverpb.Ping.Nonce)
  return _internal_nonce();
}
inline void Ping::_internal_set_nonce(int32_t value) {
  
  _impl_.nonce_ = value;
}
inline void Ping::set_nonce(int32_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:sliverpb.Ping.Nonce)
}

// .sliverpb.Response Response = 8;
inline bool Ping::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Ping::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Ping::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Ping::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Ping.Response)
  return _internal_response();
}
inline void Ping::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Ping.Response)
}
inline ::sliverpb::Response* Ping::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Ping::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Ping.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Ping::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Ping::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Ping.Response)
  return _msg;
}
inline void Ping::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Ping.Response)
}

// .sliverpb.Request Request = 9;
inline bool Ping::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool Ping::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& Ping::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& Ping::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.Ping.Request)
  return _internal_request();
}
inline void Ping::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Ping.Request)
}
inline ::sliverpb::Request* Ping::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* Ping::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.Ping.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* Ping::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* Ping::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.Ping.Request)
  return _msg;
}
inline void Ping::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Ping.Request)
}

// -------------------------------------------------------------------

// KillReq

// bool Force = 1;
inline void KillReq::clear_force() {
  _impl_.force_ = false;
}
inline bool KillReq::_internal_force() const {
  return _impl_.force_;
}
inline bool KillReq::force() const {
  // @@protoc_insertion_point(field_get:sliverpb.KillReq.Force)
  return _internal_force();
}
inline void KillReq::_internal_set_force(bool value) {
  
  _impl_.force_ = value;
}
inline void KillReq::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:sliverpb.KillReq.Force)
}

// .sliverpb.Request Request = 9;
inline bool KillReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool KillReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& KillReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& KillReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.KillReq.Request)
  return _internal_request();
}
inline void KillReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.KillReq.Request)
}
inline ::sliverpb::Request* KillReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* KillReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.KillReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* KillReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* KillReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.KillReq.Request)
  return _msg;
}
inline void KillReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.KillReq.Request)
}

// -------------------------------------------------------------------

// PsReq

// .sliverpb.Request Request = 9;
inline bool PsReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool PsReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& PsReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& PsReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.PsReq.Request)
  return _internal_request();
}
inline void PsReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.PsReq.Request)
}
inline ::sliverpb::Request* PsReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* PsReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.PsReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* PsReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* PsReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.PsReq.Request)
  return _msg;
}
inline void PsReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PsReq.Request)
}

// -------------------------------------------------------------------

// Ps

// repeated .sliverpb.Process Processes = 1;
inline int Ps::_internal_processes_size() const {
  return _impl_.processes_.size();
}
inline int Ps::processes_size() const {
  return _internal_processes_size();
}
inline ::sliverpb::Process* Ps::mutable_processes(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.Ps.Processes)
  return _impl_.processes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::Process >*
Ps::mutable_processes() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.Ps.Processes)
  return &_impl_.processes_;
}
inline const ::sliverpb::Process& Ps::_internal_processes(int index) const {
  return _impl_.processes_.Get(index);
}
inline const ::sliverpb::Process& Ps::processes(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.Ps.Processes)
  return _internal_processes(index);
}
inline ::sliverpb::Process* Ps::_internal_add_processes() {
  return _impl_.processes_.Add();
}
inline ::sliverpb::Process* Ps::add_processes() {
  ::sliverpb::Process* _add = _internal_add_processes();
  // @@protoc_insertion_point(field_add:sliverpb.Ps.Processes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::Process >&
Ps::processes() const {
  // @@protoc_insertion_point(field_list:sliverpb.Ps.Processes)
  return _impl_.processes_;
}

// .sliverpb.Response Response = 9;
inline bool Ps::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Ps::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Ps::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Ps::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Ps.Response)
  return _internal_response();
}
inline void Ps::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Ps.Response)
}
inline ::sliverpb::Response* Ps::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Ps::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Ps.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Ps::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Ps::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Ps.Response)
  return _msg;
}
inline void Ps::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Ps.Response)
}

// -------------------------------------------------------------------

// TerminateReq

// int32 Pid = 1;
inline void TerminateReq::clear_pid() {
  _impl_.pid_ = 0;
}
inline int32_t TerminateReq::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t TerminateReq::pid() const {
  // @@protoc_insertion_point(field_get:sliverpb.TerminateReq.Pid)
  return _internal_pid();
}
inline void TerminateReq::_internal_set_pid(int32_t value) {
  
  _impl_.pid_ = value;
}
inline void TerminateReq::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:sliverpb.TerminateReq.Pid)
}

// bool Force = 2;
inline void TerminateReq::clear_force() {
  _impl_.force_ = false;
}
inline bool TerminateReq::_internal_force() const {
  return _impl_.force_;
}
inline bool TerminateReq::force() const {
  // @@protoc_insertion_point(field_get:sliverpb.TerminateReq.Force)
  return _internal_force();
}
inline void TerminateReq::_internal_set_force(bool value) {
  
  _impl_.force_ = value;
}
inline void TerminateReq::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:sliverpb.TerminateReq.Force)
}

// .sliverpb.Request Request = 9;
inline bool TerminateReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool TerminateReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& TerminateReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& TerminateReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.TerminateReq.Request)
  return _internal_request();
}
inline void TerminateReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.TerminateReq.Request)
}
inline ::sliverpb::Request* TerminateReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* TerminateReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.TerminateReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* TerminateReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* TerminateReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.TerminateReq.Request)
  return _msg;
}
inline void TerminateReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.TerminateReq.Request)
}

// -------------------------------------------------------------------

// Terminate

// int32 Pid = 1;
inline void Terminate::clear_pid() {
  _impl_.pid_ = 0;
}
inline int32_t Terminate::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t Terminate::pid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Terminate.Pid)
  return _internal_pid();
}
inline void Terminate::_internal_set_pid(int32_t value) {
  
  _impl_.pid_ = value;
}
inline void Terminate::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:sliverpb.Terminate.Pid)
}

// .sliverpb.Response Response = 9;
inline bool Terminate::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Terminate::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Terminate::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Terminate::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Terminate.Response)
  return _internal_response();
}
inline void Terminate::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Terminate.Response)
}
inline ::sliverpb::Response* Terminate::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Terminate::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Terminate.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Terminate::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Terminate::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Terminate.Response)
  return _msg;
}
inline void Terminate::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Terminate.Response)
}

// -------------------------------------------------------------------

// IfconfigReq

// .sliverpb.Request Request = 9;
inline bool IfconfigReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool IfconfigReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& IfconfigReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& IfconfigReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.IfconfigReq.Request)
  return _internal_request();
}
inline void IfconfigReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.IfconfigReq.Request)
}
inline ::sliverpb::Request* IfconfigReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* IfconfigReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.IfconfigReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* IfconfigReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* IfconfigReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.IfconfigReq.Request)
  return _msg;
}
inline void IfconfigReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.IfconfigReq.Request)
}

// -------------------------------------------------------------------

// Ifconfig

// repeated .sliverpb.NetInterface NetInterfaces = 1;
inline int Ifconfig::_internal_netinterfaces_size() const {
  return _impl_.netinterfaces_.size();
}
inline int Ifconfig::netinterfaces_size() const {
  return _internal_netinterfaces_size();
}
inline void Ifconfig::clear_netinterfaces() {
  _impl_.netinterfaces_.Clear();
}
inline ::sliverpb::NetInterface* Ifconfig::mutable_netinterfaces(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.Ifconfig.NetInterfaces)
  return _impl_.netinterfaces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::NetInterface >*
Ifconfig::mutable_netinterfaces() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.Ifconfig.NetInterfaces)
  return &_impl_.netinterfaces_;
}
inline const ::sliverpb::NetInterface& Ifconfig::_internal_netinterfaces(int index) const {
  return _impl_.netinterfaces_.Get(index);
}
inline const ::sliverpb::NetInterface& Ifconfig::netinterfaces(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.Ifconfig.NetInterfaces)
  return _internal_netinterfaces(index);
}
inline ::sliverpb::NetInterface* Ifconfig::_internal_add_netinterfaces() {
  return _impl_.netinterfaces_.Add();
}
inline ::sliverpb::NetInterface* Ifconfig::add_netinterfaces() {
  ::sliverpb::NetInterface* _add = _internal_add_netinterfaces();
  // @@protoc_insertion_point(field_add:sliverpb.Ifconfig.NetInterfaces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::NetInterface >&
Ifconfig::netinterfaces() const {
  // @@protoc_insertion_point(field_list:sliverpb.Ifconfig.NetInterfaces)
  return _impl_.netinterfaces_;
}

// .sliverpb.Response Response = 9;
inline bool Ifconfig::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Ifconfig::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Ifconfig::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Ifconfig::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Ifconfig.Response)
  return _internal_response();
}
inline void Ifconfig::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Ifconfig.Response)
}
inline ::sliverpb::Response* Ifconfig::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Ifconfig::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Ifconfig.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Ifconfig::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Ifconfig::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Ifconfig.Response)
  return _msg;
}
inline void Ifconfig::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Ifconfig.Response)
}

// -------------------------------------------------------------------

// NetInterface

// int32 Index = 1;
inline void NetInterface::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t NetInterface::_internal_index() const {
  return _impl_.index_;
}
inline int32_t NetInterface::index() const {
  // @@protoc_insertion_point(field_get:sliverpb.NetInterface.Index)
  return _internal_index();
}
inline void NetInterface::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void NetInterface::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:sliverpb.NetInterface.Index)
}

// string Name = 2;
inline void NetInterface::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NetInterface::name() const {
  // @@protoc_insertion_point(field_get:sliverpb.NetInterface.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetInterface::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.NetInterface.Name)
}
inline std::string* NetInterface::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sliverpb.NetInterface.Name)
  return _s;
}
inline const std::string& NetInterface::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NetInterface::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NetInterface::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NetInterface::release_name() {
  // @@protoc_insertion_point(field_release:sliverpb.NetInterface.Name)
  return _impl_.name_.Release();
}
inline void NetInterface::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.NetInterface.Name)
}

// string MAC = 3;
inline void NetInterface::clear_mac() {
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& NetInterface::mac() const {
  // @@protoc_insertion_point(field_get:sliverpb.NetInterface.MAC)
  return _internal_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetInterface::set_mac(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mac_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.NetInterface.MAC)
}
inline std::string* NetInterface::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:sliverpb.NetInterface.MAC)
  return _s;
}
inline const std::string& NetInterface::_internal_mac() const {
  return _impl_.mac_.Get();
}
inline void NetInterface::_internal_set_mac(const std::string& value) {
  
  _impl_.mac_.Set(value, GetArenaForAllocation());
}
inline std::string* NetInterface::_internal_mutable_mac() {
  
  return _impl_.mac_.Mutable(GetArenaForAllocation());
}
inline std::string* NetInterface::release_mac() {
  // @@protoc_insertion_point(field_release:sliverpb.NetInterface.MAC)
  return _impl_.mac_.Release();
}
inline void NetInterface::set_allocated_mac(std::string* mac) {
  if (mac != nullptr) {
    
  } else {
    
  }
  _impl_.mac_.SetAllocated(mac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_.IsDefault()) {
    _impl_.mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.NetInterface.MAC)
}

// repeated string IPAddresses = 4;
inline int NetInterface::_internal_ipaddresses_size() const {
  return _impl_.ipaddresses_.size();
}
inline int NetInterface::ipaddresses_size() const {
  return _internal_ipaddresses_size();
}
inline void NetInterface::clear_ipaddresses() {
  _impl_.ipaddresses_.Clear();
}
inline std::string* NetInterface::add_ipaddresses() {
  std::string* _s = _internal_add_ipaddresses();
  // @@protoc_insertion_point(field_add_mutable:sliverpb.NetInterface.IPAddresses)
  return _s;
}
inline const std::string& NetInterface::_internal_ipaddresses(int index) const {
  return _impl_.ipaddresses_.Get(index);
}
inline const std::string& NetInterface::ipaddresses(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.NetInterface.IPAddresses)
  return _internal_ipaddresses(index);
}
inline std::string* NetInterface::mutable_ipaddresses(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.NetInterface.IPAddresses)
  return _impl_.ipaddresses_.Mutable(index);
}
inline void NetInterface::set_ipaddresses(int index, const std::string& value) {
  _impl_.ipaddresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sliverpb.NetInterface.IPAddresses)
}
inline void NetInterface::set_ipaddresses(int index, std::string&& value) {
  _impl_.ipaddresses_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sliverpb.NetInterface.IPAddresses)
}
inline void NetInterface::set_ipaddresses(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ipaddresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sliverpb.NetInterface.IPAddresses)
}
inline void NetInterface::set_ipaddresses(int index, const char* value, size_t size) {
  _impl_.ipaddresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sliverpb.NetInterface.IPAddresses)
}
inline std::string* NetInterface::_internal_add_ipaddresses() {
  return _impl_.ipaddresses_.Add();
}
inline void NetInterface::add_ipaddresses(const std::string& value) {
  _impl_.ipaddresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sliverpb.NetInterface.IPAddresses)
}
inline void NetInterface::add_ipaddresses(std::string&& value) {
  _impl_.ipaddresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sliverpb.NetInterface.IPAddresses)
}
inline void NetInterface::add_ipaddresses(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ipaddresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sliverpb.NetInterface.IPAddresses)
}
inline void NetInterface::add_ipaddresses(const char* value, size_t size) {
  _impl_.ipaddresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sliverpb.NetInterface.IPAddresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NetInterface::ipaddresses() const {
  // @@protoc_insertion_point(field_list:sliverpb.NetInterface.IPAddresses)
  return _impl_.ipaddresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NetInterface::mutable_ipaddresses() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.NetInterface.IPAddresses)
  return &_impl_.ipaddresses_;
}

// -------------------------------------------------------------------

// LsReq

// string Path = 1;
inline void LsReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& LsReq::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.LsReq.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LsReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.LsReq.Path)
}
inline std::string* LsReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.LsReq.Path)
  return _s;
}
inline const std::string& LsReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void LsReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* LsReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* LsReq::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.LsReq.Path)
  return _impl_.path_.Release();
}
inline void LsReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.LsReq.Path)
}

// .sliverpb.Request Request = 9;
inline bool LsReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool LsReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& LsReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& LsReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.LsReq.Request)
  return _internal_request();
}
inline void LsReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.LsReq.Request)
}
inline ::sliverpb::Request* LsReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* LsReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.LsReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* LsReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* LsReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.LsReq.Request)
  return _msg;
}
inline void LsReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.LsReq.Request)
}

// -------------------------------------------------------------------

// Ls

// string Path = 1;
inline void Ls::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& Ls::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.Ls.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ls::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Ls.Path)
}
inline std::string* Ls::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.Ls.Path)
  return _s;
}
inline const std::string& Ls::_internal_path() const {
  return _impl_.path_.Get();
}
inline void Ls::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* Ls::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* Ls::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.Ls.Path)
  return _impl_.path_.Release();
}
inline void Ls::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Ls.Path)
}

// bool Exists = 2;
inline void Ls::clear_exists() {
  _impl_.exists_ = false;
}
inline bool Ls::_internal_exists() const {
  return _impl_.exists_;
}
inline bool Ls::exists() const {
  // @@protoc_insertion_point(field_get:sliverpb.Ls.Exists)
  return _internal_exists();
}
inline void Ls::_internal_set_exists(bool value) {
  
  _impl_.exists_ = value;
}
inline void Ls::set_exists(bool value) {
  _internal_set_exists(value);
  // @@protoc_insertion_point(field_set:sliverpb.Ls.Exists)
}

// repeated .sliverpb.FileInfo Files = 3;
inline int Ls::_internal_files_size() const {
  return _impl_.files_.size();
}
inline int Ls::files_size() const {
  return _internal_files_size();
}
inline void Ls::clear_files() {
  _impl_.files_.Clear();
}
inline ::sliverpb::FileInfo* Ls::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.Ls.Files)
  return _impl_.files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::FileInfo >*
Ls::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.Ls.Files)
  return &_impl_.files_;
}
inline const ::sliverpb::FileInfo& Ls::_internal_files(int index) const {
  return _impl_.files_.Get(index);
}
inline const ::sliverpb::FileInfo& Ls::files(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.Ls.Files)
  return _internal_files(index);
}
inline ::sliverpb::FileInfo* Ls::_internal_add_files() {
  return _impl_.files_.Add();
}
inline ::sliverpb::FileInfo* Ls::add_files() {
  ::sliverpb::FileInfo* _add = _internal_add_files();
  // @@protoc_insertion_point(field_add:sliverpb.Ls.Files)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::FileInfo >&
Ls::files() const {
  // @@protoc_insertion_point(field_list:sliverpb.Ls.Files)
  return _impl_.files_;
}

// string timezone = 4;
inline void Ls::clear_timezone() {
  _impl_.timezone_.ClearToEmpty();
}
inline const std::string& Ls::timezone() const {
  // @@protoc_insertion_point(field_get:sliverpb.Ls.timezone)
  return _internal_timezone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ls::set_timezone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.timezone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Ls.timezone)
}
inline std::string* Ls::mutable_timezone() {
  std::string* _s = _internal_mutable_timezone();
  // @@protoc_insertion_point(field_mutable:sliverpb.Ls.timezone)
  return _s;
}
inline const std::string& Ls::_internal_timezone() const {
  return _impl_.timezone_.Get();
}
inline void Ls::_internal_set_timezone(const std::string& value) {
  
  _impl_.timezone_.Set(value, GetArenaForAllocation());
}
inline std::string* Ls::_internal_mutable_timezone() {
  
  return _impl_.timezone_.Mutable(GetArenaForAllocation());
}
inline std::string* Ls::release_timezone() {
  // @@protoc_insertion_point(field_release:sliverpb.Ls.timezone)
  return _impl_.timezone_.Release();
}
inline void Ls::set_allocated_timezone(std::string* timezone) {
  if (timezone != nullptr) {
    
  } else {
    
  }
  _impl_.timezone_.SetAllocated(timezone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timezone_.IsDefault()) {
    _impl_.timezone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Ls.timezone)
}

// int32 timezoneOffset = 5;
inline void Ls::clear_timezoneoffset() {
  _impl_.timezoneoffset_ = 0;
}
inline int32_t Ls::_internal_timezoneoffset() const {
  return _impl_.timezoneoffset_;
}
inline int32_t Ls::timezoneoffset() const {
  // @@protoc_insertion_point(field_get:sliverpb.Ls.timezoneOffset)
  return _internal_timezoneoffset();
}
inline void Ls::_internal_set_timezoneoffset(int32_t value) {
  
  _impl_.timezoneoffset_ = value;
}
inline void Ls::set_timezoneoffset(int32_t value) {
  _internal_set_timezoneoffset(value);
  // @@protoc_insertion_point(field_set:sliverpb.Ls.timezoneOffset)
}

// .sliverpb.Response Response = 9;
inline bool Ls::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Ls::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Ls::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Ls::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Ls.Response)
  return _internal_response();
}
inline void Ls::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Ls.Response)
}
inline ::sliverpb::Response* Ls::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Ls::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Ls.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Ls::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Ls::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Ls.Response)
  return _msg;
}
inline void Ls::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Ls.Response)
}

// -------------------------------------------------------------------

// FileInfo

// string Name = 1;
inline void FileInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& FileInfo::name() const {
  // @@protoc_insertion_point(field_get:sliverpb.FileInfo.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.FileInfo.Name)
}
inline std::string* FileInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sliverpb.FileInfo.Name)
  return _s;
}
inline const std::string& FileInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void FileInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* FileInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* FileInfo::release_name() {
  // @@protoc_insertion_point(field_release:sliverpb.FileInfo.Name)
  return _impl_.name_.Release();
}
inline void FileInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.FileInfo.Name)
}

// bool IsDir = 2;
inline void FileInfo::clear_isdir() {
  _impl_.isdir_ = false;
}
inline bool FileInfo::_internal_isdir() const {
  return _impl_.isdir_;
}
inline bool FileInfo::isdir() const {
  // @@protoc_insertion_point(field_get:sliverpb.FileInfo.IsDir)
  return _internal_isdir();
}
inline void FileInfo::_internal_set_isdir(bool value) {
  
  _impl_.isdir_ = value;
}
inline void FileInfo::set_isdir(bool value) {
  _internal_set_isdir(value);
  // @@protoc_insertion_point(field_set:sliverpb.FileInfo.IsDir)
}

// int64 Size = 3;
inline void FileInfo::clear_size() {
  _impl_.size_ = int64_t{0};
}
inline int64_t FileInfo::_internal_size() const {
  return _impl_.size_;
}
inline int64_t FileInfo::size() const {
  // @@protoc_insertion_point(field_get:sliverpb.FileInfo.Size)
  return _internal_size();
}
inline void FileInfo::_internal_set_size(int64_t value) {
  
  _impl_.size_ = value;
}
inline void FileInfo::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:sliverpb.FileInfo.Size)
}

// int64 ModTime = 4;
inline void FileInfo::clear_modtime() {
  _impl_.modtime_ = int64_t{0};
}
inline int64_t FileInfo::_internal_modtime() const {
  return _impl_.modtime_;
}
inline int64_t FileInfo::modtime() const {
  // @@protoc_insertion_point(field_get:sliverpb.FileInfo.ModTime)
  return _internal_modtime();
}
inline void FileInfo::_internal_set_modtime(int64_t value) {
  
  _impl_.modtime_ = value;
}
inline void FileInfo::set_modtime(int64_t value) {
  _internal_set_modtime(value);
  // @@protoc_insertion_point(field_set:sliverpb.FileInfo.ModTime)
}

// string Mode = 5;
inline void FileInfo::clear_mode() {
  _impl_.mode_.ClearToEmpty();
}
inline const std::string& FileInfo::mode() const {
  // @@protoc_insertion_point(field_get:sliverpb.FileInfo.Mode)
  return _internal_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileInfo::set_mode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.FileInfo.Mode)
}
inline std::string* FileInfo::mutable_mode() {
  std::string* _s = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:sliverpb.FileInfo.Mode)
  return _s;
}
inline const std::string& FileInfo::_internal_mode() const {
  return _impl_.mode_.Get();
}
inline void FileInfo::_internal_set_mode(const std::string& value) {
  
  _impl_.mode_.Set(value, GetArenaForAllocation());
}
inline std::string* FileInfo::_internal_mutable_mode() {
  
  return _impl_.mode_.Mutable(GetArenaForAllocation());
}
inline std::string* FileInfo::release_mode() {
  // @@protoc_insertion_point(field_release:sliverpb.FileInfo.Mode)
  return _impl_.mode_.Release();
}
inline void FileInfo::set_allocated_mode(std::string* mode) {
  if (mode != nullptr) {
    
  } else {
    
  }
  _impl_.mode_.SetAllocated(mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mode_.IsDefault()) {
    _impl_.mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.FileInfo.Mode)
}

// string Link = 6;
inline void FileInfo::clear_link() {
  _impl_.link_.ClearToEmpty();
}
inline const std::string& FileInfo::link() const {
  // @@protoc_insertion_point(field_get:sliverpb.FileInfo.Link)
  return _internal_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileInfo::set_link(ArgT0&& arg0, ArgT... args) {
 
 _impl_.link_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.FileInfo.Link)
}
inline std::string* FileInfo::mutable_link() {
  std::string* _s = _internal_mutable_link();
  // @@protoc_insertion_point(field_mutable:sliverpb.FileInfo.Link)
  return _s;
}
inline const std::string& FileInfo::_internal_link() const {
  return _impl_.link_.Get();
}
inline void FileInfo::_internal_set_link(const std::string& value) {
  
  _impl_.link_.Set(value, GetArenaForAllocation());
}
inline std::string* FileInfo::_internal_mutable_link() {
  
  return _impl_.link_.Mutable(GetArenaForAllocation());
}
inline std::string* FileInfo::release_link() {
  // @@protoc_insertion_point(field_release:sliverpb.FileInfo.Link)
  return _impl_.link_.Release();
}
inline void FileInfo::set_allocated_link(std::string* link) {
  if (link != nullptr) {
    
  } else {
    
  }
  _impl_.link_.SetAllocated(link, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.link_.IsDefault()) {
    _impl_.link_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.FileInfo.Link)
}

// -------------------------------------------------------------------

// CdReq

// string Path = 1;
inline void CdReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& CdReq::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.CdReq.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CdReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.CdReq.Path)
}
inline std::string* CdReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.CdReq.Path)
  return _s;
}
inline const std::string& CdReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void CdReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* CdReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* CdReq::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.CdReq.Path)
  return _impl_.path_.Release();
}
inline void CdReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.CdReq.Path)
}

// .sliverpb.Request Request = 9;
inline bool CdReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool CdReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& CdReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& CdReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.CdReq.Request)
  return _internal_request();
}
inline void CdReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.CdReq.Request)
}
inline ::sliverpb::Request* CdReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* CdReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.CdReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* CdReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* CdReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.CdReq.Request)
  return _msg;
}
inline void CdReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.CdReq.Request)
}

// -------------------------------------------------------------------

// PwdReq

// .sliverpb.Request Request = 9;
inline bool PwdReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool PwdReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& PwdReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& PwdReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.PwdReq.Request)
  return _internal_request();
}
inline void PwdReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.PwdReq.Request)
}
inline ::sliverpb::Request* PwdReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* PwdReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.PwdReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* PwdReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* PwdReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.PwdReq.Request)
  return _msg;
}
inline void PwdReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PwdReq.Request)
}

// -------------------------------------------------------------------

// Pwd

// string Path = 1;
inline void Pwd::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& Pwd::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.Pwd.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pwd::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Pwd.Path)
}
inline std::string* Pwd::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.Pwd.Path)
  return _s;
}
inline const std::string& Pwd::_internal_path() const {
  return _impl_.path_.Get();
}
inline void Pwd::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* Pwd::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* Pwd::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.Pwd.Path)
  return _impl_.path_.Release();
}
inline void Pwd::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Pwd.Path)
}

// .sliverpb.Response Response = 9;
inline bool Pwd::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Pwd::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Pwd::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Pwd::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Pwd.Response)
  return _internal_response();
}
inline void Pwd::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Pwd.Response)
}
inline ::sliverpb::Response* Pwd::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Pwd::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Pwd.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Pwd::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Pwd::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Pwd.Response)
  return _msg;
}
inline void Pwd::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Pwd.Response)
}

// -------------------------------------------------------------------

// RmReq

// string Path = 1;
inline void RmReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& RmReq::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.RmReq.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RmReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RmReq.Path)
}
inline std::string* RmReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.RmReq.Path)
  return _s;
}
inline const std::string& RmReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void RmReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* RmReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* RmReq::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.RmReq.Path)
  return _impl_.path_.Release();
}
inline void RmReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RmReq.Path)
}

// bool Recursive = 2;
inline void RmReq::clear_recursive() {
  _impl_.recursive_ = false;
}
inline bool RmReq::_internal_recursive() const {
  return _impl_.recursive_;
}
inline bool RmReq::recursive() const {
  // @@protoc_insertion_point(field_get:sliverpb.RmReq.Recursive)
  return _internal_recursive();
}
inline void RmReq::_internal_set_recursive(bool value) {
  
  _impl_.recursive_ = value;
}
inline void RmReq::set_recursive(bool value) {
  _internal_set_recursive(value);
  // @@protoc_insertion_point(field_set:sliverpb.RmReq.Recursive)
}

// bool Force = 3;
inline void RmReq::clear_force() {
  _impl_.force_ = false;
}
inline bool RmReq::_internal_force() const {
  return _impl_.force_;
}
inline bool RmReq::force() const {
  // @@protoc_insertion_point(field_get:sliverpb.RmReq.Force)
  return _internal_force();
}
inline void RmReq::_internal_set_force(bool value) {
  
  _impl_.force_ = value;
}
inline void RmReq::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:sliverpb.RmReq.Force)
}

// .sliverpb.Request Request = 9;
inline bool RmReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool RmReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& RmReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& RmReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.RmReq.Request)
  return _internal_request();
}
inline void RmReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RmReq.Request)
}
inline ::sliverpb::Request* RmReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* RmReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.RmReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* RmReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* RmReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.RmReq.Request)
  return _msg;
}
inline void RmReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RmReq.Request)
}

// -------------------------------------------------------------------

// Rm

// string Path = 1;
inline void Rm::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& Rm::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.Rm.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Rm::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Rm.Path)
}
inline std::string* Rm::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.Rm.Path)
  return _s;
}
inline const std::string& Rm::_internal_path() const {
  return _impl_.path_.Get();
}
inline void Rm::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* Rm::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* Rm::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.Rm.Path)
  return _impl_.path_.Release();
}
inline void Rm::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Rm.Path)
}

// .sliverpb.Response Response = 9;
inline bool Rm::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Rm::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Rm::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Rm::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Rm.Response)
  return _internal_response();
}
inline void Rm::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Rm.Response)
}
inline ::sliverpb::Response* Rm::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Rm::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Rm.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Rm::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Rm::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Rm.Response)
  return _msg;
}
inline void Rm::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Rm.Response)
}

// -------------------------------------------------------------------

// MvReq

// string Src = 1;
inline void MvReq::clear_src() {
  _impl_.src_.ClearToEmpty();
}
inline const std::string& MvReq::src() const {
  // @@protoc_insertion_point(field_get:sliverpb.MvReq.Src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MvReq::set_src(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.MvReq.Src)
}
inline std::string* MvReq::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:sliverpb.MvReq.Src)
  return _s;
}
inline const std::string& MvReq::_internal_src() const {
  return _impl_.src_.Get();
}
inline void MvReq::_internal_set_src(const std::string& value) {
  
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* MvReq::_internal_mutable_src() {
  
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* MvReq::release_src() {
  // @@protoc_insertion_point(field_release:sliverpb.MvReq.Src)
  return _impl_.src_.Release();
}
inline void MvReq::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.MvReq.Src)
}

// string Dst = 2;
inline void MvReq::clear_dst() {
  _impl_.dst_.ClearToEmpty();
}
inline const std::string& MvReq::dst() const {
  // @@protoc_insertion_point(field_get:sliverpb.MvReq.Dst)
  return _internal_dst();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MvReq::set_dst(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dst_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.MvReq.Dst)
}
inline std::string* MvReq::mutable_dst() {
  std::string* _s = _internal_mutable_dst();
  // @@protoc_insertion_point(field_mutable:sliverpb.MvReq.Dst)
  return _s;
}
inline const std::string& MvReq::_internal_dst() const {
  return _impl_.dst_.Get();
}
inline void MvReq::_internal_set_dst(const std::string& value) {
  
  _impl_.dst_.Set(value, GetArenaForAllocation());
}
inline std::string* MvReq::_internal_mutable_dst() {
  
  return _impl_.dst_.Mutable(GetArenaForAllocation());
}
inline std::string* MvReq::release_dst() {
  // @@protoc_insertion_point(field_release:sliverpb.MvReq.Dst)
  return _impl_.dst_.Release();
}
inline void MvReq::set_allocated_dst(std::string* dst) {
  if (dst != nullptr) {
    
  } else {
    
  }
  _impl_.dst_.SetAllocated(dst, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dst_.IsDefault()) {
    _impl_.dst_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.MvReq.Dst)
}

// .sliverpb.Request Request = 9;
inline bool MvReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool MvReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& MvReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& MvReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.MvReq.Request)
  return _internal_request();
}
inline void MvReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.MvReq.Request)
}
inline ::sliverpb::Request* MvReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* MvReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.MvReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* MvReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* MvReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.MvReq.Request)
  return _msg;
}
inline void MvReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.MvReq.Request)
}

// -------------------------------------------------------------------

// Mv

// string Src = 1;
inline void Mv::clear_src() {
  _impl_.src_.ClearToEmpty();
}
inline const std::string& Mv::src() const {
  // @@protoc_insertion_point(field_get:sliverpb.Mv.Src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mv::set_src(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Mv.Src)
}
inline std::string* Mv::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:sliverpb.Mv.Src)
  return _s;
}
inline const std::string& Mv::_internal_src() const {
  return _impl_.src_.Get();
}
inline void Mv::_internal_set_src(const std::string& value) {
  
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* Mv::_internal_mutable_src() {
  
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* Mv::release_src() {
  // @@protoc_insertion_point(field_release:sliverpb.Mv.Src)
  return _impl_.src_.Release();
}
inline void Mv::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Mv.Src)
}

// string Dst = 2;
inline void Mv::clear_dst() {
  _impl_.dst_.ClearToEmpty();
}
inline const std::string& Mv::dst() const {
  // @@protoc_insertion_point(field_get:sliverpb.Mv.Dst)
  return _internal_dst();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mv::set_dst(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dst_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Mv.Dst)
}
inline std::string* Mv::mutable_dst() {
  std::string* _s = _internal_mutable_dst();
  // @@protoc_insertion_point(field_mutable:sliverpb.Mv.Dst)
  return _s;
}
inline const std::string& Mv::_internal_dst() const {
  return _impl_.dst_.Get();
}
inline void Mv::_internal_set_dst(const std::string& value) {
  
  _impl_.dst_.Set(value, GetArenaForAllocation());
}
inline std::string* Mv::_internal_mutable_dst() {
  
  return _impl_.dst_.Mutable(GetArenaForAllocation());
}
inline std::string* Mv::release_dst() {
  // @@protoc_insertion_point(field_release:sliverpb.Mv.Dst)
  return _impl_.dst_.Release();
}
inline void Mv::set_allocated_dst(std::string* dst) {
  if (dst != nullptr) {
    
  } else {
    
  }
  _impl_.dst_.SetAllocated(dst, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dst_.IsDefault()) {
    _impl_.dst_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Mv.Dst)
}

// .sliverpb.Response Response = 9;
inline bool Mv::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Mv::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Mv::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Mv::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Mv.Response)
  return _internal_response();
}
inline void Mv::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Mv.Response)
}
inline ::sliverpb::Response* Mv::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Mv::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Mv.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Mv::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Mv::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Mv.Response)
  return _msg;
}
inline void Mv::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Mv.Response)
}

// -------------------------------------------------------------------

// MkdirReq

// string Path = 1;
inline void MkdirReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& MkdirReq::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.MkdirReq.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MkdirReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.MkdirReq.Path)
}
inline std::string* MkdirReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.MkdirReq.Path)
  return _s;
}
inline const std::string& MkdirReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void MkdirReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* MkdirReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* MkdirReq::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.MkdirReq.Path)
  return _impl_.path_.Release();
}
inline void MkdirReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.MkdirReq.Path)
}

// .sliverpb.Request Request = 9;
inline bool MkdirReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool MkdirReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& MkdirReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& MkdirReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.MkdirReq.Request)
  return _internal_request();
}
inline void MkdirReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.MkdirReq.Request)
}
inline ::sliverpb::Request* MkdirReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* MkdirReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.MkdirReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* MkdirReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* MkdirReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.MkdirReq.Request)
  return _msg;
}
inline void MkdirReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.MkdirReq.Request)
}

// -------------------------------------------------------------------

// Mkdir

// string Path = 1;
inline void Mkdir::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& Mkdir::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.Mkdir.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mkdir::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Mkdir.Path)
}
inline std::string* Mkdir::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.Mkdir.Path)
  return _s;
}
inline const std::string& Mkdir::_internal_path() const {
  return _impl_.path_.Get();
}
inline void Mkdir::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* Mkdir::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* Mkdir::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.Mkdir.Path)
  return _impl_.path_.Release();
}
inline void Mkdir::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Mkdir.Path)
}

// .sliverpb.Response Response = 9;
inline bool Mkdir::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Mkdir::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Mkdir::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Mkdir::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Mkdir.Response)
  return _internal_response();
}
inline void Mkdir::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Mkdir.Response)
}
inline ::sliverpb::Response* Mkdir::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Mkdir::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Mkdir.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Mkdir::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Mkdir::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Mkdir.Response)
  return _msg;
}
inline void Mkdir::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Mkdir.Response)
}

// -------------------------------------------------------------------

// DownloadReq

// string Path = 1;
inline void DownloadReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& DownloadReq::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.DownloadReq.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.DownloadReq.Path)
}
inline std::string* DownloadReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.DownloadReq.Path)
  return _s;
}
inline const std::string& DownloadReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void DownloadReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* DownloadReq::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.DownloadReq.Path)
  return _impl_.path_.Release();
}
inline void DownloadReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.DownloadReq.Path)
}

// int64 Start = 2;
inline void DownloadReq::clear_start() {
  _impl_.start_ = int64_t{0};
}
inline int64_t DownloadReq::_internal_start() const {
  return _impl_.start_;
}
inline int64_t DownloadReq::start() const {
  // @@protoc_insertion_point(field_get:sliverpb.DownloadReq.Start)
  return _internal_start();
}
inline void DownloadReq::_internal_set_start(int64_t value) {
  
  _impl_.start_ = value;
}
inline void DownloadReq::set_start(int64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:sliverpb.DownloadReq.Start)
}

// int64 Stop = 3;
inline void DownloadReq::clear_stop() {
  _impl_.stop_ = int64_t{0};
}
inline int64_t DownloadReq::_internal_stop() const {
  return _impl_.stop_;
}
inline int64_t DownloadReq::stop() const {
  // @@protoc_insertion_point(field_get:sliverpb.DownloadReq.Stop)
  return _internal_stop();
}
inline void DownloadReq::_internal_set_stop(int64_t value) {
  
  _impl_.stop_ = value;
}
inline void DownloadReq::set_stop(int64_t value) {
  _internal_set_stop(value);
  // @@protoc_insertion_point(field_set:sliverpb.DownloadReq.Stop)
}

// bool Recurse = 4;
inline void DownloadReq::clear_recurse() {
  _impl_.recurse_ = false;
}
inline bool DownloadReq::_internal_recurse() const {
  return _impl_.recurse_;
}
inline bool DownloadReq::recurse() const {
  // @@protoc_insertion_point(field_get:sliverpb.DownloadReq.Recurse)
  return _internal_recurse();
}
inline void DownloadReq::_internal_set_recurse(bool value) {
  
  _impl_.recurse_ = value;
}
inline void DownloadReq::set_recurse(bool value) {
  _internal_set_recurse(value);
  // @@protoc_insertion_point(field_set:sliverpb.DownloadReq.Recurse)
}

// .sliverpb.Request Request = 9;
inline bool DownloadReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool DownloadReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& DownloadReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& DownloadReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.DownloadReq.Request)
  return _internal_request();
}
inline void DownloadReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.DownloadReq.Request)
}
inline ::sliverpb::Request* DownloadReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* DownloadReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.DownloadReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* DownloadReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* DownloadReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.DownloadReq.Request)
  return _msg;
}
inline void DownloadReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.DownloadReq.Request)
}

// -------------------------------------------------------------------

// Download

// string Path = 1;
inline void Download::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& Download::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.Download.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Download::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Download.Path)
}
inline std::string* Download::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.Download.Path)
  return _s;
}
inline const std::string& Download::_internal_path() const {
  return _impl_.path_.Get();
}
inline void Download::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* Download::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* Download::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.Download.Path)
  return _impl_.path_.Release();
}
inline void Download::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Download.Path)
}

// string Encoder = 2;
inline void Download::clear_encoder() {
  _impl_.encoder_.ClearToEmpty();
}
inline const std::string& Download::encoder() const {
  // @@protoc_insertion_point(field_get:sliverpb.Download.Encoder)
  return _internal_encoder();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Download::set_encoder(ArgT0&& arg0, ArgT... args) {
 
 _impl_.encoder_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Download.Encoder)
}
inline std::string* Download::mutable_encoder() {
  std::string* _s = _internal_mutable_encoder();
  // @@protoc_insertion_point(field_mutable:sliverpb.Download.Encoder)
  return _s;
}
inline const std::string& Download::_internal_encoder() const {
  return _impl_.encoder_.Get();
}
inline void Download::_internal_set_encoder(const std::string& value) {
  
  _impl_.encoder_.Set(value, GetArenaForAllocation());
}
inline std::string* Download::_internal_mutable_encoder() {
  
  return _impl_.encoder_.Mutable(GetArenaForAllocation());
}
inline std::string* Download::release_encoder() {
  // @@protoc_insertion_point(field_release:sliverpb.Download.Encoder)
  return _impl_.encoder_.Release();
}
inline void Download::set_allocated_encoder(std::string* encoder) {
  if (encoder != nullptr) {
    
  } else {
    
  }
  _impl_.encoder_.SetAllocated(encoder, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.encoder_.IsDefault()) {
    _impl_.encoder_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Download.Encoder)
}

// bool Exists = 3;
inline void Download::clear_exists() {
  _impl_.exists_ = false;
}
inline bool Download::_internal_exists() const {
  return _impl_.exists_;
}
inline bool Download::exists() const {
  // @@protoc_insertion_point(field_get:sliverpb.Download.Exists)
  return _internal_exists();
}
inline void Download::_internal_set_exists(bool value) {
  
  _impl_.exists_ = value;
}
inline void Download::set_exists(bool value) {
  _internal_set_exists(value);
  // @@protoc_insertion_point(field_set:sliverpb.Download.Exists)
}

// int64 Start = 4;
inline void Download::clear_start() {
  _impl_.start_ = int64_t{0};
}
inline int64_t Download::_internal_start() const {
  return _impl_.start_;
}
inline int64_t Download::start() const {
  // @@protoc_insertion_point(field_get:sliverpb.Download.Start)
  return _internal_start();
}
inline void Download::_internal_set_start(int64_t value) {
  
  _impl_.start_ = value;
}
inline void Download::set_start(int64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:sliverpb.Download.Start)
}

// int64 Stop = 5;
inline void Download::clear_stop() {
  _impl_.stop_ = int64_t{0};
}
inline int64_t Download::_internal_stop() const {
  return _impl_.stop_;
}
inline int64_t Download::stop() const {
  // @@protoc_insertion_point(field_get:sliverpb.Download.Stop)
  return _internal_stop();
}
inline void Download::_internal_set_stop(int64_t value) {
  
  _impl_.stop_ = value;
}
inline void Download::set_stop(int64_t value) {
  _internal_set_stop(value);
  // @@protoc_insertion_point(field_set:sliverpb.Download.Stop)
}

// bytes Data = 6;
inline void Download::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Download::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.Download.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Download::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Download.Data)
}
inline std::string* Download::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.Download.Data)
  return _s;
}
inline const std::string& Download::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Download::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Download::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Download::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.Download.Data)
  return _impl_.data_.Release();
}
inline void Download::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Download.Data)
}

// bool IsDir = 7;
inline void Download::clear_isdir() {
  _impl_.isdir_ = false;
}
inline bool Download::_internal_isdir() const {
  return _impl_.isdir_;
}
inline bool Download::isdir() const {
  // @@protoc_insertion_point(field_get:sliverpb.Download.IsDir)
  return _internal_isdir();
}
inline void Download::_internal_set_isdir(bool value) {
  
  _impl_.isdir_ = value;
}
inline void Download::set_isdir(bool value) {
  _internal_set_isdir(value);
  // @@protoc_insertion_point(field_set:sliverpb.Download.IsDir)
}

// int32 ReadFiles = 8;
inline void Download::clear_readfiles() {
  _impl_.readfiles_ = 0;
}
inline int32_t Download::_internal_readfiles() const {
  return _impl_.readfiles_;
}
inline int32_t Download::readfiles() const {
  // @@protoc_insertion_point(field_get:sliverpb.Download.ReadFiles)
  return _internal_readfiles();
}
inline void Download::_internal_set_readfiles(int32_t value) {
  
  _impl_.readfiles_ = value;
}
inline void Download::set_readfiles(int32_t value) {
  _internal_set_readfiles(value);
  // @@protoc_insertion_point(field_set:sliverpb.Download.ReadFiles)
}

// int32 UnreadableFiles = 10;
inline void Download::clear_unreadablefiles() {
  _impl_.unreadablefiles_ = 0;
}
inline int32_t Download::_internal_unreadablefiles() const {
  return _impl_.unreadablefiles_;
}
inline int32_t Download::unreadablefiles() const {
  // @@protoc_insertion_point(field_get:sliverpb.Download.UnreadableFiles)
  return _internal_unreadablefiles();
}
inline void Download::_internal_set_unreadablefiles(int32_t value) {
  
  _impl_.unreadablefiles_ = value;
}
inline void Download::set_unreadablefiles(int32_t value) {
  _internal_set_unreadablefiles(value);
  // @@protoc_insertion_point(field_set:sliverpb.Download.UnreadableFiles)
}

// .sliverpb.Response Response = 9;
inline bool Download::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Download::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Download::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Download::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Download.Response)
  return _internal_response();
}
inline void Download::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Download.Response)
}
inline ::sliverpb::Response* Download::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Download::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Download.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Download::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Download::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Download.Response)
  return _msg;
}
inline void Download::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Download.Response)
}

// -------------------------------------------------------------------

// UploadReq

// string Path = 1;
inline void UploadReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& UploadReq::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.UploadReq.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.UploadReq.Path)
}
inline std::string* UploadReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.UploadReq.Path)
  return _s;
}
inline const std::string& UploadReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void UploadReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadReq::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.UploadReq.Path)
  return _impl_.path_.Release();
}
inline void UploadReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.UploadReq.Path)
}

// string Encoder = 2;
inline void UploadReq::clear_encoder() {
  _impl_.encoder_.ClearToEmpty();
}
inline const std::string& UploadReq::encoder() const {
  // @@protoc_insertion_point(field_get:sliverpb.UploadReq.Encoder)
  return _internal_encoder();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadReq::set_encoder(ArgT0&& arg0, ArgT... args) {
 
 _impl_.encoder_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.UploadReq.Encoder)
}
inline std::string* UploadReq::mutable_encoder() {
  std::string* _s = _internal_mutable_encoder();
  // @@protoc_insertion_point(field_mutable:sliverpb.UploadReq.Encoder)
  return _s;
}
inline const std::string& UploadReq::_internal_encoder() const {
  return _impl_.encoder_.Get();
}
inline void UploadReq::_internal_set_encoder(const std::string& value) {
  
  _impl_.encoder_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadReq::_internal_mutable_encoder() {
  
  return _impl_.encoder_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadReq::release_encoder() {
  // @@protoc_insertion_point(field_release:sliverpb.UploadReq.Encoder)
  return _impl_.encoder_.Release();
}
inline void UploadReq::set_allocated_encoder(std::string* encoder) {
  if (encoder != nullptr) {
    
  } else {
    
  }
  _impl_.encoder_.SetAllocated(encoder, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.encoder_.IsDefault()) {
    _impl_.encoder_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.UploadReq.Encoder)
}

// bytes Data = 3;
inline void UploadReq::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& UploadReq::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.UploadReq.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadReq::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.UploadReq.Data)
}
inline std::string* UploadReq::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.UploadReq.Data)
  return _s;
}
inline const std::string& UploadReq::_internal_data() const {
  return _impl_.data_.Get();
}
inline void UploadReq::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadReq::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadReq::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.UploadReq.Data)
  return _impl_.data_.Release();
}
inline void UploadReq::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.UploadReq.Data)
}

// bool IsIOC = 4;
inline void UploadReq::clear_isioc() {
  _impl_.isioc_ = false;
}
inline bool UploadReq::_internal_isioc() const {
  return _impl_.isioc_;
}
inline bool UploadReq::isioc() const {
  // @@protoc_insertion_point(field_get:sliverpb.UploadReq.IsIOC)
  return _internal_isioc();
}
inline void UploadReq::_internal_set_isioc(bool value) {
  
  _impl_.isioc_ = value;
}
inline void UploadReq::set_isioc(bool value) {
  _internal_set_isioc(value);
  // @@protoc_insertion_point(field_set:sliverpb.UploadReq.IsIOC)
}

// .sliverpb.Request Request = 9;
inline bool UploadReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool UploadReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& UploadReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& UploadReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.UploadReq.Request)
  return _internal_request();
}
inline void UploadReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.UploadReq.Request)
}
inline ::sliverpb::Request* UploadReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* UploadReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.UploadReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* UploadReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* UploadReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.UploadReq.Request)
  return _msg;
}
inline void UploadReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.UploadReq.Request)
}

// -------------------------------------------------------------------

// Upload

// string Path = 1;
inline void Upload::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& Upload::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.Upload.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Upload::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Upload.Path)
}
inline std::string* Upload::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.Upload.Path)
  return _s;
}
inline const std::string& Upload::_internal_path() const {
  return _impl_.path_.Get();
}
inline void Upload::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* Upload::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* Upload::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.Upload.Path)
  return _impl_.path_.Release();
}
inline void Upload::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Upload.Path)
}

// .sliverpb.Response Response = 9;
inline bool Upload::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Upload::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Upload::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Upload::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Upload.Response)
  return _internal_response();
}
inline void Upload::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Upload.Response)
}
inline ::sliverpb::Response* Upload::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Upload::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Upload.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Upload::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Upload::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Upload.Response)
  return _msg;
}
inline void Upload::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Upload.Response)
}

// -------------------------------------------------------------------

// ProcessDumpReq

// int32 Pid = 1;
inline void ProcessDumpReq::clear_pid() {
  _impl_.pid_ = 0;
}
inline int32_t ProcessDumpReq::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t ProcessDumpReq::pid() const {
  // @@protoc_insertion_point(field_get:sliverpb.ProcessDumpReq.Pid)
  return _internal_pid();
}
inline void ProcessDumpReq::_internal_set_pid(int32_t value) {
  
  _impl_.pid_ = value;
}
inline void ProcessDumpReq::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:sliverpb.ProcessDumpReq.Pid)
}

// int32 Timeout = 2;
inline void ProcessDumpReq::clear_timeout() {
  _impl_.timeout_ = 0;
}
inline int32_t ProcessDumpReq::_internal_timeout() const {
  return _impl_.timeout_;
}
inline int32_t ProcessDumpReq::timeout() const {
  // @@protoc_insertion_point(field_get:sliverpb.ProcessDumpReq.Timeout)
  return _internal_timeout();
}
inline void ProcessDumpReq::_internal_set_timeout(int32_t value) {
  
  _impl_.timeout_ = value;
}
inline void ProcessDumpReq::set_timeout(int32_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:sliverpb.ProcessDumpReq.Timeout)
}

// .sliverpb.Request Request = 9;
inline bool ProcessDumpReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool ProcessDumpReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& ProcessDumpReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& ProcessDumpReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.ProcessDumpReq.Request)
  return _internal_request();
}
inline void ProcessDumpReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.ProcessDumpReq.Request)
}
inline ::sliverpb::Request* ProcessDumpReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* ProcessDumpReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.ProcessDumpReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* ProcessDumpReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* ProcessDumpReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.ProcessDumpReq.Request)
  return _msg;
}
inline void ProcessDumpReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ProcessDumpReq.Request)
}

// -------------------------------------------------------------------

// ProcessDump

// bytes Data = 1;
inline void ProcessDump::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ProcessDump::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.ProcessDump.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessDump::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ProcessDump.Data)
}
inline std::string* ProcessDump::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.ProcessDump.Data)
  return _s;
}
inline const std::string& ProcessDump::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ProcessDump::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessDump::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessDump::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.ProcessDump.Data)
  return _impl_.data_.Release();
}
inline void ProcessDump::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ProcessDump.Data)
}

// .sliverpb.Response Response = 9;
inline bool ProcessDump::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool ProcessDump::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& ProcessDump::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& ProcessDump::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.ProcessDump.Response)
  return _internal_response();
}
inline void ProcessDump::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.ProcessDump.Response)
}
inline ::sliverpb::Response* ProcessDump::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* ProcessDump::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.ProcessDump.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* ProcessDump::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* ProcessDump::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.ProcessDump.Response)
  return _msg;
}
inline void ProcessDump::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ProcessDump.Response)
}

// -------------------------------------------------------------------

// RunAsReq

// string Username = 1;
inline void RunAsReq::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& RunAsReq::username() const {
  // @@protoc_insertion_point(field_get:sliverpb.RunAsReq.Username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunAsReq::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RunAsReq.Username)
}
inline std::string* RunAsReq::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:sliverpb.RunAsReq.Username)
  return _s;
}
inline const std::string& RunAsReq::_internal_username() const {
  return _impl_.username_.Get();
}
inline void RunAsReq::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* RunAsReq::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* RunAsReq::release_username() {
  // @@protoc_insertion_point(field_release:sliverpb.RunAsReq.Username)
  return _impl_.username_.Release();
}
inline void RunAsReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RunAsReq.Username)
}

// string ProcessName = 2;
inline void RunAsReq::clear_processname() {
  _impl_.processname_.ClearToEmpty();
}
inline const std::string& RunAsReq::processname() const {
  // @@protoc_insertion_point(field_get:sliverpb.RunAsReq.ProcessName)
  return _internal_processname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunAsReq::set_processname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.processname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RunAsReq.ProcessName)
}
inline std::string* RunAsReq::mutable_processname() {
  std::string* _s = _internal_mutable_processname();
  // @@protoc_insertion_point(field_mutable:sliverpb.RunAsReq.ProcessName)
  return _s;
}
inline const std::string& RunAsReq::_internal_processname() const {
  return _impl_.processname_.Get();
}
inline void RunAsReq::_internal_set_processname(const std::string& value) {
  
  _impl_.processname_.Set(value, GetArenaForAllocation());
}
inline std::string* RunAsReq::_internal_mutable_processname() {
  
  return _impl_.processname_.Mutable(GetArenaForAllocation());
}
inline std::string* RunAsReq::release_processname() {
  // @@protoc_insertion_point(field_release:sliverpb.RunAsReq.ProcessName)
  return _impl_.processname_.Release();
}
inline void RunAsReq::set_allocated_processname(std::string* processname) {
  if (processname != nullptr) {
    
  } else {
    
  }
  _impl_.processname_.SetAllocated(processname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.processname_.IsDefault()) {
    _impl_.processname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RunAsReq.ProcessName)
}

// string Args = 3;
inline void RunAsReq::clear_args() {
  _impl_.args_.ClearToEmpty();
}
inline const std::string& RunAsReq::args() const {
  // @@protoc_insertion_point(field_get:sliverpb.RunAsReq.Args)
  return _internal_args();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunAsReq::set_args(ArgT0&& arg0, ArgT... args) {
 
 _impl_.args_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RunAsReq.Args)
}
inline std::string* RunAsReq::mutable_args() {
  std::string* _s = _internal_mutable_args();
  // @@protoc_insertion_point(field_mutable:sliverpb.RunAsReq.Args)
  return _s;
}
inline const std::string& RunAsReq::_internal_args() const {
  return _impl_.args_.Get();
}
inline void RunAsReq::_internal_set_args(const std::string& value) {
  
  _impl_.args_.Set(value, GetArenaForAllocation());
}
inline std::string* RunAsReq::_internal_mutable_args() {
  
  return _impl_.args_.Mutable(GetArenaForAllocation());
}
inline std::string* RunAsReq::release_args() {
  // @@protoc_insertion_point(field_release:sliverpb.RunAsReq.Args)
  return _impl_.args_.Release();
}
inline void RunAsReq::set_allocated_args(std::string* args) {
  if (args != nullptr) {
    
  } else {
    
  }
  _impl_.args_.SetAllocated(args, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.args_.IsDefault()) {
    _impl_.args_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RunAsReq.Args)
}

// string Domain = 4;
inline void RunAsReq::clear_domain() {
  _impl_.domain_.ClearToEmpty();
}
inline const std::string& RunAsReq::domain() const {
  // @@protoc_insertion_point(field_get:sliverpb.RunAsReq.Domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunAsReq::set_domain(ArgT0&& arg0, ArgT... args) {
 
 _impl_.domain_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RunAsReq.Domain)
}
inline std::string* RunAsReq::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:sliverpb.RunAsReq.Domain)
  return _s;
}
inline const std::string& RunAsReq::_internal_domain() const {
  return _impl_.domain_.Get();
}
inline void RunAsReq::_internal_set_domain(const std::string& value) {
  
  _impl_.domain_.Set(value, GetArenaForAllocation());
}
inline std::string* RunAsReq::_internal_mutable_domain() {
  
  return _impl_.domain_.Mutable(GetArenaForAllocation());
}
inline std::string* RunAsReq::release_domain() {
  // @@protoc_insertion_point(field_release:sliverpb.RunAsReq.Domain)
  return _impl_.domain_.Release();
}
inline void RunAsReq::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  _impl_.domain_.SetAllocated(domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.domain_.IsDefault()) {
    _impl_.domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RunAsReq.Domain)
}

// string Password = 5;
inline void RunAsReq::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& RunAsReq::password() const {
  // @@protoc_insertion_point(field_get:sliverpb.RunAsReq.Password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunAsReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RunAsReq.Password)
}
inline std::string* RunAsReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:sliverpb.RunAsReq.Password)
  return _s;
}
inline const std::string& RunAsReq::_internal_password() const {
  return _impl_.password_.Get();
}
inline void RunAsReq::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* RunAsReq::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* RunAsReq::release_password() {
  // @@protoc_insertion_point(field_release:sliverpb.RunAsReq.Password)
  return _impl_.password_.Release();
}
inline void RunAsReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RunAsReq.Password)
}

// bool HideWindow = 6;
inline void RunAsReq::clear_hidewindow() {
  _impl_.hidewindow_ = false;
}
inline bool RunAsReq::_internal_hidewindow() const {
  return _impl_.hidewindow_;
}
inline bool RunAsReq::hidewindow() const {
  // @@protoc_insertion_point(field_get:sliverpb.RunAsReq.HideWindow)
  return _internal_hidewindow();
}
inline void RunAsReq::_internal_set_hidewindow(bool value) {
  
  _impl_.hidewindow_ = value;
}
inline void RunAsReq::set_hidewindow(bool value) {
  _internal_set_hidewindow(value);
  // @@protoc_insertion_point(field_set:sliverpb.RunAsReq.HideWindow)
}

// bool NetOnly = 7;
inline void RunAsReq::clear_netonly() {
  _impl_.netonly_ = false;
}
inline bool RunAsReq::_internal_netonly() const {
  return _impl_.netonly_;
}
inline bool RunAsReq::netonly() const {
  // @@protoc_insertion_point(field_get:sliverpb.RunAsReq.NetOnly)
  return _internal_netonly();
}
inline void RunAsReq::_internal_set_netonly(bool value) {
  
  _impl_.netonly_ = value;
}
inline void RunAsReq::set_netonly(bool value) {
  _internal_set_netonly(value);
  // @@protoc_insertion_point(field_set:sliverpb.RunAsReq.NetOnly)
}

// .sliverpb.Request Request = 9;
inline bool RunAsReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool RunAsReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& RunAsReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& RunAsReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.RunAsReq.Request)
  return _internal_request();
}
inline void RunAsReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RunAsReq.Request)
}
inline ::sliverpb::Request* RunAsReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* RunAsReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.RunAsReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* RunAsReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* RunAsReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.RunAsReq.Request)
  return _msg;
}
inline void RunAsReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RunAsReq.Request)
}

// -------------------------------------------------------------------

// RunAs

// string Output = 1;
inline void RunAs::clear_output() {
  _impl_.output_.ClearToEmpty();
}
inline const std::string& RunAs::output() const {
  // @@protoc_insertion_point(field_get:sliverpb.RunAs.Output)
  return _internal_output();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunAs::set_output(ArgT0&& arg0, ArgT... args) {
 
 _impl_.output_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RunAs.Output)
}
inline std::string* RunAs::mutable_output() {
  std::string* _s = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:sliverpb.RunAs.Output)
  return _s;
}
inline const std::string& RunAs::_internal_output() const {
  return _impl_.output_.Get();
}
inline void RunAs::_internal_set_output(const std::string& value) {
  
  _impl_.output_.Set(value, GetArenaForAllocation());
}
inline std::string* RunAs::_internal_mutable_output() {
  
  return _impl_.output_.Mutable(GetArenaForAllocation());
}
inline std::string* RunAs::release_output() {
  // @@protoc_insertion_point(field_release:sliverpb.RunAs.Output)
  return _impl_.output_.Release();
}
inline void RunAs::set_allocated_output(std::string* output) {
  if (output != nullptr) {
    
  } else {
    
  }
  _impl_.output_.SetAllocated(output, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.output_.IsDefault()) {
    _impl_.output_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RunAs.Output)
}

// .sliverpb.Response Response = 9;
inline bool RunAs::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool RunAs::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& RunAs::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& RunAs::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.RunAs.Response)
  return _internal_response();
}
inline void RunAs::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RunAs.Response)
}
inline ::sliverpb::Response* RunAs::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* RunAs::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.RunAs.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* RunAs::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* RunAs::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.RunAs.Response)
  return _msg;
}
inline void RunAs::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RunAs.Response)
}

// -------------------------------------------------------------------

// ImpersonateReq

// string Username = 1;
inline void ImpersonateReq::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& ImpersonateReq::username() const {
  // @@protoc_insertion_point(field_get:sliverpb.ImpersonateReq.Username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImpersonateReq::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ImpersonateReq.Username)
}
inline std::string* ImpersonateReq::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:sliverpb.ImpersonateReq.Username)
  return _s;
}
inline const std::string& ImpersonateReq::_internal_username() const {
  return _impl_.username_.Get();
}
inline void ImpersonateReq::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* ImpersonateReq::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* ImpersonateReq::release_username() {
  // @@protoc_insertion_point(field_release:sliverpb.ImpersonateReq.Username)
  return _impl_.username_.Release();
}
inline void ImpersonateReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ImpersonateReq.Username)
}

// .sliverpb.Request Request = 9;
inline bool ImpersonateReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool ImpersonateReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& ImpersonateReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& ImpersonateReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.ImpersonateReq.Request)
  return _internal_request();
}
inline void ImpersonateReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.ImpersonateReq.Request)
}
inline ::sliverpb::Request* ImpersonateReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* ImpersonateReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.ImpersonateReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* ImpersonateReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* ImpersonateReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.ImpersonateReq.Request)
  return _msg;
}
inline void ImpersonateReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ImpersonateReq.Request)
}

// -------------------------------------------------------------------

// Impersonate

// .sliverpb.Response Response = 9;
inline bool Impersonate::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Impersonate::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Impersonate::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Impersonate::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Impersonate.Response)
  return _internal_response();
}
inline void Impersonate::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Impersonate.Response)
}
inline ::sliverpb::Response* Impersonate::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Impersonate::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Impersonate.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Impersonate::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Impersonate::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Impersonate.Response)
  return _msg;
}
inline void Impersonate::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Impersonate.Response)
}

// -------------------------------------------------------------------

// RevToSelfReq

// .sliverpb.Request Request = 9;
inline bool RevToSelfReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool RevToSelfReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& RevToSelfReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& RevToSelfReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.RevToSelfReq.Request)
  return _internal_request();
}
inline void RevToSelfReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RevToSelfReq.Request)
}
inline ::sliverpb::Request* RevToSelfReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* RevToSelfReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.RevToSelfReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* RevToSelfReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* RevToSelfReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.RevToSelfReq.Request)
  return _msg;
}
inline void RevToSelfReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RevToSelfReq.Request)
}

// -------------------------------------------------------------------

// RevToSelf

// .sliverpb.Response Response = 9;
inline bool RevToSelf::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool RevToSelf::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& RevToSelf::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& RevToSelf::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.RevToSelf.Response)
  return _internal_response();
}
inline void RevToSelf::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RevToSelf.Response)
}
inline ::sliverpb::Response* RevToSelf::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* RevToSelf::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.RevToSelf.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* RevToSelf::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* RevToSelf::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.RevToSelf.Response)
  return _msg;
}
inline void RevToSelf::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RevToSelf.Response)
}

// -------------------------------------------------------------------

// CurrentTokenOwnerReq

// .sliverpb.Request Request = 9;
inline bool CurrentTokenOwnerReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool CurrentTokenOwnerReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& CurrentTokenOwnerReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& CurrentTokenOwnerReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.CurrentTokenOwnerReq.Request)
  return _internal_request();
}
inline void CurrentTokenOwnerReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.CurrentTokenOwnerReq.Request)
}
inline ::sliverpb::Request* CurrentTokenOwnerReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* CurrentTokenOwnerReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.CurrentTokenOwnerReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* CurrentTokenOwnerReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* CurrentTokenOwnerReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.CurrentTokenOwnerReq.Request)
  return _msg;
}
inline void CurrentTokenOwnerReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.CurrentTokenOwnerReq.Request)
}

// -------------------------------------------------------------------

// CurrentTokenOwner

// string Output = 1;
inline void CurrentTokenOwner::clear_output() {
  _impl_.output_.ClearToEmpty();
}
inline const std::string& CurrentTokenOwner::output() const {
  // @@protoc_insertion_point(field_get:sliverpb.CurrentTokenOwner.Output)
  return _internal_output();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrentTokenOwner::set_output(ArgT0&& arg0, ArgT... args) {
 
 _impl_.output_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.CurrentTokenOwner.Output)
}
inline std::string* CurrentTokenOwner::mutable_output() {
  std::string* _s = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:sliverpb.CurrentTokenOwner.Output)
  return _s;
}
inline const std::string& CurrentTokenOwner::_internal_output() const {
  return _impl_.output_.Get();
}
inline void CurrentTokenOwner::_internal_set_output(const std::string& value) {
  
  _impl_.output_.Set(value, GetArenaForAllocation());
}
inline std::string* CurrentTokenOwner::_internal_mutable_output() {
  
  return _impl_.output_.Mutable(GetArenaForAllocation());
}
inline std::string* CurrentTokenOwner::release_output() {
  // @@protoc_insertion_point(field_release:sliverpb.CurrentTokenOwner.Output)
  return _impl_.output_.Release();
}
inline void CurrentTokenOwner::set_allocated_output(std::string* output) {
  if (output != nullptr) {
    
  } else {
    
  }
  _impl_.output_.SetAllocated(output, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.output_.IsDefault()) {
    _impl_.output_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.CurrentTokenOwner.Output)
}

// .sliverpb.Response Response = 9;
inline bool CurrentTokenOwner::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool CurrentTokenOwner::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& CurrentTokenOwner::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& CurrentTokenOwner::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.CurrentTokenOwner.Response)
  return _internal_response();
}
inline void CurrentTokenOwner::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.CurrentTokenOwner.Response)
}
inline ::sliverpb::Response* CurrentTokenOwner::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* CurrentTokenOwner::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.CurrentTokenOwner.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* CurrentTokenOwner::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* CurrentTokenOwner::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.CurrentTokenOwner.Response)
  return _msg;
}
inline void CurrentTokenOwner::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.CurrentTokenOwner.Response)
}

// -------------------------------------------------------------------

// InvokeGetSystemReq

// bytes Data = 1;
inline void InvokeGetSystemReq::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& InvokeGetSystemReq::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeGetSystemReq.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeGetSystemReq::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.InvokeGetSystemReq.Data)
}
inline std::string* InvokeGetSystemReq::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeGetSystemReq.Data)
  return _s;
}
inline const std::string& InvokeGetSystemReq::_internal_data() const {
  return _impl_.data_.Get();
}
inline void InvokeGetSystemReq::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeGetSystemReq::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeGetSystemReq::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.InvokeGetSystemReq.Data)
  return _impl_.data_.Release();
}
inline void InvokeGetSystemReq::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.InvokeGetSystemReq.Data)
}

// string HostingProcess = 2;
inline void InvokeGetSystemReq::clear_hostingprocess() {
  _impl_.hostingprocess_.ClearToEmpty();
}
inline const std::string& InvokeGetSystemReq::hostingprocess() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeGetSystemReq.HostingProcess)
  return _internal_hostingprocess();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeGetSystemReq::set_hostingprocess(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostingprocess_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.InvokeGetSystemReq.HostingProcess)
}
inline std::string* InvokeGetSystemReq::mutable_hostingprocess() {
  std::string* _s = _internal_mutable_hostingprocess();
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeGetSystemReq.HostingProcess)
  return _s;
}
inline const std::string& InvokeGetSystemReq::_internal_hostingprocess() const {
  return _impl_.hostingprocess_.Get();
}
inline void InvokeGetSystemReq::_internal_set_hostingprocess(const std::string& value) {
  
  _impl_.hostingprocess_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeGetSystemReq::_internal_mutable_hostingprocess() {
  
  return _impl_.hostingprocess_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeGetSystemReq::release_hostingprocess() {
  // @@protoc_insertion_point(field_release:sliverpb.InvokeGetSystemReq.HostingProcess)
  return _impl_.hostingprocess_.Release();
}
inline void InvokeGetSystemReq::set_allocated_hostingprocess(std::string* hostingprocess) {
  if (hostingprocess != nullptr) {
    
  } else {
    
  }
  _impl_.hostingprocess_.SetAllocated(hostingprocess, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostingprocess_.IsDefault()) {
    _impl_.hostingprocess_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.InvokeGetSystemReq.HostingProcess)
}

// .sliverpb.Request Request = 9;
inline bool InvokeGetSystemReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool InvokeGetSystemReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& InvokeGetSystemReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& InvokeGetSystemReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeGetSystemReq.Request)
  return _internal_request();
}
inline void InvokeGetSystemReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.InvokeGetSystemReq.Request)
}
inline ::sliverpb::Request* InvokeGetSystemReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* InvokeGetSystemReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.InvokeGetSystemReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* InvokeGetSystemReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* InvokeGetSystemReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeGetSystemReq.Request)
  return _msg;
}
inline void InvokeGetSystemReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.InvokeGetSystemReq.Request)
}

// -------------------------------------------------------------------

// GetSystem

// .sliverpb.Response Response = 9;
inline bool GetSystem::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool GetSystem::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& GetSystem::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& GetSystem::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.GetSystem.Response)
  return _internal_response();
}
inline void GetSystem::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.GetSystem.Response)
}
inline ::sliverpb::Response* GetSystem::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* GetSystem::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.GetSystem.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* GetSystem::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* GetSystem::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.GetSystem.Response)
  return _msg;
}
inline void GetSystem::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.GetSystem.Response)
}

// -------------------------------------------------------------------

// MakeTokenReq

// string Username = 1;
inline void MakeTokenReq::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& MakeTokenReq::username() const {
  // @@protoc_insertion_point(field_get:sliverpb.MakeTokenReq.Username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MakeTokenReq::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.MakeTokenReq.Username)
}
inline std::string* MakeTokenReq::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:sliverpb.MakeTokenReq.Username)
  return _s;
}
inline const std::string& MakeTokenReq::_internal_username() const {
  return _impl_.username_.Get();
}
inline void MakeTokenReq::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* MakeTokenReq::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* MakeTokenReq::release_username() {
  // @@protoc_insertion_point(field_release:sliverpb.MakeTokenReq.Username)
  return _impl_.username_.Release();
}
inline void MakeTokenReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.MakeTokenReq.Username)
}

// string Password = 2;
inline void MakeTokenReq::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& MakeTokenReq::password() const {
  // @@protoc_insertion_point(field_get:sliverpb.MakeTokenReq.Password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MakeTokenReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.MakeTokenReq.Password)
}
inline std::string* MakeTokenReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:sliverpb.MakeTokenReq.Password)
  return _s;
}
inline const std::string& MakeTokenReq::_internal_password() const {
  return _impl_.password_.Get();
}
inline void MakeTokenReq::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* MakeTokenReq::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* MakeTokenReq::release_password() {
  // @@protoc_insertion_point(field_release:sliverpb.MakeTokenReq.Password)
  return _impl_.password_.Release();
}
inline void MakeTokenReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.MakeTokenReq.Password)
}

// string Domain = 3;
inline void MakeTokenReq::clear_domain() {
  _impl_.domain_.ClearToEmpty();
}
inline const std::string& MakeTokenReq::domain() const {
  // @@protoc_insertion_point(field_get:sliverpb.MakeTokenReq.Domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MakeTokenReq::set_domain(ArgT0&& arg0, ArgT... args) {
 
 _impl_.domain_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.MakeTokenReq.Domain)
}
inline std::string* MakeTokenReq::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:sliverpb.MakeTokenReq.Domain)
  return _s;
}
inline const std::string& MakeTokenReq::_internal_domain() const {
  return _impl_.domain_.Get();
}
inline void MakeTokenReq::_internal_set_domain(const std::string& value) {
  
  _impl_.domain_.Set(value, GetArenaForAllocation());
}
inline std::string* MakeTokenReq::_internal_mutable_domain() {
  
  return _impl_.domain_.Mutable(GetArenaForAllocation());
}
inline std::string* MakeTokenReq::release_domain() {
  // @@protoc_insertion_point(field_release:sliverpb.MakeTokenReq.Domain)
  return _impl_.domain_.Release();
}
inline void MakeTokenReq::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  _impl_.domain_.SetAllocated(domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.domain_.IsDefault()) {
    _impl_.domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.MakeTokenReq.Domain)
}

// uint32 LogonType = 4;
inline void MakeTokenReq::clear_logontype() {
  _impl_.logontype_ = 0u;
}
inline uint32_t MakeTokenReq::_internal_logontype() const {
  return _impl_.logontype_;
}
inline uint32_t MakeTokenReq::logontype() const {
  // @@protoc_insertion_point(field_get:sliverpb.MakeTokenReq.LogonType)
  return _internal_logontype();
}
inline void MakeTokenReq::_internal_set_logontype(uint32_t value) {
  
  _impl_.logontype_ = value;
}
inline void MakeTokenReq::set_logontype(uint32_t value) {
  _internal_set_logontype(value);
  // @@protoc_insertion_point(field_set:sliverpb.MakeTokenReq.LogonType)
}

// .sliverpb.Request Request = 9;
inline bool MakeTokenReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool MakeTokenReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& MakeTokenReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& MakeTokenReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.MakeTokenReq.Request)
  return _internal_request();
}
inline void MakeTokenReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.MakeTokenReq.Request)
}
inline ::sliverpb::Request* MakeTokenReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* MakeTokenReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.MakeTokenReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* MakeTokenReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* MakeTokenReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.MakeTokenReq.Request)
  return _msg;
}
inline void MakeTokenReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.MakeTokenReq.Request)
}

// -------------------------------------------------------------------

// MakeToken

// .sliverpb.Response Response = 9;
inline bool MakeToken::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool MakeToken::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& MakeToken::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& MakeToken::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.MakeToken.Response)
  return _internal_response();
}
inline void MakeToken::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.MakeToken.Response)
}
inline ::sliverpb::Response* MakeToken::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* MakeToken::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.MakeToken.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* MakeToken::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* MakeToken::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.MakeToken.Response)
  return _msg;
}
inline void MakeToken::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.MakeToken.Response)
}

// -------------------------------------------------------------------

// Token

// int64 TokenId = 1;
inline void Token::clear_tokenid() {
  _impl_.tokenid_ = int64_t{0};
}
inline int64_t Token::_internal_tokenid() const {
  return _impl_.tokenid_;
}
inline int64_t Token::tokenid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Token.TokenId)
  return _internal_tokenid();
}
inline void Token::_internal_set_tokenid(int64_t value) {
  
  _impl_.tokenid_ = value;
}
inline void Token::set_tokenid(int64_t value) {
  _internal_set_tokenid(value);
  // @@protoc_insertion_point(field_set:sliverpb.Token.TokenId)
}

// int64 LogonSessionId = 2;
inline void Token::clear_logonsessionid() {
  _impl_.logonsessionid_ = int64_t{0};
}
inline int64_t Token::_internal_logonsessionid() const {
  return _impl_.logonsessionid_;
}
inline int64_t Token::logonsessionid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Token.LogonSessionId)
  return _internal_logonsessionid();
}
inline void Token::_internal_set_logonsessionid(int64_t value) {
  
  _impl_.logonsessionid_ = value;
}
inline void Token::set_logonsessionid(int64_t value) {
  _internal_set_logonsessionid(value);
  // @@protoc_insertion_point(field_set:sliverpb.Token.LogonSessionId)
}

// int32 LogonType = 3;
inline void Token::clear_logontype() {
  _impl_.logontype_ = 0;
}
inline int32_t Token::_internal_logontype() const {
  return _impl_.logontype_;
}
inline int32_t Token::logontype() const {
  // @@protoc_insertion_point(field_get:sliverpb.Token.LogonType)
  return _internal_logontype();
}
inline void Token::_internal_set_logontype(int32_t value) {
  
  _impl_.logontype_ = value;
}
inline void Token::set_logontype(int32_t value) {
  _internal_set_logontype(value);
  // @@protoc_insertion_point(field_set:sliverpb.Token.LogonType)
}

// string Username = 4;
inline void Token::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& Token::username() const {
  // @@protoc_insertion_point(field_get:sliverpb.Token.Username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Token::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Token.Username)
}
inline std::string* Token::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:sliverpb.Token.Username)
  return _s;
}
inline const std::string& Token::_internal_username() const {
  return _impl_.username_.Get();
}
inline void Token::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* Token::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* Token::release_username() {
  // @@protoc_insertion_point(field_release:sliverpb.Token.Username)
  return _impl_.username_.Release();
}
inline void Token::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Token.Username)
}

// int32 TokenType = 5;
inline void Token::clear_tokentype() {
  _impl_.tokentype_ = 0;
}
inline int32_t Token::_internal_tokentype() const {
  return _impl_.tokentype_;
}
inline int32_t Token::tokentype() const {
  // @@protoc_insertion_point(field_get:sliverpb.Token.TokenType)
  return _internal_tokentype();
}
inline void Token::_internal_set_tokentype(int32_t value) {
  
  _impl_.tokentype_ = value;
}
inline void Token::set_tokentype(int32_t value) {
  _internal_set_tokentype(value);
  // @@protoc_insertion_point(field_set:sliverpb.Token.TokenType)
}

// int32 TokenImpLevel = 6;
inline void Token::clear_tokenimplevel() {
  _impl_.tokenimplevel_ = 0;
}
inline int32_t Token::_internal_tokenimplevel() const {
  return _impl_.tokenimplevel_;
}
inline int32_t Token::tokenimplevel() const {
  // @@protoc_insertion_point(field_get:sliverpb.Token.TokenImpLevel)
  return _internal_tokenimplevel();
}
inline void Token::_internal_set_tokenimplevel(int32_t value) {
  
  _impl_.tokenimplevel_ = value;
}
inline void Token::set_tokenimplevel(int32_t value) {
  _internal_set_tokenimplevel(value);
  // @@protoc_insertion_point(field_set:sliverpb.Token.TokenImpLevel)
}

// int32 PrivilegesCount = 7;
inline void Token::clear_privilegescount() {
  _impl_.privilegescount_ = 0;
}
inline int32_t Token::_internal_privilegescount() const {
  return _impl_.privilegescount_;
}
inline int32_t Token::privilegescount() const {
  // @@protoc_insertion_point(field_get:sliverpb.Token.PrivilegesCount)
  return _internal_privilegescount();
}
inline void Token::_internal_set_privilegescount(int32_t value) {
  
  _impl_.privilegescount_ = value;
}
inline void Token::set_privilegescount(int32_t value) {
  _internal_set_privilegescount(value);
  // @@protoc_insertion_point(field_set:sliverpb.Token.PrivilegesCount)
}

// int32 TokenIntegrity = 8;
inline void Token::clear_tokenintegrity() {
  _impl_.tokenintegrity_ = 0;
}
inline int32_t Token::_internal_tokenintegrity() const {
  return _impl_.tokenintegrity_;
}
inline int32_t Token::tokenintegrity() const {
  // @@protoc_insertion_point(field_get:sliverpb.Token.TokenIntegrity)
  return _internal_tokenintegrity();
}
inline void Token::_internal_set_tokenintegrity(int32_t value) {
  
  _impl_.tokenintegrity_ = value;
}
inline void Token::set_tokenintegrity(int32_t value) {
  _internal_set_tokenintegrity(value);
  // @@protoc_insertion_point(field_set:sliverpb.Token.TokenIntegrity)
}

// -------------------------------------------------------------------

// ListTokensReq

// .sliverpb.Request Request = 9;
inline bool ListTokensReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool ListTokensReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& ListTokensReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& ListTokensReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.ListTokensReq.Request)
  return _internal_request();
}
inline void ListTokensReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.ListTokensReq.Request)
}
inline ::sliverpb::Request* ListTokensReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* ListTokensReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.ListTokensReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* ListTokensReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* ListTokensReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.ListTokensReq.Request)
  return _msg;
}
inline void ListTokensReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ListTokensReq.Request)
}

// -------------------------------------------------------------------

// ListTokens

// repeated .sliverpb.Token Tokens = 1;
inline int ListTokens::_internal_tokens_size() const {
  return _impl_.tokens_.size();
}
inline int ListTokens::tokens_size() const {
  return _internal_tokens_size();
}
inline void ListTokens::clear_tokens() {
  _impl_.tokens_.Clear();
}
inline ::sliverpb::Token* ListTokens::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.ListTokens.Tokens)
  return _impl_.tokens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::Token >*
ListTokens::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.ListTokens.Tokens)
  return &_impl_.tokens_;
}
inline const ::sliverpb::Token& ListTokens::_internal_tokens(int index) const {
  return _impl_.tokens_.Get(index);
}
inline const ::sliverpb::Token& ListTokens::tokens(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.ListTokens.Tokens)
  return _internal_tokens(index);
}
inline ::sliverpb::Token* ListTokens::_internal_add_tokens() {
  return _impl_.tokens_.Add();
}
inline ::sliverpb::Token* ListTokens::add_tokens() {
  ::sliverpb::Token* _add = _internal_add_tokens();
  // @@protoc_insertion_point(field_add:sliverpb.ListTokens.Tokens)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::Token >&
ListTokens::tokens() const {
  // @@protoc_insertion_point(field_list:sliverpb.ListTokens.Tokens)
  return _impl_.tokens_;
}

// .sliverpb.Response Response = 9;
inline bool ListTokens::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool ListTokens::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& ListTokens::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& ListTokens::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.ListTokens.Response)
  return _internal_response();
}
inline void ListTokens::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.ListTokens.Response)
}
inline ::sliverpb::Response* ListTokens::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* ListTokens::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.ListTokens.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* ListTokens::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* ListTokens::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.ListTokens.Response)
  return _msg;
}
inline void ListTokens::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ListTokens.Response)
}

// -------------------------------------------------------------------

// TaskReq

// string Encoder = 1;
inline void TaskReq::clear_encoder() {
  _impl_.encoder_.ClearToEmpty();
}
inline const std::string& TaskReq::encoder() const {
  // @@protoc_insertion_point(field_get:sliverpb.TaskReq.Encoder)
  return _internal_encoder();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskReq::set_encoder(ArgT0&& arg0, ArgT... args) {
 
 _impl_.encoder_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.TaskReq.Encoder)
}
inline std::string* TaskReq::mutable_encoder() {
  std::string* _s = _internal_mutable_encoder();
  // @@protoc_insertion_point(field_mutable:sliverpb.TaskReq.Encoder)
  return _s;
}
inline const std::string& TaskReq::_internal_encoder() const {
  return _impl_.encoder_.Get();
}
inline void TaskReq::_internal_set_encoder(const std::string& value) {
  
  _impl_.encoder_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskReq::_internal_mutable_encoder() {
  
  return _impl_.encoder_.Mutable(GetArenaForAllocation());
}
inline std::string* TaskReq::release_encoder() {
  // @@protoc_insertion_point(field_release:sliverpb.TaskReq.Encoder)
  return _impl_.encoder_.Release();
}
inline void TaskReq::set_allocated_encoder(std::string* encoder) {
  if (encoder != nullptr) {
    
  } else {
    
  }
  _impl_.encoder_.SetAllocated(encoder, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.encoder_.IsDefault()) {
    _impl_.encoder_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.TaskReq.Encoder)
}

// bool RWXPages = 2;
inline void TaskReq::clear_rwxpages() {
  _impl_.rwxpages_ = false;
}
inline bool TaskReq::_internal_rwxpages() const {
  return _impl_.rwxpages_;
}
inline bool TaskReq::rwxpages() const {
  // @@protoc_insertion_point(field_get:sliverpb.TaskReq.RWXPages)
  return _internal_rwxpages();
}
inline void TaskReq::_internal_set_rwxpages(bool value) {
  
  _impl_.rwxpages_ = value;
}
inline void TaskReq::set_rwxpages(bool value) {
  _internal_set_rwxpages(value);
  // @@protoc_insertion_point(field_set:sliverpb.TaskReq.RWXPages)
}

// uint32 Pid = 3;
inline void TaskReq::clear_pid() {
  _impl_.pid_ = 0u;
}
inline uint32_t TaskReq::_internal_pid() const {
  return _impl_.pid_;
}
inline uint32_t TaskReq::pid() const {
  // @@protoc_insertion_point(field_get:sliverpb.TaskReq.Pid)
  return _internal_pid();
}
inline void TaskReq::_internal_set_pid(uint32_t value) {
  
  _impl_.pid_ = value;
}
inline void TaskReq::set_pid(uint32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:sliverpb.TaskReq.Pid)
}

// bytes Data = 4;
inline void TaskReq::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& TaskReq::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.TaskReq.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskReq::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.TaskReq.Data)
}
inline std::string* TaskReq::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.TaskReq.Data)
  return _s;
}
inline const std::string& TaskReq::_internal_data() const {
  return _impl_.data_.Get();
}
inline void TaskReq::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskReq::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* TaskReq::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.TaskReq.Data)
  return _impl_.data_.Release();
}
inline void TaskReq::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.TaskReq.Data)
}

// .sliverpb.Request Request = 9;
inline bool TaskReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool TaskReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& TaskReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& TaskReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.TaskReq.Request)
  return _internal_request();
}
inline void TaskReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.TaskReq.Request)
}
inline ::sliverpb::Request* TaskReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* TaskReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.TaskReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* TaskReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* TaskReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.TaskReq.Request)
  return _msg;
}
inline void TaskReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.TaskReq.Request)
}

// -------------------------------------------------------------------

// Task

// .sliverpb.Response Response = 9;
inline bool Task::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Task::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Task::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Task::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Task.Response)
  return _internal_response();
}
inline void Task::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Task.Response)
}
inline ::sliverpb::Response* Task::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Task::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Task.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Task::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Task::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Task.Response)
  return _msg;
}
inline void Task::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Task.Response)
}

// -------------------------------------------------------------------

// ExecuteAssemblyReq

// bytes Assembly = 1;
inline void ExecuteAssemblyReq::clear_assembly() {
  _impl_.assembly_.ClearToEmpty();
}
inline const std::string& ExecuteAssemblyReq::assembly() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteAssemblyReq.Assembly)
  return _internal_assembly();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteAssemblyReq::set_assembly(ArgT0&& arg0, ArgT... args) {
 
 _impl_.assembly_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteAssemblyReq.Assembly)
}
inline std::string* ExecuteAssemblyReq::mutable_assembly() {
  std::string* _s = _internal_mutable_assembly();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteAssemblyReq.Assembly)
  return _s;
}
inline const std::string& ExecuteAssemblyReq::_internal_assembly() const {
  return _impl_.assembly_.Get();
}
inline void ExecuteAssemblyReq::_internal_set_assembly(const std::string& value) {
  
  _impl_.assembly_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteAssemblyReq::_internal_mutable_assembly() {
  
  return _impl_.assembly_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteAssemblyReq::release_assembly() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteAssemblyReq.Assembly)
  return _impl_.assembly_.Release();
}
inline void ExecuteAssemblyReq::set_allocated_assembly(std::string* assembly) {
  if (assembly != nullptr) {
    
  } else {
    
  }
  _impl_.assembly_.SetAllocated(assembly, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.assembly_.IsDefault()) {
    _impl_.assembly_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteAssemblyReq.Assembly)
}

// string Arguments = 2;
inline void ExecuteAssemblyReq::clear_arguments() {
  _impl_.arguments_.ClearToEmpty();
}
inline const std::string& ExecuteAssemblyReq::arguments() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteAssemblyReq.Arguments)
  return _internal_arguments();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteAssemblyReq::set_arguments(ArgT0&& arg0, ArgT... args) {
 
 _impl_.arguments_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteAssemblyReq.Arguments)
}
inline std::string* ExecuteAssemblyReq::mutable_arguments() {
  std::string* _s = _internal_mutable_arguments();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteAssemblyReq.Arguments)
  return _s;
}
inline const std::string& ExecuteAssemblyReq::_internal_arguments() const {
  return _impl_.arguments_.Get();
}
inline void ExecuteAssemblyReq::_internal_set_arguments(const std::string& value) {
  
  _impl_.arguments_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteAssemblyReq::_internal_mutable_arguments() {
  
  return _impl_.arguments_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteAssemblyReq::release_arguments() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteAssemblyReq.Arguments)
  return _impl_.arguments_.Release();
}
inline void ExecuteAssemblyReq::set_allocated_arguments(std::string* arguments) {
  if (arguments != nullptr) {
    
  } else {
    
  }
  _impl_.arguments_.SetAllocated(arguments, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.arguments_.IsDefault()) {
    _impl_.arguments_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteAssemblyReq.Arguments)
}

// string Process = 3;
inline void ExecuteAssemblyReq::clear_process() {
  _impl_.process_.ClearToEmpty();
}
inline const std::string& ExecuteAssemblyReq::process() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteAssemblyReq.Process)
  return _internal_process();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteAssemblyReq::set_process(ArgT0&& arg0, ArgT... args) {
 
 _impl_.process_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteAssemblyReq.Process)
}
inline std::string* ExecuteAssemblyReq::mutable_process() {
  std::string* _s = _internal_mutable_process();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteAssemblyReq.Process)
  return _s;
}
inline const std::string& ExecuteAssemblyReq::_internal_process() const {
  return _impl_.process_.Get();
}
inline void ExecuteAssemblyReq::_internal_set_process(const std::string& value) {
  
  _impl_.process_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteAssemblyReq::_internal_mutable_process() {
  
  return _impl_.process_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteAssemblyReq::release_process() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteAssemblyReq.Process)
  return _impl_.process_.Release();
}
inline void ExecuteAssemblyReq::set_allocated_process(std::string* process) {
  if (process != nullptr) {
    
  } else {
    
  }
  _impl_.process_.SetAllocated(process, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.process_.IsDefault()) {
    _impl_.process_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteAssemblyReq.Process)
}

// bool IsDLL = 4;
inline void ExecuteAssemblyReq::clear_isdll() {
  _impl_.isdll_ = false;
}
inline bool ExecuteAssemblyReq::_internal_isdll() const {
  return _impl_.isdll_;
}
inline bool ExecuteAssemblyReq::isdll() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteAssemblyReq.IsDLL)
  return _internal_isdll();
}
inline void ExecuteAssemblyReq::_internal_set_isdll(bool value) {
  
  _impl_.isdll_ = value;
}
inline void ExecuteAssemblyReq::set_isdll(bool value) {
  _internal_set_isdll(value);
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteAssemblyReq.IsDLL)
}

// string Arch = 5;
inline void ExecuteAssemblyReq::clear_arch() {
  _impl_.arch_.ClearToEmpty();
}
inline const std::string& ExecuteAssemblyReq::arch() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteAssemblyReq.Arch)
  return _internal_arch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteAssemblyReq::set_arch(ArgT0&& arg0, ArgT... args) {
 
 _impl_.arch_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteAssemblyReq.Arch)
}
inline std::string* ExecuteAssemblyReq::mutable_arch() {
  std::string* _s = _internal_mutable_arch();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteAssemblyReq.Arch)
  return _s;
}
inline const std::string& ExecuteAssemblyReq::_internal_arch() const {
  return _impl_.arch_.Get();
}
inline void ExecuteAssemblyReq::_internal_set_arch(const std::string& value) {
  
  _impl_.arch_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteAssemblyReq::_internal_mutable_arch() {
  
  return _impl_.arch_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteAssemblyReq::release_arch() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteAssemblyReq.Arch)
  return _impl_.arch_.Release();
}
inline void ExecuteAssemblyReq::set_allocated_arch(std::string* arch) {
  if (arch != nullptr) {
    
  } else {
    
  }
  _impl_.arch_.SetAllocated(arch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.arch_.IsDefault()) {
    _impl_.arch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteAssemblyReq.Arch)
}

// string ClassName = 6;
inline void ExecuteAssemblyReq::clear_classname() {
  _impl_.classname_.ClearToEmpty();
}
inline const std::string& ExecuteAssemblyReq::classname() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteAssemblyReq.ClassName)
  return _internal_classname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteAssemblyReq::set_classname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.classname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteAssemblyReq.ClassName)
}
inline std::string* ExecuteAssemblyReq::mutable_classname() {
  std::string* _s = _internal_mutable_classname();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteAssemblyReq.ClassName)
  return _s;
}
inline const std::string& ExecuteAssemblyReq::_internal_classname() const {
  return _impl_.classname_.Get();
}
inline void ExecuteAssemblyReq::_internal_set_classname(const std::string& value) {
  
  _impl_.classname_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteAssemblyReq::_internal_mutable_classname() {
  
  return _impl_.classname_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteAssemblyReq::release_classname() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteAssemblyReq.ClassName)
  return _impl_.classname_.Release();
}
inline void ExecuteAssemblyReq::set_allocated_classname(std::string* classname) {
  if (classname != nullptr) {
    
  } else {
    
  }
  _impl_.classname_.SetAllocated(classname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.classname_.IsDefault()) {
    _impl_.classname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteAssemblyReq.ClassName)
}

// string Method = 7;
inline void ExecuteAssemblyReq::clear_method() {
  _impl_.method_.ClearToEmpty();
}
inline const std::string& ExecuteAssemblyReq::method() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteAssemblyReq.Method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteAssemblyReq::set_method(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteAssemblyReq.Method)
}
inline std::string* ExecuteAssemblyReq::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteAssemblyReq.Method)
  return _s;
}
inline const std::string& ExecuteAssemblyReq::_internal_method() const {
  return _impl_.method_.Get();
}
inline void ExecuteAssemblyReq::_internal_set_method(const std::string& value) {
  
  _impl_.method_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteAssemblyReq::_internal_mutable_method() {
  
  return _impl_.method_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteAssemblyReq::release_method() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteAssemblyReq.Method)
  return _impl_.method_.Release();
}
inline void ExecuteAssemblyReq::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  _impl_.method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteAssemblyReq.Method)
}

// string AppDomain = 8;
inline void ExecuteAssemblyReq::clear_appdomain() {
  _impl_.appdomain_.ClearToEmpty();
}
inline const std::string& ExecuteAssemblyReq::appdomain() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteAssemblyReq.AppDomain)
  return _internal_appdomain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteAssemblyReq::set_appdomain(ArgT0&& arg0, ArgT... args) {
 
 _impl_.appdomain_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteAssemblyReq.AppDomain)
}
inline std::string* ExecuteAssemblyReq::mutable_appdomain() {
  std::string* _s = _internal_mutable_appdomain();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteAssemblyReq.AppDomain)
  return _s;
}
inline const std::string& ExecuteAssemblyReq::_internal_appdomain() const {
  return _impl_.appdomain_.Get();
}
inline void ExecuteAssemblyReq::_internal_set_appdomain(const std::string& value) {
  
  _impl_.appdomain_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteAssemblyReq::_internal_mutable_appdomain() {
  
  return _impl_.appdomain_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteAssemblyReq::release_appdomain() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteAssemblyReq.AppDomain)
  return _impl_.appdomain_.Release();
}
inline void ExecuteAssemblyReq::set_allocated_appdomain(std::string* appdomain) {
  if (appdomain != nullptr) {
    
  } else {
    
  }
  _impl_.appdomain_.SetAllocated(appdomain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appdomain_.IsDefault()) {
    _impl_.appdomain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteAssemblyReq.AppDomain)
}

// uint32 PPid = 10;
inline void ExecuteAssemblyReq::clear_ppid() {
  _impl_.ppid_ = 0u;
}
inline uint32_t ExecuteAssemblyReq::_internal_ppid() const {
  return _impl_.ppid_;
}
inline uint32_t ExecuteAssemblyReq::ppid() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteAssemblyReq.PPid)
  return _internal_ppid();
}
inline void ExecuteAssemblyReq::_internal_set_ppid(uint32_t value) {
  
  _impl_.ppid_ = value;
}
inline void ExecuteAssemblyReq::set_ppid(uint32_t value) {
  _internal_set_ppid(value);
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteAssemblyReq.PPid)
}

// repeated string ProcessArgs = 11;
inline int ExecuteAssemblyReq::_internal_processargs_size() const {
  return _impl_.processargs_.size();
}
inline int ExecuteAssemblyReq::processargs_size() const {
  return _internal_processargs_size();
}
inline void ExecuteAssemblyReq::clear_processargs() {
  _impl_.processargs_.Clear();
}
inline std::string* ExecuteAssemblyReq::add_processargs() {
  std::string* _s = _internal_add_processargs();
  // @@protoc_insertion_point(field_add_mutable:sliverpb.ExecuteAssemblyReq.ProcessArgs)
  return _s;
}
inline const std::string& ExecuteAssemblyReq::_internal_processargs(int index) const {
  return _impl_.processargs_.Get(index);
}
inline const std::string& ExecuteAssemblyReq::processargs(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteAssemblyReq.ProcessArgs)
  return _internal_processargs(index);
}
inline std::string* ExecuteAssemblyReq::mutable_processargs(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteAssemblyReq.ProcessArgs)
  return _impl_.processargs_.Mutable(index);
}
inline void ExecuteAssemblyReq::set_processargs(int index, const std::string& value) {
  _impl_.processargs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteAssemblyReq.ProcessArgs)
}
inline void ExecuteAssemblyReq::set_processargs(int index, std::string&& value) {
  _impl_.processargs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteAssemblyReq.ProcessArgs)
}
inline void ExecuteAssemblyReq::set_processargs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.processargs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sliverpb.ExecuteAssemblyReq.ProcessArgs)
}
inline void ExecuteAssemblyReq::set_processargs(int index, const char* value, size_t size) {
  _impl_.processargs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sliverpb.ExecuteAssemblyReq.ProcessArgs)
}
inline std::string* ExecuteAssemblyReq::_internal_add_processargs() {
  return _impl_.processargs_.Add();
}
inline void ExecuteAssemblyReq::add_processargs(const std::string& value) {
  _impl_.processargs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sliverpb.ExecuteAssemblyReq.ProcessArgs)
}
inline void ExecuteAssemblyReq::add_processargs(std::string&& value) {
  _impl_.processargs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sliverpb.ExecuteAssemblyReq.ProcessArgs)
}
inline void ExecuteAssemblyReq::add_processargs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.processargs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sliverpb.ExecuteAssemblyReq.ProcessArgs)
}
inline void ExecuteAssemblyReq::add_processargs(const char* value, size_t size) {
  _impl_.processargs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sliverpb.ExecuteAssemblyReq.ProcessArgs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExecuteAssemblyReq::processargs() const {
  // @@protoc_insertion_point(field_list:sliverpb.ExecuteAssemblyReq.ProcessArgs)
  return _impl_.processargs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExecuteAssemblyReq::mutable_processargs() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.ExecuteAssemblyReq.ProcessArgs)
  return &_impl_.processargs_;
}

// bool InProcess = 12;
inline void ExecuteAssemblyReq::clear_inprocess() {
  _impl_.inprocess_ = false;
}
inline bool ExecuteAssemblyReq::_internal_inprocess() const {
  return _impl_.inprocess_;
}
inline bool ExecuteAssemblyReq::inprocess() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteAssemblyReq.InProcess)
  return _internal_inprocess();
}
inline void ExecuteAssemblyReq::_internal_set_inprocess(bool value) {
  
  _impl_.inprocess_ = value;
}
inline void ExecuteAssemblyReq::set_inprocess(bool value) {
  _internal_set_inprocess(value);
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteAssemblyReq.InProcess)
}

// string Runtime = 13;
inline void ExecuteAssemblyReq::clear_runtime() {
  _impl_.runtime_.ClearToEmpty();
}
inline const std::string& ExecuteAssemblyReq::runtime() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteAssemblyReq.Runtime)
  return _internal_runtime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteAssemblyReq::set_runtime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.runtime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteAssemblyReq.Runtime)
}
inline std::string* ExecuteAssemblyReq::mutable_runtime() {
  std::string* _s = _internal_mutable_runtime();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteAssemblyReq.Runtime)
  return _s;
}
inline const std::string& ExecuteAssemblyReq::_internal_runtime() const {
  return _impl_.runtime_.Get();
}
inline void ExecuteAssemblyReq::_internal_set_runtime(const std::string& value) {
  
  _impl_.runtime_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteAssemblyReq::_internal_mutable_runtime() {
  
  return _impl_.runtime_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteAssemblyReq::release_runtime() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteAssemblyReq.Runtime)
  return _impl_.runtime_.Release();
}
inline void ExecuteAssemblyReq::set_allocated_runtime(std::string* runtime) {
  if (runtime != nullptr) {
    
  } else {
    
  }
  _impl_.runtime_.SetAllocated(runtime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.runtime_.IsDefault()) {
    _impl_.runtime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteAssemblyReq.Runtime)
}

// bool AmsiBypass = 14;
inline void ExecuteAssemblyReq::clear_amsibypass() {
  _impl_.amsibypass_ = false;
}
inline bool ExecuteAssemblyReq::_internal_amsibypass() const {
  return _impl_.amsibypass_;
}
inline bool ExecuteAssemblyReq::amsibypass() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteAssemblyReq.AmsiBypass)
  return _internal_amsibypass();
}
inline void ExecuteAssemblyReq::_internal_set_amsibypass(bool value) {
  
  _impl_.amsibypass_ = value;
}
inline void ExecuteAssemblyReq::set_amsibypass(bool value) {
  _internal_set_amsibypass(value);
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteAssemblyReq.AmsiBypass)
}

// bool EtwBypass = 15;
inline void ExecuteAssemblyReq::clear_etwbypass() {
  _impl_.etwbypass_ = false;
}
inline bool ExecuteAssemblyReq::_internal_etwbypass() const {
  return _impl_.etwbypass_;
}
inline bool ExecuteAssemblyReq::etwbypass() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteAssemblyReq.EtwBypass)
  return _internal_etwbypass();
}
inline void ExecuteAssemblyReq::_internal_set_etwbypass(bool value) {
  
  _impl_.etwbypass_ = value;
}
inline void ExecuteAssemblyReq::set_etwbypass(bool value) {
  _internal_set_etwbypass(value);
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteAssemblyReq.EtwBypass)
}

// .sliverpb.Request Request = 9;
inline bool ExecuteAssemblyReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool ExecuteAssemblyReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& ExecuteAssemblyReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& ExecuteAssemblyReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteAssemblyReq.Request)
  return _internal_request();
}
inline void ExecuteAssemblyReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.ExecuteAssemblyReq.Request)
}
inline ::sliverpb::Request* ExecuteAssemblyReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* ExecuteAssemblyReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteAssemblyReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* ExecuteAssemblyReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* ExecuteAssemblyReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteAssemblyReq.Request)
  return _msg;
}
inline void ExecuteAssemblyReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteAssemblyReq.Request)
}

// -------------------------------------------------------------------

// InvokeExecuteAssemblyReq

// bytes Data = 1;
inline void InvokeExecuteAssemblyReq::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& InvokeExecuteAssemblyReq::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeExecuteAssemblyReq.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeExecuteAssemblyReq::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.InvokeExecuteAssemblyReq.Data)
}
inline std::string* InvokeExecuteAssemblyReq::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeExecuteAssemblyReq.Data)
  return _s;
}
inline const std::string& InvokeExecuteAssemblyReq::_internal_data() const {
  return _impl_.data_.Get();
}
inline void InvokeExecuteAssemblyReq::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeExecuteAssemblyReq::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeExecuteAssemblyReq::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.InvokeExecuteAssemblyReq.Data)
  return _impl_.data_.Release();
}
inline void InvokeExecuteAssemblyReq::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.InvokeExecuteAssemblyReq.Data)
}

// string process = 2;
inline void InvokeExecuteAssemblyReq::clear_process() {
  _impl_.process_.ClearToEmpty();
}
inline const std::string& InvokeExecuteAssemblyReq::process() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeExecuteAssemblyReq.process)
  return _internal_process();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeExecuteAssemblyReq::set_process(ArgT0&& arg0, ArgT... args) {
 
 _impl_.process_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.InvokeExecuteAssemblyReq.process)
}
inline std::string* InvokeExecuteAssemblyReq::mutable_process() {
  std::string* _s = _internal_mutable_process();
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeExecuteAssemblyReq.process)
  return _s;
}
inline const std::string& InvokeExecuteAssemblyReq::_internal_process() const {
  return _impl_.process_.Get();
}
inline void InvokeExecuteAssemblyReq::_internal_set_process(const std::string& value) {
  
  _impl_.process_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeExecuteAssemblyReq::_internal_mutable_process() {
  
  return _impl_.process_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeExecuteAssemblyReq::release_process() {
  // @@protoc_insertion_point(field_release:sliverpb.InvokeExecuteAssemblyReq.process)
  return _impl_.process_.Release();
}
inline void InvokeExecuteAssemblyReq::set_allocated_process(std::string* process) {
  if (process != nullptr) {
    
  } else {
    
  }
  _impl_.process_.SetAllocated(process, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.process_.IsDefault()) {
    _impl_.process_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.InvokeExecuteAssemblyReq.process)
}

// uint32 PPid = 10;
inline void InvokeExecuteAssemblyReq::clear_ppid() {
  _impl_.ppid_ = 0u;
}
inline uint32_t InvokeExecuteAssemblyReq::_internal_ppid() const {
  return _impl_.ppid_;
}
inline uint32_t InvokeExecuteAssemblyReq::ppid() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeExecuteAssemblyReq.PPid)
  return _internal_ppid();
}
inline void InvokeExecuteAssemblyReq::_internal_set_ppid(uint32_t value) {
  
  _impl_.ppid_ = value;
}
inline void InvokeExecuteAssemblyReq::set_ppid(uint32_t value) {
  _internal_set_ppid(value);
  // @@protoc_insertion_point(field_set:sliverpb.InvokeExecuteAssemblyReq.PPid)
}

// repeated string ProcessArgs = 11;
inline int InvokeExecuteAssemblyReq::_internal_processargs_size() const {
  return _impl_.processargs_.size();
}
inline int InvokeExecuteAssemblyReq::processargs_size() const {
  return _internal_processargs_size();
}
inline void InvokeExecuteAssemblyReq::clear_processargs() {
  _impl_.processargs_.Clear();
}
inline std::string* InvokeExecuteAssemblyReq::add_processargs() {
  std::string* _s = _internal_add_processargs();
  // @@protoc_insertion_point(field_add_mutable:sliverpb.InvokeExecuteAssemblyReq.ProcessArgs)
  return _s;
}
inline const std::string& InvokeExecuteAssemblyReq::_internal_processargs(int index) const {
  return _impl_.processargs_.Get(index);
}
inline const std::string& InvokeExecuteAssemblyReq::processargs(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeExecuteAssemblyReq.ProcessArgs)
  return _internal_processargs(index);
}
inline std::string* InvokeExecuteAssemblyReq::mutable_processargs(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeExecuteAssemblyReq.ProcessArgs)
  return _impl_.processargs_.Mutable(index);
}
inline void InvokeExecuteAssemblyReq::set_processargs(int index, const std::string& value) {
  _impl_.processargs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sliverpb.InvokeExecuteAssemblyReq.ProcessArgs)
}
inline void InvokeExecuteAssemblyReq::set_processargs(int index, std::string&& value) {
  _impl_.processargs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sliverpb.InvokeExecuteAssemblyReq.ProcessArgs)
}
inline void InvokeExecuteAssemblyReq::set_processargs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.processargs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sliverpb.InvokeExecuteAssemblyReq.ProcessArgs)
}
inline void InvokeExecuteAssemblyReq::set_processargs(int index, const char* value, size_t size) {
  _impl_.processargs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sliverpb.InvokeExecuteAssemblyReq.ProcessArgs)
}
inline std::string* InvokeExecuteAssemblyReq::_internal_add_processargs() {
  return _impl_.processargs_.Add();
}
inline void InvokeExecuteAssemblyReq::add_processargs(const std::string& value) {
  _impl_.processargs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sliverpb.InvokeExecuteAssemblyReq.ProcessArgs)
}
inline void InvokeExecuteAssemblyReq::add_processargs(std::string&& value) {
  _impl_.processargs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sliverpb.InvokeExecuteAssemblyReq.ProcessArgs)
}
inline void InvokeExecuteAssemblyReq::add_processargs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.processargs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sliverpb.InvokeExecuteAssemblyReq.ProcessArgs)
}
inline void InvokeExecuteAssemblyReq::add_processargs(const char* value, size_t size) {
  _impl_.processargs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sliverpb.InvokeExecuteAssemblyReq.ProcessArgs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InvokeExecuteAssemblyReq::processargs() const {
  // @@protoc_insertion_point(field_list:sliverpb.InvokeExecuteAssemblyReq.ProcessArgs)
  return _impl_.processargs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InvokeExecuteAssemblyReq::mutable_processargs() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.InvokeExecuteAssemblyReq.ProcessArgs)
  return &_impl_.processargs_;
}

// .sliverpb.Request Request = 9;
inline bool InvokeExecuteAssemblyReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool InvokeExecuteAssemblyReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& InvokeExecuteAssemblyReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& InvokeExecuteAssemblyReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeExecuteAssemblyReq.Request)
  return _internal_request();
}
inline void InvokeExecuteAssemblyReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.InvokeExecuteAssemblyReq.Request)
}
inline ::sliverpb::Request* InvokeExecuteAssemblyReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* InvokeExecuteAssemblyReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.InvokeExecuteAssemblyReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* InvokeExecuteAssemblyReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* InvokeExecuteAssemblyReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeExecuteAssemblyReq.Request)
  return _msg;
}
inline void InvokeExecuteAssemblyReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.InvokeExecuteAssemblyReq.Request)
}

// -------------------------------------------------------------------

// InvokeInProcExecuteAssemblyReq

// bytes Data = 1;
inline void InvokeInProcExecuteAssemblyReq::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& InvokeInProcExecuteAssemblyReq::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeInProcExecuteAssemblyReq.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeInProcExecuteAssemblyReq::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.InvokeInProcExecuteAssemblyReq.Data)
}
inline std::string* InvokeInProcExecuteAssemblyReq::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeInProcExecuteAssemblyReq.Data)
  return _s;
}
inline const std::string& InvokeInProcExecuteAssemblyReq::_internal_data() const {
  return _impl_.data_.Get();
}
inline void InvokeInProcExecuteAssemblyReq::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeInProcExecuteAssemblyReq::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeInProcExecuteAssemblyReq::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.InvokeInProcExecuteAssemblyReq.Data)
  return _impl_.data_.Release();
}
inline void InvokeInProcExecuteAssemblyReq::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.InvokeInProcExecuteAssemblyReq.Data)
}

// repeated string Arguments = 2;
inline int InvokeInProcExecuteAssemblyReq::_internal_arguments_size() const {
  return _impl_.arguments_.size();
}
inline int InvokeInProcExecuteAssemblyReq::arguments_size() const {
  return _internal_arguments_size();
}
inline void InvokeInProcExecuteAssemblyReq::clear_arguments() {
  _impl_.arguments_.Clear();
}
inline std::string* InvokeInProcExecuteAssemblyReq::add_arguments() {
  std::string* _s = _internal_add_arguments();
  // @@protoc_insertion_point(field_add_mutable:sliverpb.InvokeInProcExecuteAssemblyReq.Arguments)
  return _s;
}
inline const std::string& InvokeInProcExecuteAssemblyReq::_internal_arguments(int index) const {
  return _impl_.arguments_.Get(index);
}
inline const std::string& InvokeInProcExecuteAssemblyReq::arguments(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeInProcExecuteAssemblyReq.Arguments)
  return _internal_arguments(index);
}
inline std::string* InvokeInProcExecuteAssemblyReq::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeInProcExecuteAssemblyReq.Arguments)
  return _impl_.arguments_.Mutable(index);
}
inline void InvokeInProcExecuteAssemblyReq::set_arguments(int index, const std::string& value) {
  _impl_.arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sliverpb.InvokeInProcExecuteAssemblyReq.Arguments)
}
inline void InvokeInProcExecuteAssemblyReq::set_arguments(int index, std::string&& value) {
  _impl_.arguments_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sliverpb.InvokeInProcExecuteAssemblyReq.Arguments)
}
inline void InvokeInProcExecuteAssemblyReq::set_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sliverpb.InvokeInProcExecuteAssemblyReq.Arguments)
}
inline void InvokeInProcExecuteAssemblyReq::set_arguments(int index, const char* value, size_t size) {
  _impl_.arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sliverpb.InvokeInProcExecuteAssemblyReq.Arguments)
}
inline std::string* InvokeInProcExecuteAssemblyReq::_internal_add_arguments() {
  return _impl_.arguments_.Add();
}
inline void InvokeInProcExecuteAssemblyReq::add_arguments(const std::string& value) {
  _impl_.arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sliverpb.InvokeInProcExecuteAssemblyReq.Arguments)
}
inline void InvokeInProcExecuteAssemblyReq::add_arguments(std::string&& value) {
  _impl_.arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sliverpb.InvokeInProcExecuteAssemblyReq.Arguments)
}
inline void InvokeInProcExecuteAssemblyReq::add_arguments(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sliverpb.InvokeInProcExecuteAssemblyReq.Arguments)
}
inline void InvokeInProcExecuteAssemblyReq::add_arguments(const char* value, size_t size) {
  _impl_.arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sliverpb.InvokeInProcExecuteAssemblyReq.Arguments)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InvokeInProcExecuteAssemblyReq::arguments() const {
  // @@protoc_insertion_point(field_list:sliverpb.InvokeInProcExecuteAssemblyReq.Arguments)
  return _impl_.arguments_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InvokeInProcExecuteAssemblyReq::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.InvokeInProcExecuteAssemblyReq.Arguments)
  return &_impl_.arguments_;
}

// string Runtime = 3;
inline void InvokeInProcExecuteAssemblyReq::clear_runtime() {
  _impl_.runtime_.ClearToEmpty();
}
inline const std::string& InvokeInProcExecuteAssemblyReq::runtime() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeInProcExecuteAssemblyReq.Runtime)
  return _internal_runtime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeInProcExecuteAssemblyReq::set_runtime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.runtime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.InvokeInProcExecuteAssemblyReq.Runtime)
}
inline std::string* InvokeInProcExecuteAssemblyReq::mutable_runtime() {
  std::string* _s = _internal_mutable_runtime();
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeInProcExecuteAssemblyReq.Runtime)
  return _s;
}
inline const std::string& InvokeInProcExecuteAssemblyReq::_internal_runtime() const {
  return _impl_.runtime_.Get();
}
inline void InvokeInProcExecuteAssemblyReq::_internal_set_runtime(const std::string& value) {
  
  _impl_.runtime_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeInProcExecuteAssemblyReq::_internal_mutable_runtime() {
  
  return _impl_.runtime_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeInProcExecuteAssemblyReq::release_runtime() {
  // @@protoc_insertion_point(field_release:sliverpb.InvokeInProcExecuteAssemblyReq.Runtime)
  return _impl_.runtime_.Release();
}
inline void InvokeInProcExecuteAssemblyReq::set_allocated_runtime(std::string* runtime) {
  if (runtime != nullptr) {
    
  } else {
    
  }
  _impl_.runtime_.SetAllocated(runtime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.runtime_.IsDefault()) {
    _impl_.runtime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.InvokeInProcExecuteAssemblyReq.Runtime)
}

// bool AmsiBypass = 4;
inline void InvokeInProcExecuteAssemblyReq::clear_amsibypass() {
  _impl_.amsibypass_ = false;
}
inline bool InvokeInProcExecuteAssemblyReq::_internal_amsibypass() const {
  return _impl_.amsibypass_;
}
inline bool InvokeInProcExecuteAssemblyReq::amsibypass() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeInProcExecuteAssemblyReq.AmsiBypass)
  return _internal_amsibypass();
}
inline void InvokeInProcExecuteAssemblyReq::_internal_set_amsibypass(bool value) {
  
  _impl_.amsibypass_ = value;
}
inline void InvokeInProcExecuteAssemblyReq::set_amsibypass(bool value) {
  _internal_set_amsibypass(value);
  // @@protoc_insertion_point(field_set:sliverpb.InvokeInProcExecuteAssemblyReq.AmsiBypass)
}

// bool EtwBypass = 5;
inline void InvokeInProcExecuteAssemblyReq::clear_etwbypass() {
  _impl_.etwbypass_ = false;
}
inline bool InvokeInProcExecuteAssemblyReq::_internal_etwbypass() const {
  return _impl_.etwbypass_;
}
inline bool InvokeInProcExecuteAssemblyReq::etwbypass() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeInProcExecuteAssemblyReq.EtwBypass)
  return _internal_etwbypass();
}
inline void InvokeInProcExecuteAssemblyReq::_internal_set_etwbypass(bool value) {
  
  _impl_.etwbypass_ = value;
}
inline void InvokeInProcExecuteAssemblyReq::set_etwbypass(bool value) {
  _internal_set_etwbypass(value);
  // @@protoc_insertion_point(field_set:sliverpb.InvokeInProcExecuteAssemblyReq.EtwBypass)
}

// .sliverpb.Request Request = 9;
inline bool InvokeInProcExecuteAssemblyReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool InvokeInProcExecuteAssemblyReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& InvokeInProcExecuteAssemblyReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& InvokeInProcExecuteAssemblyReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeInProcExecuteAssemblyReq.Request)
  return _internal_request();
}
inline void InvokeInProcExecuteAssemblyReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.InvokeInProcExecuteAssemblyReq.Request)
}
inline ::sliverpb::Request* InvokeInProcExecuteAssemblyReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* InvokeInProcExecuteAssemblyReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.InvokeInProcExecuteAssemblyReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* InvokeInProcExecuteAssemblyReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* InvokeInProcExecuteAssemblyReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeInProcExecuteAssemblyReq.Request)
  return _msg;
}
inline void InvokeInProcExecuteAssemblyReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.InvokeInProcExecuteAssemblyReq.Request)
}

// -------------------------------------------------------------------

// ExecuteAssembly

// bytes Output = 1;
inline void ExecuteAssembly::clear_output() {
  _impl_.output_.ClearToEmpty();
}
inline const std::string& ExecuteAssembly::output() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteAssembly.Output)
  return _internal_output();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteAssembly::set_output(ArgT0&& arg0, ArgT... args) {
 
 _impl_.output_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteAssembly.Output)
}
inline std::string* ExecuteAssembly::mutable_output() {
  std::string* _s = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteAssembly.Output)
  return _s;
}
inline const std::string& ExecuteAssembly::_internal_output() const {
  return _impl_.output_.Get();
}
inline void ExecuteAssembly::_internal_set_output(const std::string& value) {
  
  _impl_.output_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteAssembly::_internal_mutable_output() {
  
  return _impl_.output_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteAssembly::release_output() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteAssembly.Output)
  return _impl_.output_.Release();
}
inline void ExecuteAssembly::set_allocated_output(std::string* output) {
  if (output != nullptr) {
    
  } else {
    
  }
  _impl_.output_.SetAllocated(output, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.output_.IsDefault()) {
    _impl_.output_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteAssembly.Output)
}

// .sliverpb.Response Response = 9;
inline bool ExecuteAssembly::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool ExecuteAssembly::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& ExecuteAssembly::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& ExecuteAssembly::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteAssembly.Response)
  return _internal_response();
}
inline void ExecuteAssembly::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.ExecuteAssembly.Response)
}
inline ::sliverpb::Response* ExecuteAssembly::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* ExecuteAssembly::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteAssembly.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* ExecuteAssembly::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* ExecuteAssembly::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteAssembly.Response)
  return _msg;
}
inline void ExecuteAssembly::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteAssembly.Response)
}

// -------------------------------------------------------------------

// InvokeMigrateReq

// uint32 Pid = 1;
inline void InvokeMigrateReq::clear_pid() {
  _impl_.pid_ = 0u;
}
inline uint32_t InvokeMigrateReq::_internal_pid() const {
  return _impl_.pid_;
}
inline uint32_t InvokeMigrateReq::pid() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeMigrateReq.Pid)
  return _internal_pid();
}
inline void InvokeMigrateReq::_internal_set_pid(uint32_t value) {
  
  _impl_.pid_ = value;
}
inline void InvokeMigrateReq::set_pid(uint32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:sliverpb.InvokeMigrateReq.Pid)
}

// bytes Data = 2;
inline void InvokeMigrateReq::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& InvokeMigrateReq::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeMigrateReq.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeMigrateReq::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.InvokeMigrateReq.Data)
}
inline std::string* InvokeMigrateReq::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeMigrateReq.Data)
  return _s;
}
inline const std::string& InvokeMigrateReq::_internal_data() const {
  return _impl_.data_.Get();
}
inline void InvokeMigrateReq::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeMigrateReq::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeMigrateReq::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.InvokeMigrateReq.Data)
  return _impl_.data_.Release();
}
inline void InvokeMigrateReq::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.InvokeMigrateReq.Data)
}

// .sliverpb.Request Request = 9;
inline bool InvokeMigrateReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool InvokeMigrateReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& InvokeMigrateReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& InvokeMigrateReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeMigrateReq.Request)
  return _internal_request();
}
inline void InvokeMigrateReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.InvokeMigrateReq.Request)
}
inline ::sliverpb::Request* InvokeMigrateReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* InvokeMigrateReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.InvokeMigrateReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* InvokeMigrateReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* InvokeMigrateReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeMigrateReq.Request)
  return _msg;
}
inline void InvokeMigrateReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.InvokeMigrateReq.Request)
}

// -------------------------------------------------------------------

// Migrate

// bool Success = 1;
inline void Migrate::clear_success() {
  _impl_.success_ = false;
}
inline bool Migrate::_internal_success() const {
  return _impl_.success_;
}
inline bool Migrate::success() const {
  // @@protoc_insertion_point(field_get:sliverpb.Migrate.Success)
  return _internal_success();
}
inline void Migrate::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void Migrate::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sliverpb.Migrate.Success)
}

// .sliverpb.Response Response = 9;
inline bool Migrate::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Migrate::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Migrate::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Migrate::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Migrate.Response)
  return _internal_response();
}
inline void Migrate::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Migrate.Response)
}
inline ::sliverpb::Response* Migrate::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Migrate::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Migrate.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Migrate::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Migrate::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Migrate.Response)
  return _msg;
}
inline void Migrate::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Migrate.Response)
}

// -------------------------------------------------------------------

// ExecuteReq

// string Path = 1;
inline void ExecuteReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& ExecuteReq::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteReq.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteReq.Path)
}
inline std::string* ExecuteReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteReq.Path)
  return _s;
}
inline const std::string& ExecuteReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void ExecuteReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteReq::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteReq.Path)
  return _impl_.path_.Release();
}
inline void ExecuteReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteReq.Path)
}

// repeated string Args = 2;
inline int ExecuteReq::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int ExecuteReq::args_size() const {
  return _internal_args_size();
}
inline void ExecuteReq::clear_args() {
  _impl_.args_.Clear();
}
inline std::string* ExecuteReq::add_args() {
  std::string* _s = _internal_add_args();
  // @@protoc_insertion_point(field_add_mutable:sliverpb.ExecuteReq.Args)
  return _s;
}
inline const std::string& ExecuteReq::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const std::string& ExecuteReq::args(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteReq.Args)
  return _internal_args(index);
}
inline std::string* ExecuteReq::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteReq.Args)
  return _impl_.args_.Mutable(index);
}
inline void ExecuteReq::set_args(int index, const std::string& value) {
  _impl_.args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteReq.Args)
}
inline void ExecuteReq::set_args(int index, std::string&& value) {
  _impl_.args_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteReq.Args)
}
inline void ExecuteReq::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sliverpb.ExecuteReq.Args)
}
inline void ExecuteReq::set_args(int index, const char* value, size_t size) {
  _impl_.args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sliverpb.ExecuteReq.Args)
}
inline std::string* ExecuteReq::_internal_add_args() {
  return _impl_.args_.Add();
}
inline void ExecuteReq::add_args(const std::string& value) {
  _impl_.args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sliverpb.ExecuteReq.Args)
}
inline void ExecuteReq::add_args(std::string&& value) {
  _impl_.args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sliverpb.ExecuteReq.Args)
}
inline void ExecuteReq::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sliverpb.ExecuteReq.Args)
}
inline void ExecuteReq::add_args(const char* value, size_t size) {
  _impl_.args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sliverpb.ExecuteReq.Args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExecuteReq::args() const {
  // @@protoc_insertion_point(field_list:sliverpb.ExecuteReq.Args)
  return _impl_.args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExecuteReq::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.ExecuteReq.Args)
  return &_impl_.args_;
}

// bool Output = 3;
inline void ExecuteReq::clear_output() {
  _impl_.output_ = false;
}
inline bool ExecuteReq::_internal_output() const {
  return _impl_.output_;
}
inline bool ExecuteReq::output() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteReq.Output)
  return _internal_output();
}
inline void ExecuteReq::_internal_set_output(bool value) {
  
  _impl_.output_ = value;
}
inline void ExecuteReq::set_output(bool value) {
  _internal_set_output(value);
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteReq.Output)
}

// string stdout_pb = 4;
inline void ExecuteReq::clear_stdout_pb() {
  _impl_.stdout_pb_.ClearToEmpty();
}
inline const std::string& ExecuteReq::stdout_pb() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteReq.stdout_pb)
  return _internal_stdout_pb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteReq::set_stdout_pb(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stdout_pb_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteReq.stdout_pb)
}
inline std::string* ExecuteReq::mutable_stdout_pb() {
  std::string* _s = _internal_mutable_stdout_pb();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteReq.stdout_pb)
  return _s;
}
inline const std::string& ExecuteReq::_internal_stdout_pb() const {
  return _impl_.stdout_pb_.Get();
}
inline void ExecuteReq::_internal_set_stdout_pb(const std::string& value) {
  
  _impl_.stdout_pb_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteReq::_internal_mutable_stdout_pb() {
  
  return _impl_.stdout_pb_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteReq::release_stdout_pb() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteReq.stdout_pb)
  return _impl_.stdout_pb_.Release();
}
inline void ExecuteReq::set_allocated_stdout_pb(std::string* stdout_pb) {
  if (stdout_pb != nullptr) {
    
  } else {
    
  }
  _impl_.stdout_pb_.SetAllocated(stdout_pb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stdout_pb_.IsDefault()) {
    _impl_.stdout_pb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteReq.stdout_pb)
}

// string stderr_pb = 5;
inline void ExecuteReq::clear_stderr_pb() {
  _impl_.stderr_pb_.ClearToEmpty();
}
inline const std::string& ExecuteReq::stderr_pb() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteReq.stderr_pb)
  return _internal_stderr_pb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteReq::set_stderr_pb(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stderr_pb_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteReq.stderr_pb)
}
inline std::string* ExecuteReq::mutable_stderr_pb() {
  std::string* _s = _internal_mutable_stderr_pb();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteReq.stderr_pb)
  return _s;
}
inline const std::string& ExecuteReq::_internal_stderr_pb() const {
  return _impl_.stderr_pb_.Get();
}
inline void ExecuteReq::_internal_set_stderr_pb(const std::string& value) {
  
  _impl_.stderr_pb_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteReq::_internal_mutable_stderr_pb() {
  
  return _impl_.stderr_pb_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteReq::release_stderr_pb() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteReq.stderr_pb)
  return _impl_.stderr_pb_.Release();
}
inline void ExecuteReq::set_allocated_stderr_pb(std::string* stderr_pb) {
  if (stderr_pb != nullptr) {
    
  } else {
    
  }
  _impl_.stderr_pb_.SetAllocated(stderr_pb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stderr_pb_.IsDefault()) {
    _impl_.stderr_pb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteReq.stderr_pb)
}

// uint32 PPid = 10;
inline void ExecuteReq::clear_ppid() {
  _impl_.ppid_ = 0u;
}
inline uint32_t ExecuteReq::_internal_ppid() const {
  return _impl_.ppid_;
}
inline uint32_t ExecuteReq::ppid() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteReq.PPid)
  return _internal_ppid();
}
inline void ExecuteReq::_internal_set_ppid(uint32_t value) {
  
  _impl_.ppid_ = value;
}
inline void ExecuteReq::set_ppid(uint32_t value) {
  _internal_set_ppid(value);
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteReq.PPid)
}

// .sliverpb.Request Request = 9;
inline bool ExecuteReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool ExecuteReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& ExecuteReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& ExecuteReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteReq.Request)
  return _internal_request();
}
inline void ExecuteReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.ExecuteReq.Request)
}
inline ::sliverpb::Request* ExecuteReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* ExecuteReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* ExecuteReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* ExecuteReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteReq.Request)
  return _msg;
}
inline void ExecuteReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteReq.Request)
}

// -------------------------------------------------------------------

// ExecuteWindowsReq

// string Path = 1;
inline void ExecuteWindowsReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& ExecuteWindowsReq::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteWindowsReq.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteWindowsReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteWindowsReq.Path)
}
inline std::string* ExecuteWindowsReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteWindowsReq.Path)
  return _s;
}
inline const std::string& ExecuteWindowsReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void ExecuteWindowsReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteWindowsReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteWindowsReq::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteWindowsReq.Path)
  return _impl_.path_.Release();
}
inline void ExecuteWindowsReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteWindowsReq.Path)
}

// repeated string Args = 2;
inline int ExecuteWindowsReq::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int ExecuteWindowsReq::args_size() const {
  return _internal_args_size();
}
inline void ExecuteWindowsReq::clear_args() {
  _impl_.args_.Clear();
}
inline std::string* ExecuteWindowsReq::add_args() {
  std::string* _s = _internal_add_args();
  // @@protoc_insertion_point(field_add_mutable:sliverpb.ExecuteWindowsReq.Args)
  return _s;
}
inline const std::string& ExecuteWindowsReq::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const std::string& ExecuteWindowsReq::args(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteWindowsReq.Args)
  return _internal_args(index);
}
inline std::string* ExecuteWindowsReq::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteWindowsReq.Args)
  return _impl_.args_.Mutable(index);
}
inline void ExecuteWindowsReq::set_args(int index, const std::string& value) {
  _impl_.args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteWindowsReq.Args)
}
inline void ExecuteWindowsReq::set_args(int index, std::string&& value) {
  _impl_.args_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteWindowsReq.Args)
}
inline void ExecuteWindowsReq::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sliverpb.ExecuteWindowsReq.Args)
}
inline void ExecuteWindowsReq::set_args(int index, const char* value, size_t size) {
  _impl_.args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sliverpb.ExecuteWindowsReq.Args)
}
inline std::string* ExecuteWindowsReq::_internal_add_args() {
  return _impl_.args_.Add();
}
inline void ExecuteWindowsReq::add_args(const std::string& value) {
  _impl_.args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sliverpb.ExecuteWindowsReq.Args)
}
inline void ExecuteWindowsReq::add_args(std::string&& value) {
  _impl_.args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sliverpb.ExecuteWindowsReq.Args)
}
inline void ExecuteWindowsReq::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sliverpb.ExecuteWindowsReq.Args)
}
inline void ExecuteWindowsReq::add_args(const char* value, size_t size) {
  _impl_.args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sliverpb.ExecuteWindowsReq.Args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExecuteWindowsReq::args() const {
  // @@protoc_insertion_point(field_list:sliverpb.ExecuteWindowsReq.Args)
  return _impl_.args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExecuteWindowsReq::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.ExecuteWindowsReq.Args)
  return &_impl_.args_;
}

// bool Output = 3;
inline void ExecuteWindowsReq::clear_output() {
  _impl_.output_ = false;
}
inline bool ExecuteWindowsReq::_internal_output() const {
  return _impl_.output_;
}
inline bool ExecuteWindowsReq::output() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteWindowsReq.Output)
  return _internal_output();
}
inline void ExecuteWindowsReq::_internal_set_output(bool value) {
  
  _impl_.output_ = value;
}
inline void ExecuteWindowsReq::set_output(bool value) {
  _internal_set_output(value);
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteWindowsReq.Output)
}

// string stdout_pb = 4;
inline void ExecuteWindowsReq::clear_stdout_pb() {
  _impl_.stdout_pb_.ClearToEmpty();
}
inline const std::string& ExecuteWindowsReq::stdout_pb() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteWindowsReq.stdout_pb)
  return _internal_stdout_pb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteWindowsReq::set_stdout_pb(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stdout_pb_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteWindowsReq.stdout_pb)
}
inline std::string* ExecuteWindowsReq::mutable_stdout_pb() {
  std::string* _s = _internal_mutable_stdout_pb();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteWindowsReq.stdout_pb)
  return _s;
}
inline const std::string& ExecuteWindowsReq::_internal_stdout_pb() const {
  return _impl_.stdout_pb_.Get();
}
inline void ExecuteWindowsReq::_internal_set_stdout_pb(const std::string& value) {
  
  _impl_.stdout_pb_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteWindowsReq::_internal_mutable_stdout_pb() {
  
  return _impl_.stdout_pb_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteWindowsReq::release_stdout_pb() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteWindowsReq.stdout_pb)
  return _impl_.stdout_pb_.Release();
}
inline void ExecuteWindowsReq::set_allocated_stdout_pb(std::string* stdout_pb) {
  if (stdout_pb != nullptr) {
    
  } else {
    
  }
  _impl_.stdout_pb_.SetAllocated(stdout_pb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stdout_pb_.IsDefault()) {
    _impl_.stdout_pb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteWindowsReq.stdout_pb)
}

// string stderr_pb = 5;
inline void ExecuteWindowsReq::clear_stderr_pb() {
  _impl_.stderr_pb_.ClearToEmpty();
}
inline const std::string& ExecuteWindowsReq::stderr_pb() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteWindowsReq.stderr_pb)
  return _internal_stderr_pb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteWindowsReq::set_stderr_pb(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stderr_pb_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteWindowsReq.stderr_pb)
}
inline std::string* ExecuteWindowsReq::mutable_stderr_pb() {
  std::string* _s = _internal_mutable_stderr_pb();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteWindowsReq.stderr_pb)
  return _s;
}
inline const std::string& ExecuteWindowsReq::_internal_stderr_pb() const {
  return _impl_.stderr_pb_.Get();
}
inline void ExecuteWindowsReq::_internal_set_stderr_pb(const std::string& value) {
  
  _impl_.stderr_pb_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteWindowsReq::_internal_mutable_stderr_pb() {
  
  return _impl_.stderr_pb_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteWindowsReq::release_stderr_pb() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteWindowsReq.stderr_pb)
  return _impl_.stderr_pb_.Release();
}
inline void ExecuteWindowsReq::set_allocated_stderr_pb(std::string* stderr_pb) {
  if (stderr_pb != nullptr) {
    
  } else {
    
  }
  _impl_.stderr_pb_.SetAllocated(stderr_pb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stderr_pb_.IsDefault()) {
    _impl_.stderr_pb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteWindowsReq.stderr_pb)
}

// bool UseToken = 6;
inline void ExecuteWindowsReq::clear_usetoken() {
  _impl_.usetoken_ = false;
}
inline bool ExecuteWindowsReq::_internal_usetoken() const {
  return _impl_.usetoken_;
}
inline bool ExecuteWindowsReq::usetoken() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteWindowsReq.UseToken)
  return _internal_usetoken();
}
inline void ExecuteWindowsReq::_internal_set_usetoken(bool value) {
  
  _impl_.usetoken_ = value;
}
inline void ExecuteWindowsReq::set_usetoken(bool value) {
  _internal_set_usetoken(value);
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteWindowsReq.UseToken)
}

// uint32 PPid = 10;
inline void ExecuteWindowsReq::clear_ppid() {
  _impl_.ppid_ = 0u;
}
inline uint32_t ExecuteWindowsReq::_internal_ppid() const {
  return _impl_.ppid_;
}
inline uint32_t ExecuteWindowsReq::ppid() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteWindowsReq.PPid)
  return _internal_ppid();
}
inline void ExecuteWindowsReq::_internal_set_ppid(uint32_t value) {
  
  _impl_.ppid_ = value;
}
inline void ExecuteWindowsReq::set_ppid(uint32_t value) {
  _internal_set_ppid(value);
  // @@protoc_insertion_point(field_set:sliverpb.ExecuteWindowsReq.PPid)
}

// .sliverpb.Request Request = 9;
inline bool ExecuteWindowsReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool ExecuteWindowsReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& ExecuteWindowsReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& ExecuteWindowsReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.ExecuteWindowsReq.Request)
  return _internal_request();
}
inline void ExecuteWindowsReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.ExecuteWindowsReq.Request)
}
inline ::sliverpb::Request* ExecuteWindowsReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* ExecuteWindowsReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.ExecuteWindowsReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* ExecuteWindowsReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* ExecuteWindowsReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.ExecuteWindowsReq.Request)
  return _msg;
}
inline void ExecuteWindowsReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ExecuteWindowsReq.Request)
}

// -------------------------------------------------------------------

// Execute

// uint32 Status = 1;
inline void Execute::clear_status() {
  _impl_.status_ = 0u;
}
inline uint32_t Execute::_internal_status() const {
  return _impl_.status_;
}
inline uint32_t Execute::status() const {
  // @@protoc_insertion_point(field_get:sliverpb.Execute.Status)
  return _internal_status();
}
inline void Execute::_internal_set_status(uint32_t value) {
  
  _impl_.status_ = value;
}
inline void Execute::set_status(uint32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:sliverpb.Execute.Status)
}

// bytes stdout_pb = 2;
inline void Execute::clear_stdout_pb() {
  _impl_.stdout_pb_.ClearToEmpty();
}
inline const std::string& Execute::stdout_pb() const {
  // @@protoc_insertion_point(field_get:sliverpb.Execute.stdout_pb)
  return _internal_stdout_pb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Execute::set_stdout_pb(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stdout_pb_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Execute.stdout_pb)
}
inline std::string* Execute::mutable_stdout_pb() {
  std::string* _s = _internal_mutable_stdout_pb();
  // @@protoc_insertion_point(field_mutable:sliverpb.Execute.stdout_pb)
  return _s;
}
inline const std::string& Execute::_internal_stdout_pb() const {
  return _impl_.stdout_pb_.Get();
}
inline void Execute::_internal_set_stdout_pb(const std::string& value) {
  
  _impl_.stdout_pb_.Set(value, GetArenaForAllocation());
}
inline std::string* Execute::_internal_mutable_stdout_pb() {
  
  return _impl_.stdout_pb_.Mutable(GetArenaForAllocation());
}
inline std::string* Execute::release_stdout_pb() {
  // @@protoc_insertion_point(field_release:sliverpb.Execute.stdout_pb)
  return _impl_.stdout_pb_.Release();
}
inline void Execute::set_allocated_stdout_pb(std::string* stdout_pb) {
  if (stdout_pb != nullptr) {
    
  } else {
    
  }
  _impl_.stdout_pb_.SetAllocated(stdout_pb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stdout_pb_.IsDefault()) {
    _impl_.stdout_pb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Execute.stdout_pb)
}

// bytes stderr_pb = 3;
inline void Execute::clear_stderr_pb() {
  _impl_.stderr_pb_.ClearToEmpty();
}
inline const std::string& Execute::stderr_pb() const {
  // @@protoc_insertion_point(field_get:sliverpb.Execute.stderr_pb)
  return _internal_stderr_pb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Execute::set_stderr_pb(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stderr_pb_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Execute.stderr_pb)
}
inline std::string* Execute::mutable_stderr_pb() {
  std::string* _s = _internal_mutable_stderr_pb();
  // @@protoc_insertion_point(field_mutable:sliverpb.Execute.stderr_pb)
  return _s;
}
inline const std::string& Execute::_internal_stderr_pb() const {
  return _impl_.stderr_pb_.Get();
}
inline void Execute::_internal_set_stderr_pb(const std::string& value) {
  
  _impl_.stderr_pb_.Set(value, GetArenaForAllocation());
}
inline std::string* Execute::_internal_mutable_stderr_pb() {
  
  return _impl_.stderr_pb_.Mutable(GetArenaForAllocation());
}
inline std::string* Execute::release_stderr_pb() {
  // @@protoc_insertion_point(field_release:sliverpb.Execute.stderr_pb)
  return _impl_.stderr_pb_.Release();
}
inline void Execute::set_allocated_stderr_pb(std::string* stderr_pb) {
  if (stderr_pb != nullptr) {
    
  } else {
    
  }
  _impl_.stderr_pb_.SetAllocated(stderr_pb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stderr_pb_.IsDefault()) {
    _impl_.stderr_pb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Execute.stderr_pb)
}

// uint32 Pid = 4;
inline void Execute::clear_pid() {
  _impl_.pid_ = 0u;
}
inline uint32_t Execute::_internal_pid() const {
  return _impl_.pid_;
}
inline uint32_t Execute::pid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Execute.Pid)
  return _internal_pid();
}
inline void Execute::_internal_set_pid(uint32_t value) {
  
  _impl_.pid_ = value;
}
inline void Execute::set_pid(uint32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:sliverpb.Execute.Pid)
}

// .sliverpb.Response Response = 9;
inline bool Execute::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Execute::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Execute::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Execute::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Execute.Response)
  return _internal_response();
}
inline void Execute::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Execute.Response)
}
inline ::sliverpb::Response* Execute::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Execute::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Execute.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Execute::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Execute::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Execute.Response)
  return _msg;
}
inline void Execute::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Execute.Response)
}

// -------------------------------------------------------------------

// SideloadReq

// bytes Data = 1;
inline void SideloadReq::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& SideloadReq::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.SideloadReq.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SideloadReq::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SideloadReq.Data)
}
inline std::string* SideloadReq::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.SideloadReq.Data)
  return _s;
}
inline const std::string& SideloadReq::_internal_data() const {
  return _impl_.data_.Get();
}
inline void SideloadReq::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* SideloadReq::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* SideloadReq::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.SideloadReq.Data)
  return _impl_.data_.Release();
}
inline void SideloadReq::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SideloadReq.Data)
}

// string ProcessName = 2;
inline void SideloadReq::clear_processname() {
  _impl_.processname_.ClearToEmpty();
}
inline const std::string& SideloadReq::processname() const {
  // @@protoc_insertion_point(field_get:sliverpb.SideloadReq.ProcessName)
  return _internal_processname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SideloadReq::set_processname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.processname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SideloadReq.ProcessName)
}
inline std::string* SideloadReq::mutable_processname() {
  std::string* _s = _internal_mutable_processname();
  // @@protoc_insertion_point(field_mutable:sliverpb.SideloadReq.ProcessName)
  return _s;
}
inline const std::string& SideloadReq::_internal_processname() const {
  return _impl_.processname_.Get();
}
inline void SideloadReq::_internal_set_processname(const std::string& value) {
  
  _impl_.processname_.Set(value, GetArenaForAllocation());
}
inline std::string* SideloadReq::_internal_mutable_processname() {
  
  return _impl_.processname_.Mutable(GetArenaForAllocation());
}
inline std::string* SideloadReq::release_processname() {
  // @@protoc_insertion_point(field_release:sliverpb.SideloadReq.ProcessName)
  return _impl_.processname_.Release();
}
inline void SideloadReq::set_allocated_processname(std::string* processname) {
  if (processname != nullptr) {
    
  } else {
    
  }
  _impl_.processname_.SetAllocated(processname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.processname_.IsDefault()) {
    _impl_.processname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SideloadReq.ProcessName)
}

// string Args = 3;
inline void SideloadReq::clear_args() {
  _impl_.args_.ClearToEmpty();
}
inline const std::string& SideloadReq::args() const {
  // @@protoc_insertion_point(field_get:sliverpb.SideloadReq.Args)
  return _internal_args();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SideloadReq::set_args(ArgT0&& arg0, ArgT... args) {
 
 _impl_.args_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SideloadReq.Args)
}
inline std::string* SideloadReq::mutable_args() {
  std::string* _s = _internal_mutable_args();
  // @@protoc_insertion_point(field_mutable:sliverpb.SideloadReq.Args)
  return _s;
}
inline const std::string& SideloadReq::_internal_args() const {
  return _impl_.args_.Get();
}
inline void SideloadReq::_internal_set_args(const std::string& value) {
  
  _impl_.args_.Set(value, GetArenaForAllocation());
}
inline std::string* SideloadReq::_internal_mutable_args() {
  
  return _impl_.args_.Mutable(GetArenaForAllocation());
}
inline std::string* SideloadReq::release_args() {
  // @@protoc_insertion_point(field_release:sliverpb.SideloadReq.Args)
  return _impl_.args_.Release();
}
inline void SideloadReq::set_allocated_args(std::string* args) {
  if (args != nullptr) {
    
  } else {
    
  }
  _impl_.args_.SetAllocated(args, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.args_.IsDefault()) {
    _impl_.args_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SideloadReq.Args)
}

// string EntryPoint = 4;
inline void SideloadReq::clear_entrypoint() {
  _impl_.entrypoint_.ClearToEmpty();
}
inline const std::string& SideloadReq::entrypoint() const {
  // @@protoc_insertion_point(field_get:sliverpb.SideloadReq.EntryPoint)
  return _internal_entrypoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SideloadReq::set_entrypoint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.entrypoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SideloadReq.EntryPoint)
}
inline std::string* SideloadReq::mutable_entrypoint() {
  std::string* _s = _internal_mutable_entrypoint();
  // @@protoc_insertion_point(field_mutable:sliverpb.SideloadReq.EntryPoint)
  return _s;
}
inline const std::string& SideloadReq::_internal_entrypoint() const {
  return _impl_.entrypoint_.Get();
}
inline void SideloadReq::_internal_set_entrypoint(const std::string& value) {
  
  _impl_.entrypoint_.Set(value, GetArenaForAllocation());
}
inline std::string* SideloadReq::_internal_mutable_entrypoint() {
  
  return _impl_.entrypoint_.Mutable(GetArenaForAllocation());
}
inline std::string* SideloadReq::release_entrypoint() {
  // @@protoc_insertion_point(field_release:sliverpb.SideloadReq.EntryPoint)
  return _impl_.entrypoint_.Release();
}
inline void SideloadReq::set_allocated_entrypoint(std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  _impl_.entrypoint_.SetAllocated(entrypoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.entrypoint_.IsDefault()) {
    _impl_.entrypoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SideloadReq.EntryPoint)
}

// bool Kill = 5;
inline void SideloadReq::clear_kill() {
  _impl_.kill_ = false;
}
inline bool SideloadReq::_internal_kill() const {
  return _impl_.kill_;
}
inline bool SideloadReq::kill() const {
  // @@protoc_insertion_point(field_get:sliverpb.SideloadReq.Kill)
  return _internal_kill();
}
inline void SideloadReq::_internal_set_kill(bool value) {
  
  _impl_.kill_ = value;
}
inline void SideloadReq::set_kill(bool value) {
  _internal_set_kill(value);
  // @@protoc_insertion_point(field_set:sliverpb.SideloadReq.Kill)
}

// bool isDLL = 6;
inline void SideloadReq::clear_isdll() {
  _impl_.isdll_ = false;
}
inline bool SideloadReq::_internal_isdll() const {
  return _impl_.isdll_;
}
inline bool SideloadReq::isdll() const {
  // @@protoc_insertion_point(field_get:sliverpb.SideloadReq.isDLL)
  return _internal_isdll();
}
inline void SideloadReq::_internal_set_isdll(bool value) {
  
  _impl_.isdll_ = value;
}
inline void SideloadReq::set_isdll(bool value) {
  _internal_set_isdll(value);
  // @@protoc_insertion_point(field_set:sliverpb.SideloadReq.isDLL)
}

// bool isUnicode = 7;
inline void SideloadReq::clear_isunicode() {
  _impl_.isunicode_ = false;
}
inline bool SideloadReq::_internal_isunicode() const {
  return _impl_.isunicode_;
}
inline bool SideloadReq::isunicode() const {
  // @@protoc_insertion_point(field_get:sliverpb.SideloadReq.isUnicode)
  return _internal_isunicode();
}
inline void SideloadReq::_internal_set_isunicode(bool value) {
  
  _impl_.isunicode_ = value;
}
inline void SideloadReq::set_isunicode(bool value) {
  _internal_set_isunicode(value);
  // @@protoc_insertion_point(field_set:sliverpb.SideloadReq.isUnicode)
}

// uint32 PPid = 10;
inline void SideloadReq::clear_ppid() {
  _impl_.ppid_ = 0u;
}
inline uint32_t SideloadReq::_internal_ppid() const {
  return _impl_.ppid_;
}
inline uint32_t SideloadReq::ppid() const {
  // @@protoc_insertion_point(field_get:sliverpb.SideloadReq.PPid)
  return _internal_ppid();
}
inline void SideloadReq::_internal_set_ppid(uint32_t value) {
  
  _impl_.ppid_ = value;
}
inline void SideloadReq::set_ppid(uint32_t value) {
  _internal_set_ppid(value);
  // @@protoc_insertion_point(field_set:sliverpb.SideloadReq.PPid)
}

// repeated string ProcessArgs = 11;
inline int SideloadReq::_internal_processargs_size() const {
  return _impl_.processargs_.size();
}
inline int SideloadReq::processargs_size() const {
  return _internal_processargs_size();
}
inline void SideloadReq::clear_processargs() {
  _impl_.processargs_.Clear();
}
inline std::string* SideloadReq::add_processargs() {
  std::string* _s = _internal_add_processargs();
  // @@protoc_insertion_point(field_add_mutable:sliverpb.SideloadReq.ProcessArgs)
  return _s;
}
inline const std::string& SideloadReq::_internal_processargs(int index) const {
  return _impl_.processargs_.Get(index);
}
inline const std::string& SideloadReq::processargs(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.SideloadReq.ProcessArgs)
  return _internal_processargs(index);
}
inline std::string* SideloadReq::mutable_processargs(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.SideloadReq.ProcessArgs)
  return _impl_.processargs_.Mutable(index);
}
inline void SideloadReq::set_processargs(int index, const std::string& value) {
  _impl_.processargs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sliverpb.SideloadReq.ProcessArgs)
}
inline void SideloadReq::set_processargs(int index, std::string&& value) {
  _impl_.processargs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sliverpb.SideloadReq.ProcessArgs)
}
inline void SideloadReq::set_processargs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.processargs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sliverpb.SideloadReq.ProcessArgs)
}
inline void SideloadReq::set_processargs(int index, const char* value, size_t size) {
  _impl_.processargs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sliverpb.SideloadReq.ProcessArgs)
}
inline std::string* SideloadReq::_internal_add_processargs() {
  return _impl_.processargs_.Add();
}
inline void SideloadReq::add_processargs(const std::string& value) {
  _impl_.processargs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sliverpb.SideloadReq.ProcessArgs)
}
inline void SideloadReq::add_processargs(std::string&& value) {
  _impl_.processargs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sliverpb.SideloadReq.ProcessArgs)
}
inline void SideloadReq::add_processargs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.processargs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sliverpb.SideloadReq.ProcessArgs)
}
inline void SideloadReq::add_processargs(const char* value, size_t size) {
  _impl_.processargs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sliverpb.SideloadReq.ProcessArgs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SideloadReq::processargs() const {
  // @@protoc_insertion_point(field_list:sliverpb.SideloadReq.ProcessArgs)
  return _impl_.processargs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SideloadReq::mutable_processargs() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.SideloadReq.ProcessArgs)
  return &_impl_.processargs_;
}

// .sliverpb.Request Request = 9;
inline bool SideloadReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool SideloadReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& SideloadReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& SideloadReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.SideloadReq.Request)
  return _internal_request();
}
inline void SideloadReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.SideloadReq.Request)
}
inline ::sliverpb::Request* SideloadReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* SideloadReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.SideloadReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* SideloadReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* SideloadReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.SideloadReq.Request)
  return _msg;
}
inline void SideloadReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SideloadReq.Request)
}

// -------------------------------------------------------------------

// Sideload

// string Result = 1;
inline void Sideload::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& Sideload::result() const {
  // @@protoc_insertion_point(field_get:sliverpb.Sideload.Result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Sideload::set_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Sideload.Result)
}
inline std::string* Sideload::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:sliverpb.Sideload.Result)
  return _s;
}
inline const std::string& Sideload::_internal_result() const {
  return _impl_.result_.Get();
}
inline void Sideload::_internal_set_result(const std::string& value) {
  
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* Sideload::_internal_mutable_result() {
  
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* Sideload::release_result() {
  // @@protoc_insertion_point(field_release:sliverpb.Sideload.Result)
  return _impl_.result_.Release();
}
inline void Sideload::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Sideload.Result)
}

// .sliverpb.Response Response = 9;
inline bool Sideload::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Sideload::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Sideload::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Sideload::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Sideload.Response)
  return _internal_response();
}
inline void Sideload::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Sideload.Response)
}
inline ::sliverpb::Response* Sideload::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Sideload::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Sideload.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Sideload::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Sideload::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Sideload.Response)
  return _msg;
}
inline void Sideload::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Sideload.Response)
}

// -------------------------------------------------------------------

// InvokeSpawnDllReq

// bytes Data = 1;
inline void InvokeSpawnDllReq::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& InvokeSpawnDllReq::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeSpawnDllReq.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeSpawnDllReq::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.InvokeSpawnDllReq.Data)
}
inline std::string* InvokeSpawnDllReq::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeSpawnDllReq.Data)
  return _s;
}
inline const std::string& InvokeSpawnDllReq::_internal_data() const {
  return _impl_.data_.Get();
}
inline void InvokeSpawnDllReq::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeSpawnDllReq::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeSpawnDllReq::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.InvokeSpawnDllReq.Data)
  return _impl_.data_.Release();
}
inline void InvokeSpawnDllReq::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.InvokeSpawnDllReq.Data)
}

// string ProcessName = 2;
inline void InvokeSpawnDllReq::clear_processname() {
  _impl_.processname_.ClearToEmpty();
}
inline const std::string& InvokeSpawnDllReq::processname() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeSpawnDllReq.ProcessName)
  return _internal_processname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeSpawnDllReq::set_processname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.processname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.InvokeSpawnDllReq.ProcessName)
}
inline std::string* InvokeSpawnDllReq::mutable_processname() {
  std::string* _s = _internal_mutable_processname();
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeSpawnDllReq.ProcessName)
  return _s;
}
inline const std::string& InvokeSpawnDllReq::_internal_processname() const {
  return _impl_.processname_.Get();
}
inline void InvokeSpawnDllReq::_internal_set_processname(const std::string& value) {
  
  _impl_.processname_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeSpawnDllReq::_internal_mutable_processname() {
  
  return _impl_.processname_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeSpawnDllReq::release_processname() {
  // @@protoc_insertion_point(field_release:sliverpb.InvokeSpawnDllReq.ProcessName)
  return _impl_.processname_.Release();
}
inline void InvokeSpawnDllReq::set_allocated_processname(std::string* processname) {
  if (processname != nullptr) {
    
  } else {
    
  }
  _impl_.processname_.SetAllocated(processname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.processname_.IsDefault()) {
    _impl_.processname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.InvokeSpawnDllReq.ProcessName)
}

// string Args = 3;
inline void InvokeSpawnDllReq::clear_args() {
  _impl_.args_.ClearToEmpty();
}
inline const std::string& InvokeSpawnDllReq::args() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeSpawnDllReq.Args)
  return _internal_args();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeSpawnDllReq::set_args(ArgT0&& arg0, ArgT... args) {
 
 _impl_.args_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.InvokeSpawnDllReq.Args)
}
inline std::string* InvokeSpawnDllReq::mutable_args() {
  std::string* _s = _internal_mutable_args();
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeSpawnDllReq.Args)
  return _s;
}
inline const std::string& InvokeSpawnDllReq::_internal_args() const {
  return _impl_.args_.Get();
}
inline void InvokeSpawnDllReq::_internal_set_args(const std::string& value) {
  
  _impl_.args_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeSpawnDllReq::_internal_mutable_args() {
  
  return _impl_.args_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeSpawnDllReq::release_args() {
  // @@protoc_insertion_point(field_release:sliverpb.InvokeSpawnDllReq.Args)
  return _impl_.args_.Release();
}
inline void InvokeSpawnDllReq::set_allocated_args(std::string* args) {
  if (args != nullptr) {
    
  } else {
    
  }
  _impl_.args_.SetAllocated(args, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.args_.IsDefault()) {
    _impl_.args_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.InvokeSpawnDllReq.Args)
}

// string EntryPoint = 4;
inline void InvokeSpawnDllReq::clear_entrypoint() {
  _impl_.entrypoint_.ClearToEmpty();
}
inline const std::string& InvokeSpawnDllReq::entrypoint() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeSpawnDllReq.EntryPoint)
  return _internal_entrypoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeSpawnDllReq::set_entrypoint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.entrypoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.InvokeSpawnDllReq.EntryPoint)
}
inline std::string* InvokeSpawnDllReq::mutable_entrypoint() {
  std::string* _s = _internal_mutable_entrypoint();
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeSpawnDllReq.EntryPoint)
  return _s;
}
inline const std::string& InvokeSpawnDllReq::_internal_entrypoint() const {
  return _impl_.entrypoint_.Get();
}
inline void InvokeSpawnDllReq::_internal_set_entrypoint(const std::string& value) {
  
  _impl_.entrypoint_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeSpawnDllReq::_internal_mutable_entrypoint() {
  
  return _impl_.entrypoint_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeSpawnDllReq::release_entrypoint() {
  // @@protoc_insertion_point(field_release:sliverpb.InvokeSpawnDllReq.EntryPoint)
  return _impl_.entrypoint_.Release();
}
inline void InvokeSpawnDllReq::set_allocated_entrypoint(std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  _impl_.entrypoint_.SetAllocated(entrypoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.entrypoint_.IsDefault()) {
    _impl_.entrypoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.InvokeSpawnDllReq.EntryPoint)
}

// bool Kill = 5;
inline void InvokeSpawnDllReq::clear_kill() {
  _impl_.kill_ = false;
}
inline bool InvokeSpawnDllReq::_internal_kill() const {
  return _impl_.kill_;
}
inline bool InvokeSpawnDllReq::kill() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeSpawnDllReq.Kill)
  return _internal_kill();
}
inline void InvokeSpawnDllReq::_internal_set_kill(bool value) {
  
  _impl_.kill_ = value;
}
inline void InvokeSpawnDllReq::set_kill(bool value) {
  _internal_set_kill(value);
  // @@protoc_insertion_point(field_set:sliverpb.InvokeSpawnDllReq.Kill)
}

// uint32 PPid = 10;
inline void InvokeSpawnDllReq::clear_ppid() {
  _impl_.ppid_ = 0u;
}
inline uint32_t InvokeSpawnDllReq::_internal_ppid() const {
  return _impl_.ppid_;
}
inline uint32_t InvokeSpawnDllReq::ppid() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeSpawnDllReq.PPid)
  return _internal_ppid();
}
inline void InvokeSpawnDllReq::_internal_set_ppid(uint32_t value) {
  
  _impl_.ppid_ = value;
}
inline void InvokeSpawnDllReq::set_ppid(uint32_t value) {
  _internal_set_ppid(value);
  // @@protoc_insertion_point(field_set:sliverpb.InvokeSpawnDllReq.PPid)
}

// repeated string ProcessArgs = 11;
inline int InvokeSpawnDllReq::_internal_processargs_size() const {
  return _impl_.processargs_.size();
}
inline int InvokeSpawnDllReq::processargs_size() const {
  return _internal_processargs_size();
}
inline void InvokeSpawnDllReq::clear_processargs() {
  _impl_.processargs_.Clear();
}
inline std::string* InvokeSpawnDllReq::add_processargs() {
  std::string* _s = _internal_add_processargs();
  // @@protoc_insertion_point(field_add_mutable:sliverpb.InvokeSpawnDllReq.ProcessArgs)
  return _s;
}
inline const std::string& InvokeSpawnDllReq::_internal_processargs(int index) const {
  return _impl_.processargs_.Get(index);
}
inline const std::string& InvokeSpawnDllReq::processargs(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeSpawnDllReq.ProcessArgs)
  return _internal_processargs(index);
}
inline std::string* InvokeSpawnDllReq::mutable_processargs(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeSpawnDllReq.ProcessArgs)
  return _impl_.processargs_.Mutable(index);
}
inline void InvokeSpawnDllReq::set_processargs(int index, const std::string& value) {
  _impl_.processargs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sliverpb.InvokeSpawnDllReq.ProcessArgs)
}
inline void InvokeSpawnDllReq::set_processargs(int index, std::string&& value) {
  _impl_.processargs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sliverpb.InvokeSpawnDllReq.ProcessArgs)
}
inline void InvokeSpawnDllReq::set_processargs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.processargs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sliverpb.InvokeSpawnDllReq.ProcessArgs)
}
inline void InvokeSpawnDllReq::set_processargs(int index, const char* value, size_t size) {
  _impl_.processargs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sliverpb.InvokeSpawnDllReq.ProcessArgs)
}
inline std::string* InvokeSpawnDllReq::_internal_add_processargs() {
  return _impl_.processargs_.Add();
}
inline void InvokeSpawnDllReq::add_processargs(const std::string& value) {
  _impl_.processargs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sliverpb.InvokeSpawnDllReq.ProcessArgs)
}
inline void InvokeSpawnDllReq::add_processargs(std::string&& value) {
  _impl_.processargs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sliverpb.InvokeSpawnDllReq.ProcessArgs)
}
inline void InvokeSpawnDllReq::add_processargs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.processargs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sliverpb.InvokeSpawnDllReq.ProcessArgs)
}
inline void InvokeSpawnDllReq::add_processargs(const char* value, size_t size) {
  _impl_.processargs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sliverpb.InvokeSpawnDllReq.ProcessArgs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InvokeSpawnDllReq::processargs() const {
  // @@protoc_insertion_point(field_list:sliverpb.InvokeSpawnDllReq.ProcessArgs)
  return _impl_.processargs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InvokeSpawnDllReq::mutable_processargs() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.InvokeSpawnDllReq.ProcessArgs)
  return &_impl_.processargs_;
}

// .sliverpb.Request Request = 9;
inline bool InvokeSpawnDllReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool InvokeSpawnDllReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& InvokeSpawnDllReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& InvokeSpawnDllReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.InvokeSpawnDllReq.Request)
  return _internal_request();
}
inline void InvokeSpawnDllReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.InvokeSpawnDllReq.Request)
}
inline ::sliverpb::Request* InvokeSpawnDllReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* InvokeSpawnDllReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.InvokeSpawnDllReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* InvokeSpawnDllReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* InvokeSpawnDllReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.InvokeSpawnDllReq.Request)
  return _msg;
}
inline void InvokeSpawnDllReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.InvokeSpawnDllReq.Request)
}

// -------------------------------------------------------------------

// SpawnDllReq

// bytes Data = 1;
inline void SpawnDllReq::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& SpawnDllReq::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.SpawnDllReq.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpawnDllReq::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SpawnDllReq.Data)
}
inline std::string* SpawnDllReq::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.SpawnDllReq.Data)
  return _s;
}
inline const std::string& SpawnDllReq::_internal_data() const {
  return _impl_.data_.Get();
}
inline void SpawnDllReq::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* SpawnDllReq::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* SpawnDllReq::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.SpawnDllReq.Data)
  return _impl_.data_.Release();
}
inline void SpawnDllReq::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SpawnDllReq.Data)
}

// string ProcessName = 2;
inline void SpawnDllReq::clear_processname() {
  _impl_.processname_.ClearToEmpty();
}
inline const std::string& SpawnDllReq::processname() const {
  // @@protoc_insertion_point(field_get:sliverpb.SpawnDllReq.ProcessName)
  return _internal_processname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpawnDllReq::set_processname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.processname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SpawnDllReq.ProcessName)
}
inline std::string* SpawnDllReq::mutable_processname() {
  std::string* _s = _internal_mutable_processname();
  // @@protoc_insertion_point(field_mutable:sliverpb.SpawnDllReq.ProcessName)
  return _s;
}
inline const std::string& SpawnDllReq::_internal_processname() const {
  return _impl_.processname_.Get();
}
inline void SpawnDllReq::_internal_set_processname(const std::string& value) {
  
  _impl_.processname_.Set(value, GetArenaForAllocation());
}
inline std::string* SpawnDllReq::_internal_mutable_processname() {
  
  return _impl_.processname_.Mutable(GetArenaForAllocation());
}
inline std::string* SpawnDllReq::release_processname() {
  // @@protoc_insertion_point(field_release:sliverpb.SpawnDllReq.ProcessName)
  return _impl_.processname_.Release();
}
inline void SpawnDllReq::set_allocated_processname(std::string* processname) {
  if (processname != nullptr) {
    
  } else {
    
  }
  _impl_.processname_.SetAllocated(processname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.processname_.IsDefault()) {
    _impl_.processname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SpawnDllReq.ProcessName)
}

// uint32 Offset = 3;
inline void SpawnDllReq::clear_offset() {
  _impl_.offset_ = 0u;
}
inline uint32_t SpawnDllReq::_internal_offset() const {
  return _impl_.offset_;
}
inline uint32_t SpawnDllReq::offset() const {
  // @@protoc_insertion_point(field_get:sliverpb.SpawnDllReq.Offset)
  return _internal_offset();
}
inline void SpawnDllReq::_internal_set_offset(uint32_t value) {
  
  _impl_.offset_ = value;
}
inline void SpawnDllReq::set_offset(uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:sliverpb.SpawnDllReq.Offset)
}

// string Args = 4;
inline void SpawnDllReq::clear_args() {
  _impl_.args_.ClearToEmpty();
}
inline const std::string& SpawnDllReq::args() const {
  // @@protoc_insertion_point(field_get:sliverpb.SpawnDllReq.Args)
  return _internal_args();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpawnDllReq::set_args(ArgT0&& arg0, ArgT... args) {
 
 _impl_.args_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SpawnDllReq.Args)
}
inline std::string* SpawnDllReq::mutable_args() {
  std::string* _s = _internal_mutable_args();
  // @@protoc_insertion_point(field_mutable:sliverpb.SpawnDllReq.Args)
  return _s;
}
inline const std::string& SpawnDllReq::_internal_args() const {
  return _impl_.args_.Get();
}
inline void SpawnDllReq::_internal_set_args(const std::string& value) {
  
  _impl_.args_.Set(value, GetArenaForAllocation());
}
inline std::string* SpawnDllReq::_internal_mutable_args() {
  
  return _impl_.args_.Mutable(GetArenaForAllocation());
}
inline std::string* SpawnDllReq::release_args() {
  // @@protoc_insertion_point(field_release:sliverpb.SpawnDllReq.Args)
  return _impl_.args_.Release();
}
inline void SpawnDllReq::set_allocated_args(std::string* args) {
  if (args != nullptr) {
    
  } else {
    
  }
  _impl_.args_.SetAllocated(args, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.args_.IsDefault()) {
    _impl_.args_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SpawnDllReq.Args)
}

// bool Kill = 5;
inline void SpawnDllReq::clear_kill() {
  _impl_.kill_ = false;
}
inline bool SpawnDllReq::_internal_kill() const {
  return _impl_.kill_;
}
inline bool SpawnDllReq::kill() const {
  // @@protoc_insertion_point(field_get:sliverpb.SpawnDllReq.Kill)
  return _internal_kill();
}
inline void SpawnDllReq::_internal_set_kill(bool value) {
  
  _impl_.kill_ = value;
}
inline void SpawnDllReq::set_kill(bool value) {
  _internal_set_kill(value);
  // @@protoc_insertion_point(field_set:sliverpb.SpawnDllReq.Kill)
}

// uint32 PPid = 10;
inline void SpawnDllReq::clear_ppid() {
  _impl_.ppid_ = 0u;
}
inline uint32_t SpawnDllReq::_internal_ppid() const {
  return _impl_.ppid_;
}
inline uint32_t SpawnDllReq::ppid() const {
  // @@protoc_insertion_point(field_get:sliverpb.SpawnDllReq.PPid)
  return _internal_ppid();
}
inline void SpawnDllReq::_internal_set_ppid(uint32_t value) {
  
  _impl_.ppid_ = value;
}
inline void SpawnDllReq::set_ppid(uint32_t value) {
  _internal_set_ppid(value);
  // @@protoc_insertion_point(field_set:sliverpb.SpawnDllReq.PPid)
}

// repeated string ProcessArgs = 11;
inline int SpawnDllReq::_internal_processargs_size() const {
  return _impl_.processargs_.size();
}
inline int SpawnDllReq::processargs_size() const {
  return _internal_processargs_size();
}
inline void SpawnDllReq::clear_processargs() {
  _impl_.processargs_.Clear();
}
inline std::string* SpawnDllReq::add_processargs() {
  std::string* _s = _internal_add_processargs();
  // @@protoc_insertion_point(field_add_mutable:sliverpb.SpawnDllReq.ProcessArgs)
  return _s;
}
inline const std::string& SpawnDllReq::_internal_processargs(int index) const {
  return _impl_.processargs_.Get(index);
}
inline const std::string& SpawnDllReq::processargs(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.SpawnDllReq.ProcessArgs)
  return _internal_processargs(index);
}
inline std::string* SpawnDllReq::mutable_processargs(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.SpawnDllReq.ProcessArgs)
  return _impl_.processargs_.Mutable(index);
}
inline void SpawnDllReq::set_processargs(int index, const std::string& value) {
  _impl_.processargs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sliverpb.SpawnDllReq.ProcessArgs)
}
inline void SpawnDllReq::set_processargs(int index, std::string&& value) {
  _impl_.processargs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sliverpb.SpawnDllReq.ProcessArgs)
}
inline void SpawnDllReq::set_processargs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.processargs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sliverpb.SpawnDllReq.ProcessArgs)
}
inline void SpawnDllReq::set_processargs(int index, const char* value, size_t size) {
  _impl_.processargs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sliverpb.SpawnDllReq.ProcessArgs)
}
inline std::string* SpawnDllReq::_internal_add_processargs() {
  return _impl_.processargs_.Add();
}
inline void SpawnDllReq::add_processargs(const std::string& value) {
  _impl_.processargs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sliverpb.SpawnDllReq.ProcessArgs)
}
inline void SpawnDllReq::add_processargs(std::string&& value) {
  _impl_.processargs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sliverpb.SpawnDllReq.ProcessArgs)
}
inline void SpawnDllReq::add_processargs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.processargs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sliverpb.SpawnDllReq.ProcessArgs)
}
inline void SpawnDllReq::add_processargs(const char* value, size_t size) {
  _impl_.processargs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sliverpb.SpawnDllReq.ProcessArgs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SpawnDllReq::processargs() const {
  // @@protoc_insertion_point(field_list:sliverpb.SpawnDllReq.ProcessArgs)
  return _impl_.processargs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SpawnDllReq::mutable_processargs() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.SpawnDllReq.ProcessArgs)
  return &_impl_.processargs_;
}

// .sliverpb.Request Request = 9;
inline bool SpawnDllReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool SpawnDllReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& SpawnDllReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& SpawnDllReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.SpawnDllReq.Request)
  return _internal_request();
}
inline void SpawnDllReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.SpawnDllReq.Request)
}
inline ::sliverpb::Request* SpawnDllReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* SpawnDllReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.SpawnDllReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* SpawnDllReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* SpawnDllReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.SpawnDllReq.Request)
  return _msg;
}
inline void SpawnDllReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SpawnDllReq.Request)
}

// -------------------------------------------------------------------

// SpawnDll

// string Result = 1;
inline void SpawnDll::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& SpawnDll::result() const {
  // @@protoc_insertion_point(field_get:sliverpb.SpawnDll.Result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpawnDll::set_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SpawnDll.Result)
}
inline std::string* SpawnDll::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:sliverpb.SpawnDll.Result)
  return _s;
}
inline const std::string& SpawnDll::_internal_result() const {
  return _impl_.result_.Get();
}
inline void SpawnDll::_internal_set_result(const std::string& value) {
  
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* SpawnDll::_internal_mutable_result() {
  
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* SpawnDll::release_result() {
  // @@protoc_insertion_point(field_release:sliverpb.SpawnDll.Result)
  return _impl_.result_.Release();
}
inline void SpawnDll::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SpawnDll.Result)
}

// .sliverpb.Response Response = 9;
inline bool SpawnDll::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool SpawnDll::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& SpawnDll::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& SpawnDll::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.SpawnDll.Response)
  return _internal_response();
}
inline void SpawnDll::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.SpawnDll.Response)
}
inline ::sliverpb::Response* SpawnDll::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* SpawnDll::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.SpawnDll.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* SpawnDll::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* SpawnDll::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.SpawnDll.Response)
  return _msg;
}
inline void SpawnDll::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SpawnDll.Response)
}

// -------------------------------------------------------------------

// NetstatReq

// bool TCP = 1;
inline void NetstatReq::clear_tcp() {
  _impl_.tcp_ = false;
}
inline bool NetstatReq::_internal_tcp() const {
  return _impl_.tcp_;
}
inline bool NetstatReq::tcp() const {
  // @@protoc_insertion_point(field_get:sliverpb.NetstatReq.TCP)
  return _internal_tcp();
}
inline void NetstatReq::_internal_set_tcp(bool value) {
  
  _impl_.tcp_ = value;
}
inline void NetstatReq::set_tcp(bool value) {
  _internal_set_tcp(value);
  // @@protoc_insertion_point(field_set:sliverpb.NetstatReq.TCP)
}

// bool UDP = 2;
inline void NetstatReq::clear_udp() {
  _impl_.udp_ = false;
}
inline bool NetstatReq::_internal_udp() const {
  return _impl_.udp_;
}
inline bool NetstatReq::udp() const {
  // @@protoc_insertion_point(field_get:sliverpb.NetstatReq.UDP)
  return _internal_udp();
}
inline void NetstatReq::_internal_set_udp(bool value) {
  
  _impl_.udp_ = value;
}
inline void NetstatReq::set_udp(bool value) {
  _internal_set_udp(value);
  // @@protoc_insertion_point(field_set:sliverpb.NetstatReq.UDP)
}

// bool IP4 = 3;
inline void NetstatReq::clear_ip4() {
  _impl_.ip4_ = false;
}
inline bool NetstatReq::_internal_ip4() const {
  return _impl_.ip4_;
}
inline bool NetstatReq::ip4() const {
  // @@protoc_insertion_point(field_get:sliverpb.NetstatReq.IP4)
  return _internal_ip4();
}
inline void NetstatReq::_internal_set_ip4(bool value) {
  
  _impl_.ip4_ = value;
}
inline void NetstatReq::set_ip4(bool value) {
  _internal_set_ip4(value);
  // @@protoc_insertion_point(field_set:sliverpb.NetstatReq.IP4)
}

// bool IP6 = 5;
inline void NetstatReq::clear_ip6() {
  _impl_.ip6_ = false;
}
inline bool NetstatReq::_internal_ip6() const {
  return _impl_.ip6_;
}
inline bool NetstatReq::ip6() const {
  // @@protoc_insertion_point(field_get:sliverpb.NetstatReq.IP6)
  return _internal_ip6();
}
inline void NetstatReq::_internal_set_ip6(bool value) {
  
  _impl_.ip6_ = value;
}
inline void NetstatReq::set_ip6(bool value) {
  _internal_set_ip6(value);
  // @@protoc_insertion_point(field_set:sliverpb.NetstatReq.IP6)
}

// bool Listening = 6;
inline void NetstatReq::clear_listening() {
  _impl_.listening_ = false;
}
inline bool NetstatReq::_internal_listening() const {
  return _impl_.listening_;
}
inline bool NetstatReq::listening() const {
  // @@protoc_insertion_point(field_get:sliverpb.NetstatReq.Listening)
  return _internal_listening();
}
inline void NetstatReq::_internal_set_listening(bool value) {
  
  _impl_.listening_ = value;
}
inline void NetstatReq::set_listening(bool value) {
  _internal_set_listening(value);
  // @@protoc_insertion_point(field_set:sliverpb.NetstatReq.Listening)
}

// .sliverpb.Request Request = 9;
inline bool NetstatReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool NetstatReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& NetstatReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& NetstatReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.NetstatReq.Request)
  return _internal_request();
}
inline void NetstatReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.NetstatReq.Request)
}
inline ::sliverpb::Request* NetstatReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* NetstatReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.NetstatReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* NetstatReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* NetstatReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.NetstatReq.Request)
  return _msg;
}
inline void NetstatReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.NetstatReq.Request)
}

// -------------------------------------------------------------------

// SockTabEntry_SockAddr

// string Ip = 1;
inline void SockTabEntry_SockAddr::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& SockTabEntry_SockAddr::ip() const {
  // @@protoc_insertion_point(field_get:sliverpb.SockTabEntry.SockAddr.Ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SockTabEntry_SockAddr::set_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SockTabEntry.SockAddr.Ip)
}
inline std::string* SockTabEntry_SockAddr::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:sliverpb.SockTabEntry.SockAddr.Ip)
  return _s;
}
inline const std::string& SockTabEntry_SockAddr::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void SockTabEntry_SockAddr::_internal_set_ip(const std::string& value) {
  
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* SockTabEntry_SockAddr::_internal_mutable_ip() {
  
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* SockTabEntry_SockAddr::release_ip() {
  // @@protoc_insertion_point(field_release:sliverpb.SockTabEntry.SockAddr.Ip)
  return _impl_.ip_.Release();
}
inline void SockTabEntry_SockAddr::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SockTabEntry.SockAddr.Ip)
}

// uint32 Port = 2;
inline void SockTabEntry_SockAddr::clear_port() {
  _impl_.port_ = 0u;
}
inline uint32_t SockTabEntry_SockAddr::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t SockTabEntry_SockAddr::port() const {
  // @@protoc_insertion_point(field_get:sliverpb.SockTabEntry.SockAddr.Port)
  return _internal_port();
}
inline void SockTabEntry_SockAddr::_internal_set_port(uint32_t value) {
  
  _impl_.port_ = value;
}
inline void SockTabEntry_SockAddr::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:sliverpb.SockTabEntry.SockAddr.Port)
}

// -------------------------------------------------------------------

// SockTabEntry

// .sliverpb.SockTabEntry.SockAddr LocalAddr = 1;
inline bool SockTabEntry::_internal_has_localaddr() const {
  return this != internal_default_instance() && _impl_.localaddr_ != nullptr;
}
inline bool SockTabEntry::has_localaddr() const {
  return _internal_has_localaddr();
}
inline void SockTabEntry::clear_localaddr() {
  if (GetArenaForAllocation() == nullptr && _impl_.localaddr_ != nullptr) {
    delete _impl_.localaddr_;
  }
  _impl_.localaddr_ = nullptr;
}
inline const ::sliverpb::SockTabEntry_SockAddr& SockTabEntry::_internal_localaddr() const {
  const ::sliverpb::SockTabEntry_SockAddr* p = _impl_.localaddr_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::SockTabEntry_SockAddr&>(
      ::sliverpb::_SockTabEntry_SockAddr_default_instance_);
}
inline const ::sliverpb::SockTabEntry_SockAddr& SockTabEntry::localaddr() const {
  // @@protoc_insertion_point(field_get:sliverpb.SockTabEntry.LocalAddr)
  return _internal_localaddr();
}
inline void SockTabEntry::unsafe_arena_set_allocated_localaddr(
    ::sliverpb::SockTabEntry_SockAddr* localaddr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.localaddr_);
  }
  _impl_.localaddr_ = localaddr;
  if (localaddr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.SockTabEntry.LocalAddr)
}
inline ::sliverpb::SockTabEntry_SockAddr* SockTabEntry::release_localaddr() {
  
  ::sliverpb::SockTabEntry_SockAddr* temp = _impl_.localaddr_;
  _impl_.localaddr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::SockTabEntry_SockAddr* SockTabEntry::unsafe_arena_release_localaddr() {
  // @@protoc_insertion_point(field_release:sliverpb.SockTabEntry.LocalAddr)
  
  ::sliverpb::SockTabEntry_SockAddr* temp = _impl_.localaddr_;
  _impl_.localaddr_ = nullptr;
  return temp;
}
inline ::sliverpb::SockTabEntry_SockAddr* SockTabEntry::_internal_mutable_localaddr() {
  
  if (_impl_.localaddr_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::SockTabEntry_SockAddr>(GetArenaForAllocation());
    _impl_.localaddr_ = p;
  }
  return _impl_.localaddr_;
}
inline ::sliverpb::SockTabEntry_SockAddr* SockTabEntry::mutable_localaddr() {
  ::sliverpb::SockTabEntry_SockAddr* _msg = _internal_mutable_localaddr();
  // @@protoc_insertion_point(field_mutable:sliverpb.SockTabEntry.LocalAddr)
  return _msg;
}
inline void SockTabEntry::set_allocated_localaddr(::sliverpb::SockTabEntry_SockAddr* localaddr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.localaddr_;
  }
  if (localaddr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(localaddr);
    if (message_arena != submessage_arena) {
      localaddr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, localaddr, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.localaddr_ = localaddr;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SockTabEntry.LocalAddr)
}

// .sliverpb.SockTabEntry.SockAddr RemoteAddr = 2;
inline bool SockTabEntry::_internal_has_remoteaddr() const {
  return this != internal_default_instance() && _impl_.remoteaddr_ != nullptr;
}
inline bool SockTabEntry::has_remoteaddr() const {
  return _internal_has_remoteaddr();
}
inline void SockTabEntry::clear_remoteaddr() {
  if (GetArenaForAllocation() == nullptr && _impl_.remoteaddr_ != nullptr) {
    delete _impl_.remoteaddr_;
  }
  _impl_.remoteaddr_ = nullptr;
}
inline const ::sliverpb::SockTabEntry_SockAddr& SockTabEntry::_internal_remoteaddr() const {
  const ::sliverpb::SockTabEntry_SockAddr* p = _impl_.remoteaddr_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::SockTabEntry_SockAddr&>(
      ::sliverpb::_SockTabEntry_SockAddr_default_instance_);
}
inline const ::sliverpb::SockTabEntry_SockAddr& SockTabEntry::remoteaddr() const {
  // @@protoc_insertion_point(field_get:sliverpb.SockTabEntry.RemoteAddr)
  return _internal_remoteaddr();
}
inline void SockTabEntry::unsafe_arena_set_allocated_remoteaddr(
    ::sliverpb::SockTabEntry_SockAddr* remoteaddr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remoteaddr_);
  }
  _impl_.remoteaddr_ = remoteaddr;
  if (remoteaddr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.SockTabEntry.RemoteAddr)
}
inline ::sliverpb::SockTabEntry_SockAddr* SockTabEntry::release_remoteaddr() {
  
  ::sliverpb::SockTabEntry_SockAddr* temp = _impl_.remoteaddr_;
  _impl_.remoteaddr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::SockTabEntry_SockAddr* SockTabEntry::unsafe_arena_release_remoteaddr() {
  // @@protoc_insertion_point(field_release:sliverpb.SockTabEntry.RemoteAddr)
  
  ::sliverpb::SockTabEntry_SockAddr* temp = _impl_.remoteaddr_;
  _impl_.remoteaddr_ = nullptr;
  return temp;
}
inline ::sliverpb::SockTabEntry_SockAddr* SockTabEntry::_internal_mutable_remoteaddr() {
  
  if (_impl_.remoteaddr_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::SockTabEntry_SockAddr>(GetArenaForAllocation());
    _impl_.remoteaddr_ = p;
  }
  return _impl_.remoteaddr_;
}
inline ::sliverpb::SockTabEntry_SockAddr* SockTabEntry::mutable_remoteaddr() {
  ::sliverpb::SockTabEntry_SockAddr* _msg = _internal_mutable_remoteaddr();
  // @@protoc_insertion_point(field_mutable:sliverpb.SockTabEntry.RemoteAddr)
  return _msg;
}
inline void SockTabEntry::set_allocated_remoteaddr(::sliverpb::SockTabEntry_SockAddr* remoteaddr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.remoteaddr_;
  }
  if (remoteaddr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remoteaddr);
    if (message_arena != submessage_arena) {
      remoteaddr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remoteaddr, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.remoteaddr_ = remoteaddr;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SockTabEntry.RemoteAddr)
}

// string SkState = 3;
inline void SockTabEntry::clear_skstate() {
  _impl_.skstate_.ClearToEmpty();
}
inline const std::string& SockTabEntry::skstate() const {
  // @@protoc_insertion_point(field_get:sliverpb.SockTabEntry.SkState)
  return _internal_skstate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SockTabEntry::set_skstate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.skstate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SockTabEntry.SkState)
}
inline std::string* SockTabEntry::mutable_skstate() {
  std::string* _s = _internal_mutable_skstate();
  // @@protoc_insertion_point(field_mutable:sliverpb.SockTabEntry.SkState)
  return _s;
}
inline const std::string& SockTabEntry::_internal_skstate() const {
  return _impl_.skstate_.Get();
}
inline void SockTabEntry::_internal_set_skstate(const std::string& value) {
  
  _impl_.skstate_.Set(value, GetArenaForAllocation());
}
inline std::string* SockTabEntry::_internal_mutable_skstate() {
  
  return _impl_.skstate_.Mutable(GetArenaForAllocation());
}
inline std::string* SockTabEntry::release_skstate() {
  // @@protoc_insertion_point(field_release:sliverpb.SockTabEntry.SkState)
  return _impl_.skstate_.Release();
}
inline void SockTabEntry::set_allocated_skstate(std::string* skstate) {
  if (skstate != nullptr) {
    
  } else {
    
  }
  _impl_.skstate_.SetAllocated(skstate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.skstate_.IsDefault()) {
    _impl_.skstate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SockTabEntry.SkState)
}

// uint32 UID = 4;
inline void SockTabEntry::clear_uid() {
  _impl_.uid_ = 0u;
}
inline uint32_t SockTabEntry::_internal_uid() const {
  return _impl_.uid_;
}
inline uint32_t SockTabEntry::uid() const {
  // @@protoc_insertion_point(field_get:sliverpb.SockTabEntry.UID)
  return _internal_uid();
}
inline void SockTabEntry::_internal_set_uid(uint32_t value) {
  
  _impl_.uid_ = value;
}
inline void SockTabEntry::set_uid(uint32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:sliverpb.SockTabEntry.UID)
}

// .sliverpb.Process Process = 5;
inline bool SockTabEntry::_internal_has_process() const {
  return this != internal_default_instance() && _impl_.process_ != nullptr;
}
inline bool SockTabEntry::has_process() const {
  return _internal_has_process();
}
inline const ::sliverpb::Process& SockTabEntry::_internal_process() const {
  const ::sliverpb::Process* p = _impl_.process_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Process&>(
      ::sliverpb::_Process_default_instance_);
}
inline const ::sliverpb::Process& SockTabEntry::process() const {
  // @@protoc_insertion_point(field_get:sliverpb.SockTabEntry.Process)
  return _internal_process();
}
inline void SockTabEntry::unsafe_arena_set_allocated_process(
    ::sliverpb::Process* process) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.process_);
  }
  _impl_.process_ = process;
  if (process) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.SockTabEntry.Process)
}
inline ::sliverpb::Process* SockTabEntry::release_process() {
  
  ::sliverpb::Process* temp = _impl_.process_;
  _impl_.process_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Process* SockTabEntry::unsafe_arena_release_process() {
  // @@protoc_insertion_point(field_release:sliverpb.SockTabEntry.Process)
  
  ::sliverpb::Process* temp = _impl_.process_;
  _impl_.process_ = nullptr;
  return temp;
}
inline ::sliverpb::Process* SockTabEntry::_internal_mutable_process() {
  
  if (_impl_.process_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Process>(GetArenaForAllocation());
    _impl_.process_ = p;
  }
  return _impl_.process_;
}
inline ::sliverpb::Process* SockTabEntry::mutable_process() {
  ::sliverpb::Process* _msg = _internal_mutable_process();
  // @@protoc_insertion_point(field_mutable:sliverpb.SockTabEntry.Process)
  return _msg;
}
inline void SockTabEntry::set_allocated_process(::sliverpb::Process* process) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.process_);
  }
  if (process) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(process));
    if (message_arena != submessage_arena) {
      process = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, process, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.process_ = process;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SockTabEntry.Process)
}

// string Protocol = 6;
inline void SockTabEntry::clear_protocol() {
  _impl_.protocol_.ClearToEmpty();
}
inline const std::string& SockTabEntry::protocol() const {
  // @@protoc_insertion_point(field_get:sliverpb.SockTabEntry.Protocol)
  return _internal_protocol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SockTabEntry::set_protocol(ArgT0&& arg0, ArgT... args) {
 
 _impl_.protocol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SockTabEntry.Protocol)
}
inline std::string* SockTabEntry::mutable_protocol() {
  std::string* _s = _internal_mutable_protocol();
  // @@protoc_insertion_point(field_mutable:sliverpb.SockTabEntry.Protocol)
  return _s;
}
inline const std::string& SockTabEntry::_internal_protocol() const {
  return _impl_.protocol_.Get();
}
inline void SockTabEntry::_internal_set_protocol(const std::string& value) {
  
  _impl_.protocol_.Set(value, GetArenaForAllocation());
}
inline std::string* SockTabEntry::_internal_mutable_protocol() {
  
  return _impl_.protocol_.Mutable(GetArenaForAllocation());
}
inline std::string* SockTabEntry::release_protocol() {
  // @@protoc_insertion_point(field_release:sliverpb.SockTabEntry.Protocol)
  return _impl_.protocol_.Release();
}
inline void SockTabEntry::set_allocated_protocol(std::string* protocol) {
  if (protocol != nullptr) {
    
  } else {
    
  }
  _impl_.protocol_.SetAllocated(protocol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.protocol_.IsDefault()) {
    _impl_.protocol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SockTabEntry.Protocol)
}

// -------------------------------------------------------------------

// Netstat

// repeated .sliverpb.SockTabEntry Entries = 1;
inline int Netstat::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int Netstat::entries_size() const {
  return _internal_entries_size();
}
inline void Netstat::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::sliverpb::SockTabEntry* Netstat::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.Netstat.Entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::SockTabEntry >*
Netstat::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.Netstat.Entries)
  return &_impl_.entries_;
}
inline const ::sliverpb::SockTabEntry& Netstat::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::sliverpb::SockTabEntry& Netstat::entries(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.Netstat.Entries)
  return _internal_entries(index);
}
inline ::sliverpb::SockTabEntry* Netstat::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::sliverpb::SockTabEntry* Netstat::add_entries() {
  ::sliverpb::SockTabEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:sliverpb.Netstat.Entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::SockTabEntry >&
Netstat::entries() const {
  // @@protoc_insertion_point(field_list:sliverpb.Netstat.Entries)
  return _impl_.entries_;
}

// .sliverpb.Response Response = 9;
inline bool Netstat::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Netstat::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Netstat::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Netstat::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Netstat.Response)
  return _internal_response();
}
inline void Netstat::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Netstat.Response)
}
inline ::sliverpb::Response* Netstat::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Netstat::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Netstat.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Netstat::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Netstat::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Netstat.Response)
  return _msg;
}
inline void Netstat::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Netstat.Response)
}

// -------------------------------------------------------------------

// EnvReq

// string Name = 1;
inline void EnvReq::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& EnvReq::name() const {
  // @@protoc_insertion_point(field_get:sliverpb.EnvReq.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnvReq::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.EnvReq.Name)
}
inline std::string* EnvReq::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sliverpb.EnvReq.Name)
  return _s;
}
inline const std::string& EnvReq::_internal_name() const {
  return _impl_.name_.Get();
}
inline void EnvReq::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* EnvReq::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* EnvReq::release_name() {
  // @@protoc_insertion_point(field_release:sliverpb.EnvReq.Name)
  return _impl_.name_.Release();
}
inline void EnvReq::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.EnvReq.Name)
}

// .sliverpb.Request Request = 9;
inline bool EnvReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool EnvReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& EnvReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& EnvReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.EnvReq.Request)
  return _internal_request();
}
inline void EnvReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.EnvReq.Request)
}
inline ::sliverpb::Request* EnvReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* EnvReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.EnvReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* EnvReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* EnvReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.EnvReq.Request)
  return _msg;
}
inline void EnvReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.EnvReq.Request)
}

// -------------------------------------------------------------------

// EnvInfo

// repeated .sliverpb.EnvVar Variables = 1;
inline int EnvInfo::_internal_variables_size() const {
  return _impl_.variables_.size();
}
inline int EnvInfo::variables_size() const {
  return _internal_variables_size();
}
inline ::sliverpb::EnvVar* EnvInfo::mutable_variables(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.EnvInfo.Variables)
  return _impl_.variables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::EnvVar >*
EnvInfo::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.EnvInfo.Variables)
  return &_impl_.variables_;
}
inline const ::sliverpb::EnvVar& EnvInfo::_internal_variables(int index) const {
  return _impl_.variables_.Get(index);
}
inline const ::sliverpb::EnvVar& EnvInfo::variables(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.EnvInfo.Variables)
  return _internal_variables(index);
}
inline ::sliverpb::EnvVar* EnvInfo::_internal_add_variables() {
  return _impl_.variables_.Add();
}
inline ::sliverpb::EnvVar* EnvInfo::add_variables() {
  ::sliverpb::EnvVar* _add = _internal_add_variables();
  // @@protoc_insertion_point(field_add:sliverpb.EnvInfo.Variables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::EnvVar >&
EnvInfo::variables() const {
  // @@protoc_insertion_point(field_list:sliverpb.EnvInfo.Variables)
  return _impl_.variables_;
}

// .sliverpb.Response Response = 9;
inline bool EnvInfo::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool EnvInfo::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& EnvInfo::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& EnvInfo::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.EnvInfo.Response)
  return _internal_response();
}
inline void EnvInfo::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.EnvInfo.Response)
}
inline ::sliverpb::Response* EnvInfo::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* EnvInfo::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.EnvInfo.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* EnvInfo::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* EnvInfo::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.EnvInfo.Response)
  return _msg;
}
inline void EnvInfo::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.EnvInfo.Response)
}

// -------------------------------------------------------------------

// SetEnvReq

// .sliverpb.EnvVar Variable = 1;
inline bool SetEnvReq::_internal_has_variable() const {
  return this != internal_default_instance() && _impl_.variable_ != nullptr;
}
inline bool SetEnvReq::has_variable() const {
  return _internal_has_variable();
}
inline const ::sliverpb::EnvVar& SetEnvReq::_internal_variable() const {
  const ::sliverpb::EnvVar* p = _impl_.variable_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::EnvVar&>(
      ::sliverpb::_EnvVar_default_instance_);
}
inline const ::sliverpb::EnvVar& SetEnvReq::variable() const {
  // @@protoc_insertion_point(field_get:sliverpb.SetEnvReq.Variable)
  return _internal_variable();
}
inline void SetEnvReq::unsafe_arena_set_allocated_variable(
    ::sliverpb::EnvVar* variable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.variable_);
  }
  _impl_.variable_ = variable;
  if (variable) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.SetEnvReq.Variable)
}
inline ::sliverpb::EnvVar* SetEnvReq::release_variable() {
  
  ::sliverpb::EnvVar* temp = _impl_.variable_;
  _impl_.variable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::EnvVar* SetEnvReq::unsafe_arena_release_variable() {
  // @@protoc_insertion_point(field_release:sliverpb.SetEnvReq.Variable)
  
  ::sliverpb::EnvVar* temp = _impl_.variable_;
  _impl_.variable_ = nullptr;
  return temp;
}
inline ::sliverpb::EnvVar* SetEnvReq::_internal_mutable_variable() {
  
  if (_impl_.variable_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::EnvVar>(GetArenaForAllocation());
    _impl_.variable_ = p;
  }
  return _impl_.variable_;
}
inline ::sliverpb::EnvVar* SetEnvReq::mutable_variable() {
  ::sliverpb::EnvVar* _msg = _internal_mutable_variable();
  // @@protoc_insertion_point(field_mutable:sliverpb.SetEnvReq.Variable)
  return _msg;
}
inline void SetEnvReq::set_allocated_variable(::sliverpb::EnvVar* variable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.variable_);
  }
  if (variable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(variable));
    if (message_arena != submessage_arena) {
      variable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, variable, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.variable_ = variable;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SetEnvReq.Variable)
}

// .sliverpb.Request Request = 9;
inline bool SetEnvReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool SetEnvReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& SetEnvReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& SetEnvReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.SetEnvReq.Request)
  return _internal_request();
}
inline void SetEnvReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.SetEnvReq.Request)
}
inline ::sliverpb::Request* SetEnvReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* SetEnvReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.SetEnvReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* SetEnvReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* SetEnvReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.SetEnvReq.Request)
  return _msg;
}
inline void SetEnvReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SetEnvReq.Request)
}

// -------------------------------------------------------------------

// SetEnv

// .sliverpb.Response Response = 9;
inline bool SetEnv::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool SetEnv::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& SetEnv::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& SetEnv::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.SetEnv.Response)
  return _internal_response();
}
inline void SetEnv::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.SetEnv.Response)
}
inline ::sliverpb::Response* SetEnv::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* SetEnv::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.SetEnv.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* SetEnv::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* SetEnv::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.SetEnv.Response)
  return _msg;
}
inline void SetEnv::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SetEnv.Response)
}

// -------------------------------------------------------------------

// UnsetEnvReq

// string Name = 1;
inline void UnsetEnvReq::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UnsetEnvReq::name() const {
  // @@protoc_insertion_point(field_get:sliverpb.UnsetEnvReq.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnsetEnvReq::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.UnsetEnvReq.Name)
}
inline std::string* UnsetEnvReq::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sliverpb.UnsetEnvReq.Name)
  return _s;
}
inline const std::string& UnsetEnvReq::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UnsetEnvReq::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UnsetEnvReq::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UnsetEnvReq::release_name() {
  // @@protoc_insertion_point(field_release:sliverpb.UnsetEnvReq.Name)
  return _impl_.name_.Release();
}
inline void UnsetEnvReq::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.UnsetEnvReq.Name)
}

// .sliverpb.Request Request = 9;
inline bool UnsetEnvReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool UnsetEnvReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& UnsetEnvReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& UnsetEnvReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.UnsetEnvReq.Request)
  return _internal_request();
}
inline void UnsetEnvReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.UnsetEnvReq.Request)
}
inline ::sliverpb::Request* UnsetEnvReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* UnsetEnvReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.UnsetEnvReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* UnsetEnvReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* UnsetEnvReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.UnsetEnvReq.Request)
  return _msg;
}
inline void UnsetEnvReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.UnsetEnvReq.Request)
}

// -------------------------------------------------------------------

// UnsetEnv

// .sliverpb.Response Response = 9;
inline bool UnsetEnv::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool UnsetEnv::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& UnsetEnv::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& UnsetEnv::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.UnsetEnv.Response)
  return _internal_response();
}
inline void UnsetEnv::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.UnsetEnv.Response)
}
inline ::sliverpb::Response* UnsetEnv::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* UnsetEnv::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.UnsetEnv.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* UnsetEnv::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* UnsetEnv::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.UnsetEnv.Response)
  return _msg;
}
inline void UnsetEnv::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.UnsetEnv.Response)
}

// -------------------------------------------------------------------

// DNSSessionInit

// bytes Key = 1;
inline void DNSSessionInit::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& DNSSessionInit::key() const {
  // @@protoc_insertion_point(field_get:sliverpb.DNSSessionInit.Key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DNSSessionInit::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.DNSSessionInit.Key)
}
inline std::string* DNSSessionInit::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:sliverpb.DNSSessionInit.Key)
  return _s;
}
inline const std::string& DNSSessionInit::_internal_key() const {
  return _impl_.key_.Get();
}
inline void DNSSessionInit::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* DNSSessionInit::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* DNSSessionInit::release_key() {
  // @@protoc_insertion_point(field_release:sliverpb.DNSSessionInit.Key)
  return _impl_.key_.Release();
}
inline void DNSSessionInit::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.DNSSessionInit.Key)
}

// -------------------------------------------------------------------

// DNSPoll

// repeated .sliverpb.DNSBlockHeader blocks = 1;
inline int DNSPoll::_internal_blocks_size() const {
  return _impl_.blocks_.size();
}
inline int DNSPoll::blocks_size() const {
  return _internal_blocks_size();
}
inline void DNSPoll::clear_blocks() {
  _impl_.blocks_.Clear();
}
inline ::sliverpb::DNSBlockHeader* DNSPoll::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.DNSPoll.blocks)
  return _impl_.blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::DNSBlockHeader >*
DNSPoll::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.DNSPoll.blocks)
  return &_impl_.blocks_;
}
inline const ::sliverpb::DNSBlockHeader& DNSPoll::_internal_blocks(int index) const {
  return _impl_.blocks_.Get(index);
}
inline const ::sliverpb::DNSBlockHeader& DNSPoll::blocks(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.DNSPoll.blocks)
  return _internal_blocks(index);
}
inline ::sliverpb::DNSBlockHeader* DNSPoll::_internal_add_blocks() {
  return _impl_.blocks_.Add();
}
inline ::sliverpb::DNSBlockHeader* DNSPoll::add_blocks() {
  ::sliverpb::DNSBlockHeader* _add = _internal_add_blocks();
  // @@protoc_insertion_point(field_add:sliverpb.DNSPoll.blocks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::DNSBlockHeader >&
DNSPoll::blocks() const {
  // @@protoc_insertion_point(field_list:sliverpb.DNSPoll.blocks)
  return _impl_.blocks_;
}

// -------------------------------------------------------------------

// DNSBlockHeader

// string ID = 1;
inline void DNSBlockHeader::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DNSBlockHeader::id() const {
  // @@protoc_insertion_point(field_get:sliverpb.DNSBlockHeader.ID)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DNSBlockHeader::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.DNSBlockHeader.ID)
}
inline std::string* DNSBlockHeader::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sliverpb.DNSBlockHeader.ID)
  return _s;
}
inline const std::string& DNSBlockHeader::_internal_id() const {
  return _impl_.id_.Get();
}
inline void DNSBlockHeader::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* DNSBlockHeader::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* DNSBlockHeader::release_id() {
  // @@protoc_insertion_point(field_release:sliverpb.DNSBlockHeader.ID)
  return _impl_.id_.Release();
}
inline void DNSBlockHeader::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.DNSBlockHeader.ID)
}

// uint32 Size = 2;
inline void DNSBlockHeader::clear_size() {
  _impl_.size_ = 0u;
}
inline uint32_t DNSBlockHeader::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t DNSBlockHeader::size() const {
  // @@protoc_insertion_point(field_get:sliverpb.DNSBlockHeader.Size)
  return _internal_size();
}
inline void DNSBlockHeader::_internal_set_size(uint32_t value) {
  
  _impl_.size_ = value;
}
inline void DNSBlockHeader::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:sliverpb.DNSBlockHeader.Size)
}

// -------------------------------------------------------------------

// HTTPSessionInit

// bytes Key = 1;
inline void HTTPSessionInit::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& HTTPSessionInit::key() const {
  // @@protoc_insertion_point(field_get:sliverpb.HTTPSessionInit.Key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HTTPSessionInit::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.HTTPSessionInit.Key)
}
inline std::string* HTTPSessionInit::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:sliverpb.HTTPSessionInit.Key)
  return _s;
}
inline const std::string& HTTPSessionInit::_internal_key() const {
  return _impl_.key_.Get();
}
inline void HTTPSessionInit::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* HTTPSessionInit::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* HTTPSessionInit::release_key() {
  // @@protoc_insertion_point(field_release:sliverpb.HTTPSessionInit.Key)
  return _impl_.key_.Release();
}
inline void HTTPSessionInit::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.HTTPSessionInit.Key)
}

// -------------------------------------------------------------------

// ScreenshotReq

// .sliverpb.Request Request = 9;
inline bool ScreenshotReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool ScreenshotReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& ScreenshotReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& ScreenshotReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.ScreenshotReq.Request)
  return _internal_request();
}
inline void ScreenshotReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.ScreenshotReq.Request)
}
inline ::sliverpb::Request* ScreenshotReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* ScreenshotReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.ScreenshotReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* ScreenshotReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* ScreenshotReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.ScreenshotReq.Request)
  return _msg;
}
inline void ScreenshotReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ScreenshotReq.Request)
}

// -------------------------------------------------------------------

// Screenshot

// bytes Data = 1;
inline void Screenshot::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Screenshot::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.Screenshot.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Screenshot::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Screenshot.Data)
}
inline std::string* Screenshot::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.Screenshot.Data)
  return _s;
}
inline const std::string& Screenshot::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Screenshot::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Screenshot::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Screenshot::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.Screenshot.Data)
  return _impl_.data_.Release();
}
inline void Screenshot::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Screenshot.Data)
}

// .sliverpb.Response Response = 9;
inline bool Screenshot::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Screenshot::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Screenshot::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Screenshot::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Screenshot.Response)
  return _internal_response();
}
inline void Screenshot::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Screenshot.Response)
}
inline ::sliverpb::Response* Screenshot::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Screenshot::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Screenshot.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Screenshot::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Screenshot::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Screenshot.Response)
  return _msg;
}
inline void Screenshot::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Screenshot.Response)
}

// -------------------------------------------------------------------

// StartServiceReq

// string ServiceName = 1;
inline void StartServiceReq::clear_servicename() {
  _impl_.servicename_.ClearToEmpty();
}
inline const std::string& StartServiceReq::servicename() const {
  // @@protoc_insertion_point(field_get:sliverpb.StartServiceReq.ServiceName)
  return _internal_servicename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartServiceReq::set_servicename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.servicename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.StartServiceReq.ServiceName)
}
inline std::string* StartServiceReq::mutable_servicename() {
  std::string* _s = _internal_mutable_servicename();
  // @@protoc_insertion_point(field_mutable:sliverpb.StartServiceReq.ServiceName)
  return _s;
}
inline const std::string& StartServiceReq::_internal_servicename() const {
  return _impl_.servicename_.Get();
}
inline void StartServiceReq::_internal_set_servicename(const std::string& value) {
  
  _impl_.servicename_.Set(value, GetArenaForAllocation());
}
inline std::string* StartServiceReq::_internal_mutable_servicename() {
  
  return _impl_.servicename_.Mutable(GetArenaForAllocation());
}
inline std::string* StartServiceReq::release_servicename() {
  // @@protoc_insertion_point(field_release:sliverpb.StartServiceReq.ServiceName)
  return _impl_.servicename_.Release();
}
inline void StartServiceReq::set_allocated_servicename(std::string* servicename) {
  if (servicename != nullptr) {
    
  } else {
    
  }
  _impl_.servicename_.SetAllocated(servicename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.servicename_.IsDefault()) {
    _impl_.servicename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.StartServiceReq.ServiceName)
}

// string ServiceDescription = 2;
inline void StartServiceReq::clear_servicedescription() {
  _impl_.servicedescription_.ClearToEmpty();
}
inline const std::string& StartServiceReq::servicedescription() const {
  // @@protoc_insertion_point(field_get:sliverpb.StartServiceReq.ServiceDescription)
  return _internal_servicedescription();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartServiceReq::set_servicedescription(ArgT0&& arg0, ArgT... args) {
 
 _impl_.servicedescription_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.StartServiceReq.ServiceDescription)
}
inline std::string* StartServiceReq::mutable_servicedescription() {
  std::string* _s = _internal_mutable_servicedescription();
  // @@protoc_insertion_point(field_mutable:sliverpb.StartServiceReq.ServiceDescription)
  return _s;
}
inline const std::string& StartServiceReq::_internal_servicedescription() const {
  return _impl_.servicedescription_.Get();
}
inline void StartServiceReq::_internal_set_servicedescription(const std::string& value) {
  
  _impl_.servicedescription_.Set(value, GetArenaForAllocation());
}
inline std::string* StartServiceReq::_internal_mutable_servicedescription() {
  
  return _impl_.servicedescription_.Mutable(GetArenaForAllocation());
}
inline std::string* StartServiceReq::release_servicedescription() {
  // @@protoc_insertion_point(field_release:sliverpb.StartServiceReq.ServiceDescription)
  return _impl_.servicedescription_.Release();
}
inline void StartServiceReq::set_allocated_servicedescription(std::string* servicedescription) {
  if (servicedescription != nullptr) {
    
  } else {
    
  }
  _impl_.servicedescription_.SetAllocated(servicedescription, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.servicedescription_.IsDefault()) {
    _impl_.servicedescription_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.StartServiceReq.ServiceDescription)
}

// string BinPath = 3;
inline void StartServiceReq::clear_binpath() {
  _impl_.binpath_.ClearToEmpty();
}
inline const std::string& StartServiceReq::binpath() const {
  // @@protoc_insertion_point(field_get:sliverpb.StartServiceReq.BinPath)
  return _internal_binpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartServiceReq::set_binpath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.binpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.StartServiceReq.BinPath)
}
inline std::string* StartServiceReq::mutable_binpath() {
  std::string* _s = _internal_mutable_binpath();
  // @@protoc_insertion_point(field_mutable:sliverpb.StartServiceReq.BinPath)
  return _s;
}
inline const std::string& StartServiceReq::_internal_binpath() const {
  return _impl_.binpath_.Get();
}
inline void StartServiceReq::_internal_set_binpath(const std::string& value) {
  
  _impl_.binpath_.Set(value, GetArenaForAllocation());
}
inline std::string* StartServiceReq::_internal_mutable_binpath() {
  
  return _impl_.binpath_.Mutable(GetArenaForAllocation());
}
inline std::string* StartServiceReq::release_binpath() {
  // @@protoc_insertion_point(field_release:sliverpb.StartServiceReq.BinPath)
  return _impl_.binpath_.Release();
}
inline void StartServiceReq::set_allocated_binpath(std::string* binpath) {
  if (binpath != nullptr) {
    
  } else {
    
  }
  _impl_.binpath_.SetAllocated(binpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.binpath_.IsDefault()) {
    _impl_.binpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.StartServiceReq.BinPath)
}

// string Hostname = 4;
inline void StartServiceReq::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& StartServiceReq::hostname() const {
  // @@protoc_insertion_point(field_get:sliverpb.StartServiceReq.Hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartServiceReq::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.StartServiceReq.Hostname)
}
inline std::string* StartServiceReq::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:sliverpb.StartServiceReq.Hostname)
  return _s;
}
inline const std::string& StartServiceReq::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void StartServiceReq::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* StartServiceReq::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* StartServiceReq::release_hostname() {
  // @@protoc_insertion_point(field_release:sliverpb.StartServiceReq.Hostname)
  return _impl_.hostname_.Release();
}
inline void StartServiceReq::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.StartServiceReq.Hostname)
}

// string Arguments = 5;
inline void StartServiceReq::clear_arguments() {
  _impl_.arguments_.ClearToEmpty();
}
inline const std::string& StartServiceReq::arguments() const {
  // @@protoc_insertion_point(field_get:sliverpb.StartServiceReq.Arguments)
  return _internal_arguments();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartServiceReq::set_arguments(ArgT0&& arg0, ArgT... args) {
 
 _impl_.arguments_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.StartServiceReq.Arguments)
}
inline std::string* StartServiceReq::mutable_arguments() {
  std::string* _s = _internal_mutable_arguments();
  // @@protoc_insertion_point(field_mutable:sliverpb.StartServiceReq.Arguments)
  return _s;
}
inline const std::string& StartServiceReq::_internal_arguments() const {
  return _impl_.arguments_.Get();
}
inline void StartServiceReq::_internal_set_arguments(const std::string& value) {
  
  _impl_.arguments_.Set(value, GetArenaForAllocation());
}
inline std::string* StartServiceReq::_internal_mutable_arguments() {
  
  return _impl_.arguments_.Mutable(GetArenaForAllocation());
}
inline std::string* StartServiceReq::release_arguments() {
  // @@protoc_insertion_point(field_release:sliverpb.StartServiceReq.Arguments)
  return _impl_.arguments_.Release();
}
inline void StartServiceReq::set_allocated_arguments(std::string* arguments) {
  if (arguments != nullptr) {
    
  } else {
    
  }
  _impl_.arguments_.SetAllocated(arguments, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.arguments_.IsDefault()) {
    _impl_.arguments_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.StartServiceReq.Arguments)
}

// .sliverpb.Request Request = 9;
inline bool StartServiceReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool StartServiceReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& StartServiceReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& StartServiceReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.StartServiceReq.Request)
  return _internal_request();
}
inline void StartServiceReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.StartServiceReq.Request)
}
inline ::sliverpb::Request* StartServiceReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* StartServiceReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.StartServiceReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* StartServiceReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* StartServiceReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.StartServiceReq.Request)
  return _msg;
}
inline void StartServiceReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.StartServiceReq.Request)
}

// -------------------------------------------------------------------

// ServiceInfo

// .sliverpb.Response Response = 9;
inline bool ServiceInfo::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool ServiceInfo::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& ServiceInfo::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& ServiceInfo::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.ServiceInfo.Response)
  return _internal_response();
}
inline void ServiceInfo::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.ServiceInfo.Response)
}
inline ::sliverpb::Response* ServiceInfo::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* ServiceInfo::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.ServiceInfo.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* ServiceInfo::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* ServiceInfo::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.ServiceInfo.Response)
  return _msg;
}
inline void ServiceInfo::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ServiceInfo.Response)
}

// -------------------------------------------------------------------

// ServiceInfoReq

// string ServiceName = 1;
inline void ServiceInfoReq::clear_servicename() {
  _impl_.servicename_.ClearToEmpty();
}
inline const std::string& ServiceInfoReq::servicename() const {
  // @@protoc_insertion_point(field_get:sliverpb.ServiceInfoReq.ServiceName)
  return _internal_servicename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceInfoReq::set_servicename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.servicename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ServiceInfoReq.ServiceName)
}
inline std::string* ServiceInfoReq::mutable_servicename() {
  std::string* _s = _internal_mutable_servicename();
  // @@protoc_insertion_point(field_mutable:sliverpb.ServiceInfoReq.ServiceName)
  return _s;
}
inline const std::string& ServiceInfoReq::_internal_servicename() const {
  return _impl_.servicename_.Get();
}
inline void ServiceInfoReq::_internal_set_servicename(const std::string& value) {
  
  _impl_.servicename_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceInfoReq::_internal_mutable_servicename() {
  
  return _impl_.servicename_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceInfoReq::release_servicename() {
  // @@protoc_insertion_point(field_release:sliverpb.ServiceInfoReq.ServiceName)
  return _impl_.servicename_.Release();
}
inline void ServiceInfoReq::set_allocated_servicename(std::string* servicename) {
  if (servicename != nullptr) {
    
  } else {
    
  }
  _impl_.servicename_.SetAllocated(servicename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.servicename_.IsDefault()) {
    _impl_.servicename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ServiceInfoReq.ServiceName)
}

// string Hostname = 2;
inline void ServiceInfoReq::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& ServiceInfoReq::hostname() const {
  // @@protoc_insertion_point(field_get:sliverpb.ServiceInfoReq.Hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceInfoReq::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ServiceInfoReq.Hostname)
}
inline std::string* ServiceInfoReq::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:sliverpb.ServiceInfoReq.Hostname)
  return _s;
}
inline const std::string& ServiceInfoReq::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void ServiceInfoReq::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceInfoReq::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceInfoReq::release_hostname() {
  // @@protoc_insertion_point(field_release:sliverpb.ServiceInfoReq.Hostname)
  return _impl_.hostname_.Release();
}
inline void ServiceInfoReq::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ServiceInfoReq.Hostname)
}

// -------------------------------------------------------------------

// StopServiceReq

// .sliverpb.ServiceInfoReq ServiceInfo = 1;
inline bool StopServiceReq::_internal_has_serviceinfo() const {
  return this != internal_default_instance() && _impl_.serviceinfo_ != nullptr;
}
inline bool StopServiceReq::has_serviceinfo() const {
  return _internal_has_serviceinfo();
}
inline void StopServiceReq::clear_serviceinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.serviceinfo_ != nullptr) {
    delete _impl_.serviceinfo_;
  }
  _impl_.serviceinfo_ = nullptr;
}
inline const ::sliverpb::ServiceInfoReq& StopServiceReq::_internal_serviceinfo() const {
  const ::sliverpb::ServiceInfoReq* p = _impl_.serviceinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::ServiceInfoReq&>(
      ::sliverpb::_ServiceInfoReq_default_instance_);
}
inline const ::sliverpb::ServiceInfoReq& StopServiceReq::serviceinfo() const {
  // @@protoc_insertion_point(field_get:sliverpb.StopServiceReq.ServiceInfo)
  return _internal_serviceinfo();
}
inline void StopServiceReq::unsafe_arena_set_allocated_serviceinfo(
    ::sliverpb::ServiceInfoReq* serviceinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.serviceinfo_);
  }
  _impl_.serviceinfo_ = serviceinfo;
  if (serviceinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.StopServiceReq.ServiceInfo)
}
inline ::sliverpb::ServiceInfoReq* StopServiceReq::release_serviceinfo() {
  
  ::sliverpb::ServiceInfoReq* temp = _impl_.serviceinfo_;
  _impl_.serviceinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::ServiceInfoReq* StopServiceReq::unsafe_arena_release_serviceinfo() {
  // @@protoc_insertion_point(field_release:sliverpb.StopServiceReq.ServiceInfo)
  
  ::sliverpb::ServiceInfoReq* temp = _impl_.serviceinfo_;
  _impl_.serviceinfo_ = nullptr;
  return temp;
}
inline ::sliverpb::ServiceInfoReq* StopServiceReq::_internal_mutable_serviceinfo() {
  
  if (_impl_.serviceinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::ServiceInfoReq>(GetArenaForAllocation());
    _impl_.serviceinfo_ = p;
  }
  return _impl_.serviceinfo_;
}
inline ::sliverpb::ServiceInfoReq* StopServiceReq::mutable_serviceinfo() {
  ::sliverpb::ServiceInfoReq* _msg = _internal_mutable_serviceinfo();
  // @@protoc_insertion_point(field_mutable:sliverpb.StopServiceReq.ServiceInfo)
  return _msg;
}
inline void StopServiceReq::set_allocated_serviceinfo(::sliverpb::ServiceInfoReq* serviceinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.serviceinfo_;
  }
  if (serviceinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(serviceinfo);
    if (message_arena != submessage_arena) {
      serviceinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, serviceinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.serviceinfo_ = serviceinfo;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.StopServiceReq.ServiceInfo)
}

// .sliverpb.Request Request = 9;
inline bool StopServiceReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool StopServiceReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& StopServiceReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& StopServiceReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.StopServiceReq.Request)
  return _internal_request();
}
inline void StopServiceReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.StopServiceReq.Request)
}
inline ::sliverpb::Request* StopServiceReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* StopServiceReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.StopServiceReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* StopServiceReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* StopServiceReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.StopServiceReq.Request)
  return _msg;
}
inline void StopServiceReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.StopServiceReq.Request)
}

// -------------------------------------------------------------------

// RemoveServiceReq

// .sliverpb.ServiceInfoReq ServiceInfo = 1;
inline bool RemoveServiceReq::_internal_has_serviceinfo() const {
  return this != internal_default_instance() && _impl_.serviceinfo_ != nullptr;
}
inline bool RemoveServiceReq::has_serviceinfo() const {
  return _internal_has_serviceinfo();
}
inline void RemoveServiceReq::clear_serviceinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.serviceinfo_ != nullptr) {
    delete _impl_.serviceinfo_;
  }
  _impl_.serviceinfo_ = nullptr;
}
inline const ::sliverpb::ServiceInfoReq& RemoveServiceReq::_internal_serviceinfo() const {
  const ::sliverpb::ServiceInfoReq* p = _impl_.serviceinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::ServiceInfoReq&>(
      ::sliverpb::_ServiceInfoReq_default_instance_);
}
inline const ::sliverpb::ServiceInfoReq& RemoveServiceReq::serviceinfo() const {
  // @@protoc_insertion_point(field_get:sliverpb.RemoveServiceReq.ServiceInfo)
  return _internal_serviceinfo();
}
inline void RemoveServiceReq::unsafe_arena_set_allocated_serviceinfo(
    ::sliverpb::ServiceInfoReq* serviceinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.serviceinfo_);
  }
  _impl_.serviceinfo_ = serviceinfo;
  if (serviceinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RemoveServiceReq.ServiceInfo)
}
inline ::sliverpb::ServiceInfoReq* RemoveServiceReq::release_serviceinfo() {
  
  ::sliverpb::ServiceInfoReq* temp = _impl_.serviceinfo_;
  _impl_.serviceinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::ServiceInfoReq* RemoveServiceReq::unsafe_arena_release_serviceinfo() {
  // @@protoc_insertion_point(field_release:sliverpb.RemoveServiceReq.ServiceInfo)
  
  ::sliverpb::ServiceInfoReq* temp = _impl_.serviceinfo_;
  _impl_.serviceinfo_ = nullptr;
  return temp;
}
inline ::sliverpb::ServiceInfoReq* RemoveServiceReq::_internal_mutable_serviceinfo() {
  
  if (_impl_.serviceinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::ServiceInfoReq>(GetArenaForAllocation());
    _impl_.serviceinfo_ = p;
  }
  return _impl_.serviceinfo_;
}
inline ::sliverpb::ServiceInfoReq* RemoveServiceReq::mutable_serviceinfo() {
  ::sliverpb::ServiceInfoReq* _msg = _internal_mutable_serviceinfo();
  // @@protoc_insertion_point(field_mutable:sliverpb.RemoveServiceReq.ServiceInfo)
  return _msg;
}
inline void RemoveServiceReq::set_allocated_serviceinfo(::sliverpb::ServiceInfoReq* serviceinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.serviceinfo_;
  }
  if (serviceinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(serviceinfo);
    if (message_arena != submessage_arena) {
      serviceinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, serviceinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.serviceinfo_ = serviceinfo;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RemoveServiceReq.ServiceInfo)
}

// .sliverpb.Request Request = 9;
inline bool RemoveServiceReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool RemoveServiceReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& RemoveServiceReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& RemoveServiceReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.RemoveServiceReq.Request)
  return _internal_request();
}
inline void RemoveServiceReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RemoveServiceReq.Request)
}
inline ::sliverpb::Request* RemoveServiceReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* RemoveServiceReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.RemoveServiceReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* RemoveServiceReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* RemoveServiceReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.RemoveServiceReq.Request)
  return _msg;
}
inline void RemoveServiceReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RemoveServiceReq.Request)
}

// -------------------------------------------------------------------

// BackdoorReq

// string FilePath = 1;
inline void BackdoorReq::clear_filepath() {
  _impl_.filepath_.ClearToEmpty();
}
inline const std::string& BackdoorReq::filepath() const {
  // @@protoc_insertion_point(field_get:sliverpb.BackdoorReq.FilePath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BackdoorReq::set_filepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.BackdoorReq.FilePath)
}
inline std::string* BackdoorReq::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:sliverpb.BackdoorReq.FilePath)
  return _s;
}
inline const std::string& BackdoorReq::_internal_filepath() const {
  return _impl_.filepath_.Get();
}
inline void BackdoorReq::_internal_set_filepath(const std::string& value) {
  
  _impl_.filepath_.Set(value, GetArenaForAllocation());
}
inline std::string* BackdoorReq::_internal_mutable_filepath() {
  
  return _impl_.filepath_.Mutable(GetArenaForAllocation());
}
inline std::string* BackdoorReq::release_filepath() {
  // @@protoc_insertion_point(field_release:sliverpb.BackdoorReq.FilePath)
  return _impl_.filepath_.Release();
}
inline void BackdoorReq::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    
  } else {
    
  }
  _impl_.filepath_.SetAllocated(filepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.BackdoorReq.FilePath)
}

// string ProfileName = 2;
inline void BackdoorReq::clear_profilename() {
  _impl_.profilename_.ClearToEmpty();
}
inline const std::string& BackdoorReq::profilename() const {
  // @@protoc_insertion_point(field_get:sliverpb.BackdoorReq.ProfileName)
  return _internal_profilename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BackdoorReq::set_profilename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.profilename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.BackdoorReq.ProfileName)
}
inline std::string* BackdoorReq::mutable_profilename() {
  std::string* _s = _internal_mutable_profilename();
  // @@protoc_insertion_point(field_mutable:sliverpb.BackdoorReq.ProfileName)
  return _s;
}
inline const std::string& BackdoorReq::_internal_profilename() const {
  return _impl_.profilename_.Get();
}
inline void BackdoorReq::_internal_set_profilename(const std::string& value) {
  
  _impl_.profilename_.Set(value, GetArenaForAllocation());
}
inline std::string* BackdoorReq::_internal_mutable_profilename() {
  
  return _impl_.profilename_.Mutable(GetArenaForAllocation());
}
inline std::string* BackdoorReq::release_profilename() {
  // @@protoc_insertion_point(field_release:sliverpb.BackdoorReq.ProfileName)
  return _impl_.profilename_.Release();
}
inline void BackdoorReq::set_allocated_profilename(std::string* profilename) {
  if (profilename != nullptr) {
    
  } else {
    
  }
  _impl_.profilename_.SetAllocated(profilename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profilename_.IsDefault()) {
    _impl_.profilename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.BackdoorReq.ProfileName)
}

// .sliverpb.Request Request = 9;
inline bool BackdoorReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool BackdoorReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& BackdoorReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& BackdoorReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.BackdoorReq.Request)
  return _internal_request();
}
inline void BackdoorReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.BackdoorReq.Request)
}
inline ::sliverpb::Request* BackdoorReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* BackdoorReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.BackdoorReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* BackdoorReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* BackdoorReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.BackdoorReq.Request)
  return _msg;
}
inline void BackdoorReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.BackdoorReq.Request)
}

// -------------------------------------------------------------------

// Backdoor

// .sliverpb.Response Response = 9;
inline bool Backdoor::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Backdoor::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Backdoor::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Backdoor::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Backdoor.Response)
  return _internal_response();
}
inline void Backdoor::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Backdoor.Response)
}
inline ::sliverpb::Response* Backdoor::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Backdoor::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Backdoor.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Backdoor::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Backdoor::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Backdoor.Response)
  return _msg;
}
inline void Backdoor::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Backdoor.Response)
}

// -------------------------------------------------------------------

// RegistryReadReq

// string Hive = 1;
inline void RegistryReadReq::clear_hive() {
  _impl_.hive_.ClearToEmpty();
}
inline const std::string& RegistryReadReq::hive() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryReadReq.Hive)
  return _internal_hive();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryReadReq::set_hive(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hive_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryReadReq.Hive)
}
inline std::string* RegistryReadReq::mutable_hive() {
  std::string* _s = _internal_mutable_hive();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryReadReq.Hive)
  return _s;
}
inline const std::string& RegistryReadReq::_internal_hive() const {
  return _impl_.hive_.Get();
}
inline void RegistryReadReq::_internal_set_hive(const std::string& value) {
  
  _impl_.hive_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryReadReq::_internal_mutable_hive() {
  
  return _impl_.hive_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryReadReq::release_hive() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryReadReq.Hive)
  return _impl_.hive_.Release();
}
inline void RegistryReadReq::set_allocated_hive(std::string* hive) {
  if (hive != nullptr) {
    
  } else {
    
  }
  _impl_.hive_.SetAllocated(hive, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hive_.IsDefault()) {
    _impl_.hive_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryReadReq.Hive)
}

// string Path = 2;
inline void RegistryReadReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& RegistryReadReq::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryReadReq.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryReadReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryReadReq.Path)
}
inline std::string* RegistryReadReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryReadReq.Path)
  return _s;
}
inline const std::string& RegistryReadReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void RegistryReadReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryReadReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryReadReq::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryReadReq.Path)
  return _impl_.path_.Release();
}
inline void RegistryReadReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryReadReq.Path)
}

// string Key = 3;
inline void RegistryReadReq::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& RegistryReadReq::key() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryReadReq.Key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryReadReq::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryReadReq.Key)
}
inline std::string* RegistryReadReq::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryReadReq.Key)
  return _s;
}
inline const std::string& RegistryReadReq::_internal_key() const {
  return _impl_.key_.Get();
}
inline void RegistryReadReq::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryReadReq::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryReadReq::release_key() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryReadReq.Key)
  return _impl_.key_.Release();
}
inline void RegistryReadReq::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryReadReq.Key)
}

// string Hostname = 4;
inline void RegistryReadReq::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& RegistryReadReq::hostname() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryReadReq.Hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryReadReq::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryReadReq.Hostname)
}
inline std::string* RegistryReadReq::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryReadReq.Hostname)
  return _s;
}
inline const std::string& RegistryReadReq::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void RegistryReadReq::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryReadReq::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryReadReq::release_hostname() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryReadReq.Hostname)
  return _impl_.hostname_.Release();
}
inline void RegistryReadReq::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryReadReq.Hostname)
}

// .sliverpb.Request Request = 9;
inline bool RegistryReadReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool RegistryReadReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& RegistryReadReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& RegistryReadReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryReadReq.Request)
  return _internal_request();
}
inline void RegistryReadReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RegistryReadReq.Request)
}
inline ::sliverpb::Request* RegistryReadReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* RegistryReadReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryReadReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* RegistryReadReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* RegistryReadReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryReadReq.Request)
  return _msg;
}
inline void RegistryReadReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryReadReq.Request)
}

// -------------------------------------------------------------------

// RegistryRead

// string Value = 1;
inline void RegistryRead::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& RegistryRead::value() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryRead.Value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryRead::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryRead.Value)
}
inline std::string* RegistryRead::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryRead.Value)
  return _s;
}
inline const std::string& RegistryRead::_internal_value() const {
  return _impl_.value_.Get();
}
inline void RegistryRead::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryRead::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryRead::release_value() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryRead.Value)
  return _impl_.value_.Release();
}
inline void RegistryRead::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryRead.Value)
}

// .sliverpb.Response Response = 9;
inline bool RegistryRead::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool RegistryRead::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& RegistryRead::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& RegistryRead::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryRead.Response)
  return _internal_response();
}
inline void RegistryRead::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RegistryRead.Response)
}
inline ::sliverpb::Response* RegistryRead::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* RegistryRead::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryRead.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* RegistryRead::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* RegistryRead::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryRead.Response)
  return _msg;
}
inline void RegistryRead::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryRead.Response)
}

// -------------------------------------------------------------------

// RegistryWriteReq

// string Hive = 1;
inline void RegistryWriteReq::clear_hive() {
  _impl_.hive_.ClearToEmpty();
}
inline const std::string& RegistryWriteReq::hive() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryWriteReq.Hive)
  return _internal_hive();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryWriteReq::set_hive(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hive_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryWriteReq.Hive)
}
inline std::string* RegistryWriteReq::mutable_hive() {
  std::string* _s = _internal_mutable_hive();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryWriteReq.Hive)
  return _s;
}
inline const std::string& RegistryWriteReq::_internal_hive() const {
  return _impl_.hive_.Get();
}
inline void RegistryWriteReq::_internal_set_hive(const std::string& value) {
  
  _impl_.hive_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryWriteReq::_internal_mutable_hive() {
  
  return _impl_.hive_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryWriteReq::release_hive() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryWriteReq.Hive)
  return _impl_.hive_.Release();
}
inline void RegistryWriteReq::set_allocated_hive(std::string* hive) {
  if (hive != nullptr) {
    
  } else {
    
  }
  _impl_.hive_.SetAllocated(hive, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hive_.IsDefault()) {
    _impl_.hive_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryWriteReq.Hive)
}

// string Path = 2;
inline void RegistryWriteReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& RegistryWriteReq::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryWriteReq.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryWriteReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryWriteReq.Path)
}
inline std::string* RegistryWriteReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryWriteReq.Path)
  return _s;
}
inline const std::string& RegistryWriteReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void RegistryWriteReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryWriteReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryWriteReq::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryWriteReq.Path)
  return _impl_.path_.Release();
}
inline void RegistryWriteReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryWriteReq.Path)
}

// string Key = 3;
inline void RegistryWriteReq::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& RegistryWriteReq::key() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryWriteReq.Key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryWriteReq::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryWriteReq.Key)
}
inline std::string* RegistryWriteReq::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryWriteReq.Key)
  return _s;
}
inline const std::string& RegistryWriteReq::_internal_key() const {
  return _impl_.key_.Get();
}
inline void RegistryWriteReq::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryWriteReq::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryWriteReq::release_key() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryWriteReq.Key)
  return _impl_.key_.Release();
}
inline void RegistryWriteReq::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryWriteReq.Key)
}

// string Hostname = 4;
inline void RegistryWriteReq::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& RegistryWriteReq::hostname() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryWriteReq.Hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryWriteReq::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryWriteReq.Hostname)
}
inline std::string* RegistryWriteReq::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryWriteReq.Hostname)
  return _s;
}
inline const std::string& RegistryWriteReq::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void RegistryWriteReq::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryWriteReq::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryWriteReq::release_hostname() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryWriteReq.Hostname)
  return _impl_.hostname_.Release();
}
inline void RegistryWriteReq::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryWriteReq.Hostname)
}

// string StringValue = 5;
inline void RegistryWriteReq::clear_stringvalue() {
  _impl_.stringvalue_.ClearToEmpty();
}
inline const std::string& RegistryWriteReq::stringvalue() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryWriteReq.StringValue)
  return _internal_stringvalue();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryWriteReq::set_stringvalue(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stringvalue_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryWriteReq.StringValue)
}
inline std::string* RegistryWriteReq::mutable_stringvalue() {
  std::string* _s = _internal_mutable_stringvalue();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryWriteReq.StringValue)
  return _s;
}
inline const std::string& RegistryWriteReq::_internal_stringvalue() const {
  return _impl_.stringvalue_.Get();
}
inline void RegistryWriteReq::_internal_set_stringvalue(const std::string& value) {
  
  _impl_.stringvalue_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryWriteReq::_internal_mutable_stringvalue() {
  
  return _impl_.stringvalue_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryWriteReq::release_stringvalue() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryWriteReq.StringValue)
  return _impl_.stringvalue_.Release();
}
inline void RegistryWriteReq::set_allocated_stringvalue(std::string* stringvalue) {
  if (stringvalue != nullptr) {
    
  } else {
    
  }
  _impl_.stringvalue_.SetAllocated(stringvalue, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stringvalue_.IsDefault()) {
    _impl_.stringvalue_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryWriteReq.StringValue)
}

// bytes ByteValue = 6;
inline void RegistryWriteReq::clear_bytevalue() {
  _impl_.bytevalue_.ClearToEmpty();
}
inline const std::string& RegistryWriteReq::bytevalue() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryWriteReq.ByteValue)
  return _internal_bytevalue();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryWriteReq::set_bytevalue(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bytevalue_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryWriteReq.ByteValue)
}
inline std::string* RegistryWriteReq::mutable_bytevalue() {
  std::string* _s = _internal_mutable_bytevalue();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryWriteReq.ByteValue)
  return _s;
}
inline const std::string& RegistryWriteReq::_internal_bytevalue() const {
  return _impl_.bytevalue_.Get();
}
inline void RegistryWriteReq::_internal_set_bytevalue(const std::string& value) {
  
  _impl_.bytevalue_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryWriteReq::_internal_mutable_bytevalue() {
  
  return _impl_.bytevalue_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryWriteReq::release_bytevalue() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryWriteReq.ByteValue)
  return _impl_.bytevalue_.Release();
}
inline void RegistryWriteReq::set_allocated_bytevalue(std::string* bytevalue) {
  if (bytevalue != nullptr) {
    
  } else {
    
  }
  _impl_.bytevalue_.SetAllocated(bytevalue, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bytevalue_.IsDefault()) {
    _impl_.bytevalue_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryWriteReq.ByteValue)
}

// uint32 DWordValue = 7;
inline void RegistryWriteReq::clear_dwordvalue() {
  _impl_.dwordvalue_ = 0u;
}
inline uint32_t RegistryWriteReq::_internal_dwordvalue() const {
  return _impl_.dwordvalue_;
}
inline uint32_t RegistryWriteReq::dwordvalue() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryWriteReq.DWordValue)
  return _internal_dwordvalue();
}
inline void RegistryWriteReq::_internal_set_dwordvalue(uint32_t value) {
  
  _impl_.dwordvalue_ = value;
}
inline void RegistryWriteReq::set_dwordvalue(uint32_t value) {
  _internal_set_dwordvalue(value);
  // @@protoc_insertion_point(field_set:sliverpb.RegistryWriteReq.DWordValue)
}

// uint64 QWordValue = 8;
inline void RegistryWriteReq::clear_qwordvalue() {
  _impl_.qwordvalue_ = uint64_t{0u};
}
inline uint64_t RegistryWriteReq::_internal_qwordvalue() const {
  return _impl_.qwordvalue_;
}
inline uint64_t RegistryWriteReq::qwordvalue() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryWriteReq.QWordValue)
  return _internal_qwordvalue();
}
inline void RegistryWriteReq::_internal_set_qwordvalue(uint64_t value) {
  
  _impl_.qwordvalue_ = value;
}
inline void RegistryWriteReq::set_qwordvalue(uint64_t value) {
  _internal_set_qwordvalue(value);
  // @@protoc_insertion_point(field_set:sliverpb.RegistryWriteReq.QWordValue)
}

// uint32 Type = 10;
inline void RegistryWriteReq::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t RegistryWriteReq::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t RegistryWriteReq::type() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryWriteReq.Type)
  return _internal_type();
}
inline void RegistryWriteReq::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void RegistryWriteReq::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sliverpb.RegistryWriteReq.Type)
}

// .sliverpb.Request Request = 9;
inline bool RegistryWriteReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool RegistryWriteReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& RegistryWriteReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& RegistryWriteReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryWriteReq.Request)
  return _internal_request();
}
inline void RegistryWriteReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RegistryWriteReq.Request)
}
inline ::sliverpb::Request* RegistryWriteReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* RegistryWriteReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryWriteReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* RegistryWriteReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* RegistryWriteReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryWriteReq.Request)
  return _msg;
}
inline void RegistryWriteReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryWriteReq.Request)
}

// -------------------------------------------------------------------

// RegistryWrite

// .sliverpb.Response Response = 9;
inline bool RegistryWrite::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool RegistryWrite::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& RegistryWrite::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& RegistryWrite::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryWrite.Response)
  return _internal_response();
}
inline void RegistryWrite::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RegistryWrite.Response)
}
inline ::sliverpb::Response* RegistryWrite::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* RegistryWrite::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryWrite.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* RegistryWrite::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* RegistryWrite::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryWrite.Response)
  return _msg;
}
inline void RegistryWrite::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryWrite.Response)
}

// -------------------------------------------------------------------

// RegistryCreateKeyReq

// string Hive = 1;
inline void RegistryCreateKeyReq::clear_hive() {
  _impl_.hive_.ClearToEmpty();
}
inline const std::string& RegistryCreateKeyReq::hive() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryCreateKeyReq.Hive)
  return _internal_hive();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryCreateKeyReq::set_hive(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hive_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryCreateKeyReq.Hive)
}
inline std::string* RegistryCreateKeyReq::mutable_hive() {
  std::string* _s = _internal_mutable_hive();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryCreateKeyReq.Hive)
  return _s;
}
inline const std::string& RegistryCreateKeyReq::_internal_hive() const {
  return _impl_.hive_.Get();
}
inline void RegistryCreateKeyReq::_internal_set_hive(const std::string& value) {
  
  _impl_.hive_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryCreateKeyReq::_internal_mutable_hive() {
  
  return _impl_.hive_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryCreateKeyReq::release_hive() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryCreateKeyReq.Hive)
  return _impl_.hive_.Release();
}
inline void RegistryCreateKeyReq::set_allocated_hive(std::string* hive) {
  if (hive != nullptr) {
    
  } else {
    
  }
  _impl_.hive_.SetAllocated(hive, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hive_.IsDefault()) {
    _impl_.hive_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryCreateKeyReq.Hive)
}

// string Path = 2;
inline void RegistryCreateKeyReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& RegistryCreateKeyReq::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryCreateKeyReq.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryCreateKeyReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryCreateKeyReq.Path)
}
inline std::string* RegistryCreateKeyReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryCreateKeyReq.Path)
  return _s;
}
inline const std::string& RegistryCreateKeyReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void RegistryCreateKeyReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryCreateKeyReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryCreateKeyReq::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryCreateKeyReq.Path)
  return _impl_.path_.Release();
}
inline void RegistryCreateKeyReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryCreateKeyReq.Path)
}

// string Key = 3;
inline void RegistryCreateKeyReq::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& RegistryCreateKeyReq::key() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryCreateKeyReq.Key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryCreateKeyReq::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryCreateKeyReq.Key)
}
inline std::string* RegistryCreateKeyReq::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryCreateKeyReq.Key)
  return _s;
}
inline const std::string& RegistryCreateKeyReq::_internal_key() const {
  return _impl_.key_.Get();
}
inline void RegistryCreateKeyReq::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryCreateKeyReq::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryCreateKeyReq::release_key() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryCreateKeyReq.Key)
  return _impl_.key_.Release();
}
inline void RegistryCreateKeyReq::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryCreateKeyReq.Key)
}

// string Hostname = 4;
inline void RegistryCreateKeyReq::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& RegistryCreateKeyReq::hostname() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryCreateKeyReq.Hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryCreateKeyReq::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryCreateKeyReq.Hostname)
}
inline std::string* RegistryCreateKeyReq::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryCreateKeyReq.Hostname)
  return _s;
}
inline const std::string& RegistryCreateKeyReq::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void RegistryCreateKeyReq::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryCreateKeyReq::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryCreateKeyReq::release_hostname() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryCreateKeyReq.Hostname)
  return _impl_.hostname_.Release();
}
inline void RegistryCreateKeyReq::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryCreateKeyReq.Hostname)
}

// .sliverpb.Request Request = 9;
inline bool RegistryCreateKeyReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool RegistryCreateKeyReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& RegistryCreateKeyReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& RegistryCreateKeyReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryCreateKeyReq.Request)
  return _internal_request();
}
inline void RegistryCreateKeyReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RegistryCreateKeyReq.Request)
}
inline ::sliverpb::Request* RegistryCreateKeyReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* RegistryCreateKeyReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryCreateKeyReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* RegistryCreateKeyReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* RegistryCreateKeyReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryCreateKeyReq.Request)
  return _msg;
}
inline void RegistryCreateKeyReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryCreateKeyReq.Request)
}

// -------------------------------------------------------------------

// RegistryCreateKey

// .sliverpb.Response Response = 9;
inline bool RegistryCreateKey::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool RegistryCreateKey::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& RegistryCreateKey::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& RegistryCreateKey::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryCreateKey.Response)
  return _internal_response();
}
inline void RegistryCreateKey::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RegistryCreateKey.Response)
}
inline ::sliverpb::Response* RegistryCreateKey::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* RegistryCreateKey::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryCreateKey.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* RegistryCreateKey::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* RegistryCreateKey::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryCreateKey.Response)
  return _msg;
}
inline void RegistryCreateKey::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryCreateKey.Response)
}

// -------------------------------------------------------------------

// RegistryDeleteKeyReq

// string Hive = 1;
inline void RegistryDeleteKeyReq::clear_hive() {
  _impl_.hive_.ClearToEmpty();
}
inline const std::string& RegistryDeleteKeyReq::hive() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryDeleteKeyReq.Hive)
  return _internal_hive();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryDeleteKeyReq::set_hive(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hive_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryDeleteKeyReq.Hive)
}
inline std::string* RegistryDeleteKeyReq::mutable_hive() {
  std::string* _s = _internal_mutable_hive();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryDeleteKeyReq.Hive)
  return _s;
}
inline const std::string& RegistryDeleteKeyReq::_internal_hive() const {
  return _impl_.hive_.Get();
}
inline void RegistryDeleteKeyReq::_internal_set_hive(const std::string& value) {
  
  _impl_.hive_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryDeleteKeyReq::_internal_mutable_hive() {
  
  return _impl_.hive_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryDeleteKeyReq::release_hive() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryDeleteKeyReq.Hive)
  return _impl_.hive_.Release();
}
inline void RegistryDeleteKeyReq::set_allocated_hive(std::string* hive) {
  if (hive != nullptr) {
    
  } else {
    
  }
  _impl_.hive_.SetAllocated(hive, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hive_.IsDefault()) {
    _impl_.hive_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryDeleteKeyReq.Hive)
}

// string Path = 2;
inline void RegistryDeleteKeyReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& RegistryDeleteKeyReq::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryDeleteKeyReq.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryDeleteKeyReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryDeleteKeyReq.Path)
}
inline std::string* RegistryDeleteKeyReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryDeleteKeyReq.Path)
  return _s;
}
inline const std::string& RegistryDeleteKeyReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void RegistryDeleteKeyReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryDeleteKeyReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryDeleteKeyReq::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryDeleteKeyReq.Path)
  return _impl_.path_.Release();
}
inline void RegistryDeleteKeyReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryDeleteKeyReq.Path)
}

// string Key = 3;
inline void RegistryDeleteKeyReq::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& RegistryDeleteKeyReq::key() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryDeleteKeyReq.Key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryDeleteKeyReq::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryDeleteKeyReq.Key)
}
inline std::string* RegistryDeleteKeyReq::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryDeleteKeyReq.Key)
  return _s;
}
inline const std::string& RegistryDeleteKeyReq::_internal_key() const {
  return _impl_.key_.Get();
}
inline void RegistryDeleteKeyReq::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryDeleteKeyReq::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryDeleteKeyReq::release_key() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryDeleteKeyReq.Key)
  return _impl_.key_.Release();
}
inline void RegistryDeleteKeyReq::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryDeleteKeyReq.Key)
}

// string Hostname = 4;
inline void RegistryDeleteKeyReq::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& RegistryDeleteKeyReq::hostname() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryDeleteKeyReq.Hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryDeleteKeyReq::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryDeleteKeyReq.Hostname)
}
inline std::string* RegistryDeleteKeyReq::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryDeleteKeyReq.Hostname)
  return _s;
}
inline const std::string& RegistryDeleteKeyReq::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void RegistryDeleteKeyReq::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryDeleteKeyReq::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryDeleteKeyReq::release_hostname() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryDeleteKeyReq.Hostname)
  return _impl_.hostname_.Release();
}
inline void RegistryDeleteKeyReq::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryDeleteKeyReq.Hostname)
}

// .sliverpb.Request Request = 9;
inline bool RegistryDeleteKeyReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool RegistryDeleteKeyReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& RegistryDeleteKeyReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& RegistryDeleteKeyReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryDeleteKeyReq.Request)
  return _internal_request();
}
inline void RegistryDeleteKeyReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RegistryDeleteKeyReq.Request)
}
inline ::sliverpb::Request* RegistryDeleteKeyReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* RegistryDeleteKeyReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryDeleteKeyReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* RegistryDeleteKeyReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* RegistryDeleteKeyReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryDeleteKeyReq.Request)
  return _msg;
}
inline void RegistryDeleteKeyReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryDeleteKeyReq.Request)
}

// -------------------------------------------------------------------

// RegistryDeleteKey

// .sliverpb.Response Response = 9;
inline bool RegistryDeleteKey::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool RegistryDeleteKey::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& RegistryDeleteKey::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& RegistryDeleteKey::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryDeleteKey.Response)
  return _internal_response();
}
inline void RegistryDeleteKey::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RegistryDeleteKey.Response)
}
inline ::sliverpb::Response* RegistryDeleteKey::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* RegistryDeleteKey::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryDeleteKey.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* RegistryDeleteKey::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* RegistryDeleteKey::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryDeleteKey.Response)
  return _msg;
}
inline void RegistryDeleteKey::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryDeleteKey.Response)
}

// -------------------------------------------------------------------

// RegistrySubKeyListReq

// string Hive = 1;
inline void RegistrySubKeyListReq::clear_hive() {
  _impl_.hive_.ClearToEmpty();
}
inline const std::string& RegistrySubKeyListReq::hive() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistrySubKeyListReq.Hive)
  return _internal_hive();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistrySubKeyListReq::set_hive(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hive_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistrySubKeyListReq.Hive)
}
inline std::string* RegistrySubKeyListReq::mutable_hive() {
  std::string* _s = _internal_mutable_hive();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistrySubKeyListReq.Hive)
  return _s;
}
inline const std::string& RegistrySubKeyListReq::_internal_hive() const {
  return _impl_.hive_.Get();
}
inline void RegistrySubKeyListReq::_internal_set_hive(const std::string& value) {
  
  _impl_.hive_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistrySubKeyListReq::_internal_mutable_hive() {
  
  return _impl_.hive_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistrySubKeyListReq::release_hive() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistrySubKeyListReq.Hive)
  return _impl_.hive_.Release();
}
inline void RegistrySubKeyListReq::set_allocated_hive(std::string* hive) {
  if (hive != nullptr) {
    
  } else {
    
  }
  _impl_.hive_.SetAllocated(hive, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hive_.IsDefault()) {
    _impl_.hive_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistrySubKeyListReq.Hive)
}

// string Path = 2;
inline void RegistrySubKeyListReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& RegistrySubKeyListReq::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistrySubKeyListReq.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistrySubKeyListReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistrySubKeyListReq.Path)
}
inline std::string* RegistrySubKeyListReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistrySubKeyListReq.Path)
  return _s;
}
inline const std::string& RegistrySubKeyListReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void RegistrySubKeyListReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistrySubKeyListReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistrySubKeyListReq::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistrySubKeyListReq.Path)
  return _impl_.path_.Release();
}
inline void RegistrySubKeyListReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistrySubKeyListReq.Path)
}

// string Hostname = 4;
inline void RegistrySubKeyListReq::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& RegistrySubKeyListReq::hostname() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistrySubKeyListReq.Hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistrySubKeyListReq::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistrySubKeyListReq.Hostname)
}
inline std::string* RegistrySubKeyListReq::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistrySubKeyListReq.Hostname)
  return _s;
}
inline const std::string& RegistrySubKeyListReq::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void RegistrySubKeyListReq::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistrySubKeyListReq::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistrySubKeyListReq::release_hostname() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistrySubKeyListReq.Hostname)
  return _impl_.hostname_.Release();
}
inline void RegistrySubKeyListReq::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistrySubKeyListReq.Hostname)
}

// .sliverpb.Request Request = 9;
inline bool RegistrySubKeyListReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool RegistrySubKeyListReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& RegistrySubKeyListReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& RegistrySubKeyListReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistrySubKeyListReq.Request)
  return _internal_request();
}
inline void RegistrySubKeyListReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RegistrySubKeyListReq.Request)
}
inline ::sliverpb::Request* RegistrySubKeyListReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* RegistrySubKeyListReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistrySubKeyListReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* RegistrySubKeyListReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* RegistrySubKeyListReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistrySubKeyListReq.Request)
  return _msg;
}
inline void RegistrySubKeyListReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistrySubKeyListReq.Request)
}

// -------------------------------------------------------------------

// RegistrySubKeyList

// repeated string Subkeys = 1;
inline int RegistrySubKeyList::_internal_subkeys_size() const {
  return _impl_.subkeys_.size();
}
inline int RegistrySubKeyList::subkeys_size() const {
  return _internal_subkeys_size();
}
inline void RegistrySubKeyList::clear_subkeys() {
  _impl_.subkeys_.Clear();
}
inline std::string* RegistrySubKeyList::add_subkeys() {
  std::string* _s = _internal_add_subkeys();
  // @@protoc_insertion_point(field_add_mutable:sliverpb.RegistrySubKeyList.Subkeys)
  return _s;
}
inline const std::string& RegistrySubKeyList::_internal_subkeys(int index) const {
  return _impl_.subkeys_.Get(index);
}
inline const std::string& RegistrySubKeyList::subkeys(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistrySubKeyList.Subkeys)
  return _internal_subkeys(index);
}
inline std::string* RegistrySubKeyList::mutable_subkeys(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistrySubKeyList.Subkeys)
  return _impl_.subkeys_.Mutable(index);
}
inline void RegistrySubKeyList::set_subkeys(int index, const std::string& value) {
  _impl_.subkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sliverpb.RegistrySubKeyList.Subkeys)
}
inline void RegistrySubKeyList::set_subkeys(int index, std::string&& value) {
  _impl_.subkeys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sliverpb.RegistrySubKeyList.Subkeys)
}
inline void RegistrySubKeyList::set_subkeys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.subkeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sliverpb.RegistrySubKeyList.Subkeys)
}
inline void RegistrySubKeyList::set_subkeys(int index, const char* value, size_t size) {
  _impl_.subkeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sliverpb.RegistrySubKeyList.Subkeys)
}
inline std::string* RegistrySubKeyList::_internal_add_subkeys() {
  return _impl_.subkeys_.Add();
}
inline void RegistrySubKeyList::add_subkeys(const std::string& value) {
  _impl_.subkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sliverpb.RegistrySubKeyList.Subkeys)
}
inline void RegistrySubKeyList::add_subkeys(std::string&& value) {
  _impl_.subkeys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sliverpb.RegistrySubKeyList.Subkeys)
}
inline void RegistrySubKeyList::add_subkeys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.subkeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sliverpb.RegistrySubKeyList.Subkeys)
}
inline void RegistrySubKeyList::add_subkeys(const char* value, size_t size) {
  _impl_.subkeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sliverpb.RegistrySubKeyList.Subkeys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RegistrySubKeyList::subkeys() const {
  // @@protoc_insertion_point(field_list:sliverpb.RegistrySubKeyList.Subkeys)
  return _impl_.subkeys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RegistrySubKeyList::mutable_subkeys() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.RegistrySubKeyList.Subkeys)
  return &_impl_.subkeys_;
}

// .sliverpb.Response Response = 9;
inline bool RegistrySubKeyList::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool RegistrySubKeyList::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& RegistrySubKeyList::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& RegistrySubKeyList::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistrySubKeyList.Response)
  return _internal_response();
}
inline void RegistrySubKeyList::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RegistrySubKeyList.Response)
}
inline ::sliverpb::Response* RegistrySubKeyList::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* RegistrySubKeyList::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistrySubKeyList.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* RegistrySubKeyList::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* RegistrySubKeyList::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistrySubKeyList.Response)
  return _msg;
}
inline void RegistrySubKeyList::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistrySubKeyList.Response)
}

// -------------------------------------------------------------------

// RegistryListValuesReq

// string Hive = 1;
inline void RegistryListValuesReq::clear_hive() {
  _impl_.hive_.ClearToEmpty();
}
inline const std::string& RegistryListValuesReq::hive() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryListValuesReq.Hive)
  return _internal_hive();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryListValuesReq::set_hive(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hive_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryListValuesReq.Hive)
}
inline std::string* RegistryListValuesReq::mutable_hive() {
  std::string* _s = _internal_mutable_hive();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryListValuesReq.Hive)
  return _s;
}
inline const std::string& RegistryListValuesReq::_internal_hive() const {
  return _impl_.hive_.Get();
}
inline void RegistryListValuesReq::_internal_set_hive(const std::string& value) {
  
  _impl_.hive_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryListValuesReq::_internal_mutable_hive() {
  
  return _impl_.hive_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryListValuesReq::release_hive() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryListValuesReq.Hive)
  return _impl_.hive_.Release();
}
inline void RegistryListValuesReq::set_allocated_hive(std::string* hive) {
  if (hive != nullptr) {
    
  } else {
    
  }
  _impl_.hive_.SetAllocated(hive, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hive_.IsDefault()) {
    _impl_.hive_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryListValuesReq.Hive)
}

// string Path = 2;
inline void RegistryListValuesReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& RegistryListValuesReq::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryListValuesReq.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryListValuesReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryListValuesReq.Path)
}
inline std::string* RegistryListValuesReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryListValuesReq.Path)
  return _s;
}
inline const std::string& RegistryListValuesReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void RegistryListValuesReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryListValuesReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryListValuesReq::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryListValuesReq.Path)
  return _impl_.path_.Release();
}
inline void RegistryListValuesReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryListValuesReq.Path)
}

// string Hostname = 4;
inline void RegistryListValuesReq::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& RegistryListValuesReq::hostname() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryListValuesReq.Hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryListValuesReq::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegistryListValuesReq.Hostname)
}
inline std::string* RegistryListValuesReq::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryListValuesReq.Hostname)
  return _s;
}
inline const std::string& RegistryListValuesReq::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void RegistryListValuesReq::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryListValuesReq::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryListValuesReq::release_hostname() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryListValuesReq.Hostname)
  return _impl_.hostname_.Release();
}
inline void RegistryListValuesReq::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryListValuesReq.Hostname)
}

// .sliverpb.Request Request = 9;
inline bool RegistryListValuesReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool RegistryListValuesReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& RegistryListValuesReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& RegistryListValuesReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryListValuesReq.Request)
  return _internal_request();
}
inline void RegistryListValuesReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RegistryListValuesReq.Request)
}
inline ::sliverpb::Request* RegistryListValuesReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* RegistryListValuesReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryListValuesReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* RegistryListValuesReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* RegistryListValuesReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryListValuesReq.Request)
  return _msg;
}
inline void RegistryListValuesReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryListValuesReq.Request)
}

// -------------------------------------------------------------------

// RegistryValuesList

// repeated string ValueNames = 1;
inline int RegistryValuesList::_internal_valuenames_size() const {
  return _impl_.valuenames_.size();
}
inline int RegistryValuesList::valuenames_size() const {
  return _internal_valuenames_size();
}
inline void RegistryValuesList::clear_valuenames() {
  _impl_.valuenames_.Clear();
}
inline std::string* RegistryValuesList::add_valuenames() {
  std::string* _s = _internal_add_valuenames();
  // @@protoc_insertion_point(field_add_mutable:sliverpb.RegistryValuesList.ValueNames)
  return _s;
}
inline const std::string& RegistryValuesList::_internal_valuenames(int index) const {
  return _impl_.valuenames_.Get(index);
}
inline const std::string& RegistryValuesList::valuenames(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryValuesList.ValueNames)
  return _internal_valuenames(index);
}
inline std::string* RegistryValuesList::mutable_valuenames(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryValuesList.ValueNames)
  return _impl_.valuenames_.Mutable(index);
}
inline void RegistryValuesList::set_valuenames(int index, const std::string& value) {
  _impl_.valuenames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sliverpb.RegistryValuesList.ValueNames)
}
inline void RegistryValuesList::set_valuenames(int index, std::string&& value) {
  _impl_.valuenames_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sliverpb.RegistryValuesList.ValueNames)
}
inline void RegistryValuesList::set_valuenames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.valuenames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sliverpb.RegistryValuesList.ValueNames)
}
inline void RegistryValuesList::set_valuenames(int index, const char* value, size_t size) {
  _impl_.valuenames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sliverpb.RegistryValuesList.ValueNames)
}
inline std::string* RegistryValuesList::_internal_add_valuenames() {
  return _impl_.valuenames_.Add();
}
inline void RegistryValuesList::add_valuenames(const std::string& value) {
  _impl_.valuenames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sliverpb.RegistryValuesList.ValueNames)
}
inline void RegistryValuesList::add_valuenames(std::string&& value) {
  _impl_.valuenames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sliverpb.RegistryValuesList.ValueNames)
}
inline void RegistryValuesList::add_valuenames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.valuenames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sliverpb.RegistryValuesList.ValueNames)
}
inline void RegistryValuesList::add_valuenames(const char* value, size_t size) {
  _impl_.valuenames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sliverpb.RegistryValuesList.ValueNames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RegistryValuesList::valuenames() const {
  // @@protoc_insertion_point(field_list:sliverpb.RegistryValuesList.ValueNames)
  return _impl_.valuenames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RegistryValuesList::mutable_valuenames() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.RegistryValuesList.ValueNames)
  return &_impl_.valuenames_;
}

// .sliverpb.Response Response = 9;
inline bool RegistryValuesList::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool RegistryValuesList::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& RegistryValuesList::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& RegistryValuesList::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegistryValuesList.Response)
  return _internal_response();
}
inline void RegistryValuesList::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RegistryValuesList.Response)
}
inline ::sliverpb::Response* RegistryValuesList::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* RegistryValuesList::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.RegistryValuesList.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* RegistryValuesList::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* RegistryValuesList::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegistryValuesList.Response)
  return _msg;
}
inline void RegistryValuesList::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegistryValuesList.Response)
}

// -------------------------------------------------------------------

// Tunnel

// uint64 TunnelID = 8 [jstype = JS_STRING];
inline void Tunnel::clear_tunnelid() {
  _impl_.tunnelid_ = uint64_t{0u};
}
inline uint64_t Tunnel::_internal_tunnelid() const {
  return _impl_.tunnelid_;
}
inline uint64_t Tunnel::tunnelid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Tunnel.TunnelID)
  return _internal_tunnelid();
}
inline void Tunnel::_internal_set_tunnelid(uint64_t value) {
  
  _impl_.tunnelid_ = value;
}
inline void Tunnel::set_tunnelid(uint64_t value) {
  _internal_set_tunnelid(value);
  // @@protoc_insertion_point(field_set:sliverpb.Tunnel.TunnelID)
}

// string SessionID = 9;
inline void Tunnel::clear_sessionid() {
  _impl_.sessionid_.ClearToEmpty();
}
inline const std::string& Tunnel::sessionid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Tunnel.SessionID)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tunnel::set_sessionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sessionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Tunnel.SessionID)
}
inline std::string* Tunnel::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:sliverpb.Tunnel.SessionID)
  return _s;
}
inline const std::string& Tunnel::_internal_sessionid() const {
  return _impl_.sessionid_.Get();
}
inline void Tunnel::_internal_set_sessionid(const std::string& value) {
  
  _impl_.sessionid_.Set(value, GetArenaForAllocation());
}
inline std::string* Tunnel::_internal_mutable_sessionid() {
  
  return _impl_.sessionid_.Mutable(GetArenaForAllocation());
}
inline std::string* Tunnel::release_sessionid() {
  // @@protoc_insertion_point(field_release:sliverpb.Tunnel.SessionID)
  return _impl_.sessionid_.Release();
}
inline void Tunnel::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  _impl_.sessionid_.SetAllocated(sessionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sessionid_.IsDefault()) {
    _impl_.sessionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Tunnel.SessionID)
}

// -------------------------------------------------------------------

// TunnelData

// bytes Data = 1;
inline void TunnelData::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& TunnelData::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.TunnelData.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TunnelData::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.TunnelData.Data)
}
inline std::string* TunnelData::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.TunnelData.Data)
  return _s;
}
inline const std::string& TunnelData::_internal_data() const {
  return _impl_.data_.Get();
}
inline void TunnelData::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* TunnelData::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* TunnelData::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.TunnelData.Data)
  return _impl_.data_.Release();
}
inline void TunnelData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.TunnelData.Data)
}

// bool Closed = 2;
inline void TunnelData::clear_closed() {
  _impl_.closed_ = false;
}
inline bool TunnelData::_internal_closed() const {
  return _impl_.closed_;
}
inline bool TunnelData::closed() const {
  // @@protoc_insertion_point(field_get:sliverpb.TunnelData.Closed)
  return _internal_closed();
}
inline void TunnelData::_internal_set_closed(bool value) {
  
  _impl_.closed_ = value;
}
inline void TunnelData::set_closed(bool value) {
  _internal_set_closed(value);
  // @@protoc_insertion_point(field_set:sliverpb.TunnelData.Closed)
}

// uint64 Sequence = 3;
inline void TunnelData::clear_sequence() {
  _impl_.sequence_ = uint64_t{0u};
}
inline uint64_t TunnelData::_internal_sequence() const {
  return _impl_.sequence_;
}
inline uint64_t TunnelData::sequence() const {
  // @@protoc_insertion_point(field_get:sliverpb.TunnelData.Sequence)
  return _internal_sequence();
}
inline void TunnelData::_internal_set_sequence(uint64_t value) {
  
  _impl_.sequence_ = value;
}
inline void TunnelData::set_sequence(uint64_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:sliverpb.TunnelData.Sequence)
}

// uint64 Ack = 4;
inline void TunnelData::clear_ack() {
  _impl_.ack_ = uint64_t{0u};
}
inline uint64_t TunnelData::_internal_ack() const {
  return _impl_.ack_;
}
inline uint64_t TunnelData::ack() const {
  // @@protoc_insertion_point(field_get:sliverpb.TunnelData.Ack)
  return _internal_ack();
}
inline void TunnelData::_internal_set_ack(uint64_t value) {
  
  _impl_.ack_ = value;
}
inline void TunnelData::set_ack(uint64_t value) {
  _internal_set_ack(value);
  // @@protoc_insertion_point(field_set:sliverpb.TunnelData.Ack)
}

// bool Resend = 5;
inline void TunnelData::clear_resend() {
  _impl_.resend_ = false;
}
inline bool TunnelData::_internal_resend() const {
  return _impl_.resend_;
}
inline bool TunnelData::resend() const {
  // @@protoc_insertion_point(field_get:sliverpb.TunnelData.Resend)
  return _internal_resend();
}
inline void TunnelData::_internal_set_resend(bool value) {
  
  _impl_.resend_ = value;
}
inline void TunnelData::set_resend(bool value) {
  _internal_set_resend(value);
  // @@protoc_insertion_point(field_set:sliverpb.TunnelData.Resend)
}

// bool CreateReverse = 6;
inline void TunnelData::clear_createreverse() {
  _impl_.createreverse_ = false;
}
inline bool TunnelData::_internal_createreverse() const {
  return _impl_.createreverse_;
}
inline bool TunnelData::createreverse() const {
  // @@protoc_insertion_point(field_get:sliverpb.TunnelData.CreateReverse)
  return _internal_createreverse();
}
inline void TunnelData::_internal_set_createreverse(bool value) {
  
  _impl_.createreverse_ = value;
}
inline void TunnelData::set_createreverse(bool value) {
  _internal_set_createreverse(value);
  // @@protoc_insertion_point(field_set:sliverpb.TunnelData.CreateReverse)
}

// .sliverpb.RPortfwd rportfwd = 7;
inline bool TunnelData::_internal_has_rportfwd() const {
  return this != internal_default_instance() && _impl_.rportfwd_ != nullptr;
}
inline bool TunnelData::has_rportfwd() const {
  return _internal_has_rportfwd();
}
inline void TunnelData::clear_rportfwd() {
  if (GetArenaForAllocation() == nullptr && _impl_.rportfwd_ != nullptr) {
    delete _impl_.rportfwd_;
  }
  _impl_.rportfwd_ = nullptr;
}
inline const ::sliverpb::RPortfwd& TunnelData::_internal_rportfwd() const {
  const ::sliverpb::RPortfwd* p = _impl_.rportfwd_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::RPortfwd&>(
      ::sliverpb::_RPortfwd_default_instance_);
}
inline const ::sliverpb::RPortfwd& TunnelData::rportfwd() const {
  // @@protoc_insertion_point(field_get:sliverpb.TunnelData.rportfwd)
  return _internal_rportfwd();
}
inline void TunnelData::unsafe_arena_set_allocated_rportfwd(
    ::sliverpb::RPortfwd* rportfwd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rportfwd_);
  }
  _impl_.rportfwd_ = rportfwd;
  if (rportfwd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.TunnelData.rportfwd)
}
inline ::sliverpb::RPortfwd* TunnelData::release_rportfwd() {
  
  ::sliverpb::RPortfwd* temp = _impl_.rportfwd_;
  _impl_.rportfwd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::RPortfwd* TunnelData::unsafe_arena_release_rportfwd() {
  // @@protoc_insertion_point(field_release:sliverpb.TunnelData.rportfwd)
  
  ::sliverpb::RPortfwd* temp = _impl_.rportfwd_;
  _impl_.rportfwd_ = nullptr;
  return temp;
}
inline ::sliverpb::RPortfwd* TunnelData::_internal_mutable_rportfwd() {
  
  if (_impl_.rportfwd_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::RPortfwd>(GetArenaForAllocation());
    _impl_.rportfwd_ = p;
  }
  return _impl_.rportfwd_;
}
inline ::sliverpb::RPortfwd* TunnelData::mutable_rportfwd() {
  ::sliverpb::RPortfwd* _msg = _internal_mutable_rportfwd();
  // @@protoc_insertion_point(field_mutable:sliverpb.TunnelData.rportfwd)
  return _msg;
}
inline void TunnelData::set_allocated_rportfwd(::sliverpb::RPortfwd* rportfwd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rportfwd_;
  }
  if (rportfwd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rportfwd);
    if (message_arena != submessage_arena) {
      rportfwd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rportfwd, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rportfwd_ = rportfwd;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.TunnelData.rportfwd)
}

// uint64 TunnelID = 8 [jstype = JS_STRING];
inline void TunnelData::clear_tunnelid() {
  _impl_.tunnelid_ = uint64_t{0u};
}
inline uint64_t TunnelData::_internal_tunnelid() const {
  return _impl_.tunnelid_;
}
inline uint64_t TunnelData::tunnelid() const {
  // @@protoc_insertion_point(field_get:sliverpb.TunnelData.TunnelID)
  return _internal_tunnelid();
}
inline void TunnelData::_internal_set_tunnelid(uint64_t value) {
  
  _impl_.tunnelid_ = value;
}
inline void TunnelData::set_tunnelid(uint64_t value) {
  _internal_set_tunnelid(value);
  // @@protoc_insertion_point(field_set:sliverpb.TunnelData.TunnelID)
}

// string SessionID = 9;
inline void TunnelData::clear_sessionid() {
  _impl_.sessionid_.ClearToEmpty();
}
inline const std::string& TunnelData::sessionid() const {
  // @@protoc_insertion_point(field_get:sliverpb.TunnelData.SessionID)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TunnelData::set_sessionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sessionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.TunnelData.SessionID)
}
inline std::string* TunnelData::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:sliverpb.TunnelData.SessionID)
  return _s;
}
inline const std::string& TunnelData::_internal_sessionid() const {
  return _impl_.sessionid_.Get();
}
inline void TunnelData::_internal_set_sessionid(const std::string& value) {
  
  _impl_.sessionid_.Set(value, GetArenaForAllocation());
}
inline std::string* TunnelData::_internal_mutable_sessionid() {
  
  return _impl_.sessionid_.Mutable(GetArenaForAllocation());
}
inline std::string* TunnelData::release_sessionid() {
  // @@protoc_insertion_point(field_release:sliverpb.TunnelData.SessionID)
  return _impl_.sessionid_.Release();
}
inline void TunnelData::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  _impl_.sessionid_.SetAllocated(sessionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sessionid_.IsDefault()) {
    _impl_.sessionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.TunnelData.SessionID)
}

// -------------------------------------------------------------------

// ShellReq

// string Path = 1;
inline void ShellReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& ShellReq::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.ShellReq.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.ShellReq.Path)
}
inline std::string* ShellReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.ShellReq.Path)
  return _s;
}
inline const std::string& ShellReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void ShellReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* ShellReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* ShellReq::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.ShellReq.Path)
  return _impl_.path_.Release();
}
inline void ShellReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ShellReq.Path)
}

// bool EnablePTY = 2;
inline void ShellReq::clear_enablepty() {
  _impl_.enablepty_ = false;
}
inline bool ShellReq::_internal_enablepty() const {
  return _impl_.enablepty_;
}
inline bool ShellReq::enablepty() const {
  // @@protoc_insertion_point(field_get:sliverpb.ShellReq.EnablePTY)
  return _internal_enablepty();
}
inline void ShellReq::_internal_set_enablepty(bool value) {
  
  _impl_.enablepty_ = value;
}
inline void ShellReq::set_enablepty(bool value) {
  _internal_set_enablepty(value);
  // @@protoc_insertion_point(field_set:sliverpb.ShellReq.EnablePTY)
}

// uint32 Pid = 3;
inline void ShellReq::clear_pid() {
  _impl_.pid_ = 0u;
}
inline uint32_t ShellReq::_internal_pid() const {
  return _impl_.pid_;
}
inline uint32_t ShellReq::pid() const {
  // @@protoc_insertion_point(field_get:sliverpb.ShellReq.Pid)
  return _internal_pid();
}
inline void ShellReq::_internal_set_pid(uint32_t value) {
  
  _impl_.pid_ = value;
}
inline void ShellReq::set_pid(uint32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:sliverpb.ShellReq.Pid)
}

// uint64 TunnelID = 8 [jstype = JS_STRING];
inline void ShellReq::clear_tunnelid() {
  _impl_.tunnelid_ = uint64_t{0u};
}
inline uint64_t ShellReq::_internal_tunnelid() const {
  return _impl_.tunnelid_;
}
inline uint64_t ShellReq::tunnelid() const {
  // @@protoc_insertion_point(field_get:sliverpb.ShellReq.TunnelID)
  return _internal_tunnelid();
}
inline void ShellReq::_internal_set_tunnelid(uint64_t value) {
  
  _impl_.tunnelid_ = value;
}
inline void ShellReq::set_tunnelid(uint64_t value) {
  _internal_set_tunnelid(value);
  // @@protoc_insertion_point(field_set:sliverpb.ShellReq.TunnelID)
}

// .sliverpb.Request Request = 9;
inline bool ShellReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool ShellReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& ShellReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& ShellReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.ShellReq.Request)
  return _internal_request();
}
inline void ShellReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.ShellReq.Request)
}
inline ::sliverpb::Request* ShellReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* ShellReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.ShellReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* ShellReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* ShellReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.ShellReq.Request)
  return _msg;
}
inline void ShellReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ShellReq.Request)
}

// -------------------------------------------------------------------

// Shell

// string Path = 1;
inline void Shell::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& Shell::path() const {
  // @@protoc_insertion_point(field_get:sliverpb.Shell.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Shell::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Shell.Path)
}
inline std::string* Shell::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:sliverpb.Shell.Path)
  return _s;
}
inline const std::string& Shell::_internal_path() const {
  return _impl_.path_.Get();
}
inline void Shell::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* Shell::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* Shell::release_path() {
  // @@protoc_insertion_point(field_release:sliverpb.Shell.Path)
  return _impl_.path_.Release();
}
inline void Shell::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Shell.Path)
}

// bool EnablePTY = 2;
inline void Shell::clear_enablepty() {
  _impl_.enablepty_ = false;
}
inline bool Shell::_internal_enablepty() const {
  return _impl_.enablepty_;
}
inline bool Shell::enablepty() const {
  // @@protoc_insertion_point(field_get:sliverpb.Shell.EnablePTY)
  return _internal_enablepty();
}
inline void Shell::_internal_set_enablepty(bool value) {
  
  _impl_.enablepty_ = value;
}
inline void Shell::set_enablepty(bool value) {
  _internal_set_enablepty(value);
  // @@protoc_insertion_point(field_set:sliverpb.Shell.EnablePTY)
}

// uint32 Pid = 3;
inline void Shell::clear_pid() {
  _impl_.pid_ = 0u;
}
inline uint32_t Shell::_internal_pid() const {
  return _impl_.pid_;
}
inline uint32_t Shell::pid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Shell.Pid)
  return _internal_pid();
}
inline void Shell::_internal_set_pid(uint32_t value) {
  
  _impl_.pid_ = value;
}
inline void Shell::set_pid(uint32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:sliverpb.Shell.Pid)
}

// uint64 TunnelID = 8 [jstype = JS_STRING];
inline void Shell::clear_tunnelid() {
  _impl_.tunnelid_ = uint64_t{0u};
}
inline uint64_t Shell::_internal_tunnelid() const {
  return _impl_.tunnelid_;
}
inline uint64_t Shell::tunnelid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Shell.TunnelID)
  return _internal_tunnelid();
}
inline void Shell::_internal_set_tunnelid(uint64_t value) {
  
  _impl_.tunnelid_ = value;
}
inline void Shell::set_tunnelid(uint64_t value) {
  _internal_set_tunnelid(value);
  // @@protoc_insertion_point(field_set:sliverpb.Shell.TunnelID)
}

// .sliverpb.Response Response = 9;
inline bool Shell::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Shell::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Shell::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Shell::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Shell.Response)
  return _internal_response();
}
inline void Shell::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Shell.Response)
}
inline ::sliverpb::Response* Shell::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Shell::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Shell.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Shell::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Shell::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Shell.Response)
  return _msg;
}
inline void Shell::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Shell.Response)
}

// -------------------------------------------------------------------

// PortfwdReq

// uint32 Port = 1;
inline void PortfwdReq::clear_port() {
  _impl_.port_ = 0u;
}
inline uint32_t PortfwdReq::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t PortfwdReq::port() const {
  // @@protoc_insertion_point(field_get:sliverpb.PortfwdReq.Port)
  return _internal_port();
}
inline void PortfwdReq::_internal_set_port(uint32_t value) {
  
  _impl_.port_ = value;
}
inline void PortfwdReq::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:sliverpb.PortfwdReq.Port)
}

// int32 Protocol = 2;
inline void PortfwdReq::clear_protocol() {
  _impl_.protocol_ = 0;
}
inline int32_t PortfwdReq::_internal_protocol() const {
  return _impl_.protocol_;
}
inline int32_t PortfwdReq::protocol() const {
  // @@protoc_insertion_point(field_get:sliverpb.PortfwdReq.Protocol)
  return _internal_protocol();
}
inline void PortfwdReq::_internal_set_protocol(int32_t value) {
  
  _impl_.protocol_ = value;
}
inline void PortfwdReq::set_protocol(int32_t value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:sliverpb.PortfwdReq.Protocol)
}

// string Host = 3;
inline void PortfwdReq::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& PortfwdReq::host() const {
  // @@protoc_insertion_point(field_get:sliverpb.PortfwdReq.Host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PortfwdReq::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.PortfwdReq.Host)
}
inline std::string* PortfwdReq::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:sliverpb.PortfwdReq.Host)
  return _s;
}
inline const std::string& PortfwdReq::_internal_host() const {
  return _impl_.host_.Get();
}
inline void PortfwdReq::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* PortfwdReq::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* PortfwdReq::release_host() {
  // @@protoc_insertion_point(field_release:sliverpb.PortfwdReq.Host)
  return _impl_.host_.Release();
}
inline void PortfwdReq::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PortfwdReq.Host)
}

// uint64 TunnelID = 8 [jstype = JS_STRING];
inline void PortfwdReq::clear_tunnelid() {
  _impl_.tunnelid_ = uint64_t{0u};
}
inline uint64_t PortfwdReq::_internal_tunnelid() const {
  return _impl_.tunnelid_;
}
inline uint64_t PortfwdReq::tunnelid() const {
  // @@protoc_insertion_point(field_get:sliverpb.PortfwdReq.TunnelID)
  return _internal_tunnelid();
}
inline void PortfwdReq::_internal_set_tunnelid(uint64_t value) {
  
  _impl_.tunnelid_ = value;
}
inline void PortfwdReq::set_tunnelid(uint64_t value) {
  _internal_set_tunnelid(value);
  // @@protoc_insertion_point(field_set:sliverpb.PortfwdReq.TunnelID)
}

// .sliverpb.Request Request = 9;
inline bool PortfwdReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool PortfwdReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& PortfwdReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& PortfwdReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.PortfwdReq.Request)
  return _internal_request();
}
inline void PortfwdReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.PortfwdReq.Request)
}
inline ::sliverpb::Request* PortfwdReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* PortfwdReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.PortfwdReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* PortfwdReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* PortfwdReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.PortfwdReq.Request)
  return _msg;
}
inline void PortfwdReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PortfwdReq.Request)
}

// -------------------------------------------------------------------

// Portfwd

// uint32 Port = 1;
inline void Portfwd::clear_port() {
  _impl_.port_ = 0u;
}
inline uint32_t Portfwd::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t Portfwd::port() const {
  // @@protoc_insertion_point(field_get:sliverpb.Portfwd.Port)
  return _internal_port();
}
inline void Portfwd::_internal_set_port(uint32_t value) {
  
  _impl_.port_ = value;
}
inline void Portfwd::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:sliverpb.Portfwd.Port)
}

// int32 Protocol = 2;
inline void Portfwd::clear_protocol() {
  _impl_.protocol_ = 0;
}
inline int32_t Portfwd::_internal_protocol() const {
  return _impl_.protocol_;
}
inline int32_t Portfwd::protocol() const {
  // @@protoc_insertion_point(field_get:sliverpb.Portfwd.Protocol)
  return _internal_protocol();
}
inline void Portfwd::_internal_set_protocol(int32_t value) {
  
  _impl_.protocol_ = value;
}
inline void Portfwd::set_protocol(int32_t value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:sliverpb.Portfwd.Protocol)
}

// string Host = 3;
inline void Portfwd::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& Portfwd::host() const {
  // @@protoc_insertion_point(field_get:sliverpb.Portfwd.Host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Portfwd::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Portfwd.Host)
}
inline std::string* Portfwd::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:sliverpb.Portfwd.Host)
  return _s;
}
inline const std::string& Portfwd::_internal_host() const {
  return _impl_.host_.Get();
}
inline void Portfwd::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* Portfwd::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* Portfwd::release_host() {
  // @@protoc_insertion_point(field_release:sliverpb.Portfwd.Host)
  return _impl_.host_.Release();
}
inline void Portfwd::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Portfwd.Host)
}

// uint64 TunnelID = 8 [jstype = JS_STRING];
inline void Portfwd::clear_tunnelid() {
  _impl_.tunnelid_ = uint64_t{0u};
}
inline uint64_t Portfwd::_internal_tunnelid() const {
  return _impl_.tunnelid_;
}
inline uint64_t Portfwd::tunnelid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Portfwd.TunnelID)
  return _internal_tunnelid();
}
inline void Portfwd::_internal_set_tunnelid(uint64_t value) {
  
  _impl_.tunnelid_ = value;
}
inline void Portfwd::set_tunnelid(uint64_t value) {
  _internal_set_tunnelid(value);
  // @@protoc_insertion_point(field_set:sliverpb.Portfwd.TunnelID)
}

// .sliverpb.Response Response = 9;
inline bool Portfwd::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Portfwd::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Portfwd::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Portfwd::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Portfwd.Response)
  return _internal_response();
}
inline void Portfwd::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Portfwd.Response)
}
inline ::sliverpb::Response* Portfwd::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Portfwd::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Portfwd.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Portfwd::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Portfwd::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Portfwd.Response)
  return _msg;
}
inline void Portfwd::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Portfwd.Response)
}

// -------------------------------------------------------------------

// Socks

// uint64 TunnelID = 8 [jstype = JS_STRING];
inline void Socks::clear_tunnelid() {
  _impl_.tunnelid_ = uint64_t{0u};
}
inline uint64_t Socks::_internal_tunnelid() const {
  return _impl_.tunnelid_;
}
inline uint64_t Socks::tunnelid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Socks.TunnelID)
  return _internal_tunnelid();
}
inline void Socks::_internal_set_tunnelid(uint64_t value) {
  
  _impl_.tunnelid_ = value;
}
inline void Socks::set_tunnelid(uint64_t value) {
  _internal_set_tunnelid(value);
  // @@protoc_insertion_point(field_set:sliverpb.Socks.TunnelID)
}

// string SessionID = 9;
inline void Socks::clear_sessionid() {
  _impl_.sessionid_.ClearToEmpty();
}
inline const std::string& Socks::sessionid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Socks.SessionID)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Socks::set_sessionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sessionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Socks.SessionID)
}
inline std::string* Socks::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:sliverpb.Socks.SessionID)
  return _s;
}
inline const std::string& Socks::_internal_sessionid() const {
  return _impl_.sessionid_.Get();
}
inline void Socks::_internal_set_sessionid(const std::string& value) {
  
  _impl_.sessionid_.Set(value, GetArenaForAllocation());
}
inline std::string* Socks::_internal_mutable_sessionid() {
  
  return _impl_.sessionid_.Mutable(GetArenaForAllocation());
}
inline std::string* Socks::release_sessionid() {
  // @@protoc_insertion_point(field_release:sliverpb.Socks.SessionID)
  return _impl_.sessionid_.Release();
}
inline void Socks::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  _impl_.sessionid_.SetAllocated(sessionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sessionid_.IsDefault()) {
    _impl_.sessionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Socks.SessionID)
}

// -------------------------------------------------------------------

// SocksData

// bytes Data = 1;
inline void SocksData::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& SocksData::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.SocksData.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SocksData::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SocksData.Data)
}
inline std::string* SocksData::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.SocksData.Data)
  return _s;
}
inline const std::string& SocksData::_internal_data() const {
  return _impl_.data_.Get();
}
inline void SocksData::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* SocksData::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* SocksData::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.SocksData.Data)
  return _impl_.data_.Release();
}
inline void SocksData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SocksData.Data)
}

// bool CloseConn = 2;
inline void SocksData::clear_closeconn() {
  _impl_.closeconn_ = false;
}
inline bool SocksData::_internal_closeconn() const {
  return _impl_.closeconn_;
}
inline bool SocksData::closeconn() const {
  // @@protoc_insertion_point(field_get:sliverpb.SocksData.CloseConn)
  return _internal_closeconn();
}
inline void SocksData::_internal_set_closeconn(bool value) {
  
  _impl_.closeconn_ = value;
}
inline void SocksData::set_closeconn(bool value) {
  _internal_set_closeconn(value);
  // @@protoc_insertion_point(field_set:sliverpb.SocksData.CloseConn)
}

// string Username = 3;
inline void SocksData::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& SocksData::username() const {
  // @@protoc_insertion_point(field_get:sliverpb.SocksData.Username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SocksData::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SocksData.Username)
}
inline std::string* SocksData::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:sliverpb.SocksData.Username)
  return _s;
}
inline const std::string& SocksData::_internal_username() const {
  return _impl_.username_.Get();
}
inline void SocksData::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* SocksData::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* SocksData::release_username() {
  // @@protoc_insertion_point(field_release:sliverpb.SocksData.Username)
  return _impl_.username_.Release();
}
inline void SocksData::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SocksData.Username)
}

// string Password = 4;
inline void SocksData::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& SocksData::password() const {
  // @@protoc_insertion_point(field_get:sliverpb.SocksData.Password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SocksData::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SocksData.Password)
}
inline std::string* SocksData::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:sliverpb.SocksData.Password)
  return _s;
}
inline const std::string& SocksData::_internal_password() const {
  return _impl_.password_.Get();
}
inline void SocksData::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* SocksData::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* SocksData::release_password() {
  // @@protoc_insertion_point(field_release:sliverpb.SocksData.Password)
  return _impl_.password_.Release();
}
inline void SocksData::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SocksData.Password)
}

// uint64 Sequence = 5;
inline void SocksData::clear_sequence() {
  _impl_.sequence_ = uint64_t{0u};
}
inline uint64_t SocksData::_internal_sequence() const {
  return _impl_.sequence_;
}
inline uint64_t SocksData::sequence() const {
  // @@protoc_insertion_point(field_get:sliverpb.SocksData.Sequence)
  return _internal_sequence();
}
inline void SocksData::_internal_set_sequence(uint64_t value) {
  
  _impl_.sequence_ = value;
}
inline void SocksData::set_sequence(uint64_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:sliverpb.SocksData.Sequence)
}

// uint64 TunnelID = 8 [jstype = JS_STRING];
inline void SocksData::clear_tunnelid() {
  _impl_.tunnelid_ = uint64_t{0u};
}
inline uint64_t SocksData::_internal_tunnelid() const {
  return _impl_.tunnelid_;
}
inline uint64_t SocksData::tunnelid() const {
  // @@protoc_insertion_point(field_get:sliverpb.SocksData.TunnelID)
  return _internal_tunnelid();
}
inline void SocksData::_internal_set_tunnelid(uint64_t value) {
  
  _impl_.tunnelid_ = value;
}
inline void SocksData::set_tunnelid(uint64_t value) {
  _internal_set_tunnelid(value);
  // @@protoc_insertion_point(field_set:sliverpb.SocksData.TunnelID)
}

// .sliverpb.Request Request = 9;
inline bool SocksData::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool SocksData::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& SocksData::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& SocksData::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.SocksData.Request)
  return _internal_request();
}
inline void SocksData::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.SocksData.Request)
}
inline ::sliverpb::Request* SocksData::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* SocksData::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.SocksData.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* SocksData::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* SocksData::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.SocksData.Request)
  return _msg;
}
inline void SocksData::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SocksData.Request)
}

// -------------------------------------------------------------------

// PivotStartListenerReq

// .sliverpb.PivotType Type = 1;
inline void PivotStartListenerReq::clear_type() {
  _impl_.type_ = 0;
}
inline ::sliverpb::PivotType PivotStartListenerReq::_internal_type() const {
  return static_cast< ::sliverpb::PivotType >(_impl_.type_);
}
inline ::sliverpb::PivotType PivotStartListenerReq::type() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotStartListenerReq.Type)
  return _internal_type();
}
inline void PivotStartListenerReq::_internal_set_type(::sliverpb::PivotType value) {
  
  _impl_.type_ = value;
}
inline void PivotStartListenerReq::set_type(::sliverpb::PivotType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sliverpb.PivotStartListenerReq.Type)
}

// string BindAddress = 2;
inline void PivotStartListenerReq::clear_bindaddress() {
  _impl_.bindaddress_.ClearToEmpty();
}
inline const std::string& PivotStartListenerReq::bindaddress() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotStartListenerReq.BindAddress)
  return _internal_bindaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PivotStartListenerReq::set_bindaddress(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bindaddress_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.PivotStartListenerReq.BindAddress)
}
inline std::string* PivotStartListenerReq::mutable_bindaddress() {
  std::string* _s = _internal_mutable_bindaddress();
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotStartListenerReq.BindAddress)
  return _s;
}
inline const std::string& PivotStartListenerReq::_internal_bindaddress() const {
  return _impl_.bindaddress_.Get();
}
inline void PivotStartListenerReq::_internal_set_bindaddress(const std::string& value) {
  
  _impl_.bindaddress_.Set(value, GetArenaForAllocation());
}
inline std::string* PivotStartListenerReq::_internal_mutable_bindaddress() {
  
  return _impl_.bindaddress_.Mutable(GetArenaForAllocation());
}
inline std::string* PivotStartListenerReq::release_bindaddress() {
  // @@protoc_insertion_point(field_release:sliverpb.PivotStartListenerReq.BindAddress)
  return _impl_.bindaddress_.Release();
}
inline void PivotStartListenerReq::set_allocated_bindaddress(std::string* bindaddress) {
  if (bindaddress != nullptr) {
    
  } else {
    
  }
  _impl_.bindaddress_.SetAllocated(bindaddress, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bindaddress_.IsDefault()) {
    _impl_.bindaddress_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PivotStartListenerReq.BindAddress)
}

// repeated bool Options = 3;
inline int PivotStartListenerReq::_internal_options_size() const {
  return _impl_.options_.size();
}
inline int PivotStartListenerReq::options_size() const {
  return _internal_options_size();
}
inline void PivotStartListenerReq::clear_options() {
  _impl_.options_.Clear();
}
inline bool PivotStartListenerReq::_internal_options(int index) const {
  return _impl_.options_.Get(index);
}
inline bool PivotStartListenerReq::options(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotStartListenerReq.Options)
  return _internal_options(index);
}
inline void PivotStartListenerReq::set_options(int index, bool value) {
  _impl_.options_.Set(index, value);
  // @@protoc_insertion_point(field_set:sliverpb.PivotStartListenerReq.Options)
}
inline void PivotStartListenerReq::_internal_add_options(bool value) {
  _impl_.options_.Add(value);
}
inline void PivotStartListenerReq::add_options(bool value) {
  _internal_add_options(value);
  // @@protoc_insertion_point(field_add:sliverpb.PivotStartListenerReq.Options)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
PivotStartListenerReq::_internal_options() const {
  return _impl_.options_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
PivotStartListenerReq::options() const {
  // @@protoc_insertion_point(field_list:sliverpb.PivotStartListenerReq.Options)
  return _internal_options();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
PivotStartListenerReq::_internal_mutable_options() {
  return &_impl_.options_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
PivotStartListenerReq::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.PivotStartListenerReq.Options)
  return _internal_mutable_options();
}

// .sliverpb.Request Request = 9;
inline bool PivotStartListenerReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool PivotStartListenerReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& PivotStartListenerReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& PivotStartListenerReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotStartListenerReq.Request)
  return _internal_request();
}
inline void PivotStartListenerReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.PivotStartListenerReq.Request)
}
inline ::sliverpb::Request* PivotStartListenerReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* PivotStartListenerReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.PivotStartListenerReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* PivotStartListenerReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* PivotStartListenerReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotStartListenerReq.Request)
  return _msg;
}
inline void PivotStartListenerReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PivotStartListenerReq.Request)
}

// -------------------------------------------------------------------

// PivotStopListenerReq

// uint32 ID = 1;
inline void PivotStopListenerReq::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t PivotStopListenerReq::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t PivotStopListenerReq::id() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotStopListenerReq.ID)
  return _internal_id();
}
inline void PivotStopListenerReq::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void PivotStopListenerReq::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sliverpb.PivotStopListenerReq.ID)
}

// .sliverpb.Request Request = 9;
inline bool PivotStopListenerReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool PivotStopListenerReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& PivotStopListenerReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& PivotStopListenerReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotStopListenerReq.Request)
  return _internal_request();
}
inline void PivotStopListenerReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.PivotStopListenerReq.Request)
}
inline ::sliverpb::Request* PivotStopListenerReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* PivotStopListenerReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.PivotStopListenerReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* PivotStopListenerReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* PivotStopListenerReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotStopListenerReq.Request)
  return _msg;
}
inline void PivotStopListenerReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PivotStopListenerReq.Request)
}

// -------------------------------------------------------------------

// PivotListener

// uint32 ID = 1;
inline void PivotListener::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t PivotListener::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t PivotListener::id() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotListener.ID)
  return _internal_id();
}
inline void PivotListener::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void PivotListener::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sliverpb.PivotListener.ID)
}

// .sliverpb.PivotType Type = 2;
inline void PivotListener::clear_type() {
  _impl_.type_ = 0;
}
inline ::sliverpb::PivotType PivotListener::_internal_type() const {
  return static_cast< ::sliverpb::PivotType >(_impl_.type_);
}
inline ::sliverpb::PivotType PivotListener::type() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotListener.Type)
  return _internal_type();
}
inline void PivotListener::_internal_set_type(::sliverpb::PivotType value) {
  
  _impl_.type_ = value;
}
inline void PivotListener::set_type(::sliverpb::PivotType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sliverpb.PivotListener.Type)
}

// string BindAddress = 3;
inline void PivotListener::clear_bindaddress() {
  _impl_.bindaddress_.ClearToEmpty();
}
inline const std::string& PivotListener::bindaddress() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotListener.BindAddress)
  return _internal_bindaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PivotListener::set_bindaddress(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bindaddress_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.PivotListener.BindAddress)
}
inline std::string* PivotListener::mutable_bindaddress() {
  std::string* _s = _internal_mutable_bindaddress();
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotListener.BindAddress)
  return _s;
}
inline const std::string& PivotListener::_internal_bindaddress() const {
  return _impl_.bindaddress_.Get();
}
inline void PivotListener::_internal_set_bindaddress(const std::string& value) {
  
  _impl_.bindaddress_.Set(value, GetArenaForAllocation());
}
inline std::string* PivotListener::_internal_mutable_bindaddress() {
  
  return _impl_.bindaddress_.Mutable(GetArenaForAllocation());
}
inline std::string* PivotListener::release_bindaddress() {
  // @@protoc_insertion_point(field_release:sliverpb.PivotListener.BindAddress)
  return _impl_.bindaddress_.Release();
}
inline void PivotListener::set_allocated_bindaddress(std::string* bindaddress) {
  if (bindaddress != nullptr) {
    
  } else {
    
  }
  _impl_.bindaddress_.SetAllocated(bindaddress, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bindaddress_.IsDefault()) {
    _impl_.bindaddress_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PivotListener.BindAddress)
}

// repeated .sliverpb.NetConnPivot Pivots = 4;
inline int PivotListener::_internal_pivots_size() const {
  return _impl_.pivots_.size();
}
inline int PivotListener::pivots_size() const {
  return _internal_pivots_size();
}
inline void PivotListener::clear_pivots() {
  _impl_.pivots_.Clear();
}
inline ::sliverpb::NetConnPivot* PivotListener::mutable_pivots(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotListener.Pivots)
  return _impl_.pivots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::NetConnPivot >*
PivotListener::mutable_pivots() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.PivotListener.Pivots)
  return &_impl_.pivots_;
}
inline const ::sliverpb::NetConnPivot& PivotListener::_internal_pivots(int index) const {
  return _impl_.pivots_.Get(index);
}
inline const ::sliverpb::NetConnPivot& PivotListener::pivots(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotListener.Pivots)
  return _internal_pivots(index);
}
inline ::sliverpb::NetConnPivot* PivotListener::_internal_add_pivots() {
  return _impl_.pivots_.Add();
}
inline ::sliverpb::NetConnPivot* PivotListener::add_pivots() {
  ::sliverpb::NetConnPivot* _add = _internal_add_pivots();
  // @@protoc_insertion_point(field_add:sliverpb.PivotListener.Pivots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::NetConnPivot >&
PivotListener::pivots() const {
  // @@protoc_insertion_point(field_list:sliverpb.PivotListener.Pivots)
  return _impl_.pivots_;
}

// .sliverpb.Response Response = 9;
inline bool PivotListener::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool PivotListener::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& PivotListener::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& PivotListener::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotListener.Response)
  return _internal_response();
}
inline void PivotListener::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.PivotListener.Response)
}
inline ::sliverpb::Response* PivotListener::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* PivotListener::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.PivotListener.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* PivotListener::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* PivotListener::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotListener.Response)
  return _msg;
}
inline void PivotListener::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PivotListener.Response)
}

// -------------------------------------------------------------------

// PivotHello

// bytes PublicKey = 1;
inline void PivotHello::clear_publickey() {
  _impl_.publickey_.ClearToEmpty();
}
inline const std::string& PivotHello::publickey() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotHello.PublicKey)
  return _internal_publickey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PivotHello::set_publickey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.publickey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.PivotHello.PublicKey)
}
inline std::string* PivotHello::mutable_publickey() {
  std::string* _s = _internal_mutable_publickey();
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotHello.PublicKey)
  return _s;
}
inline const std::string& PivotHello::_internal_publickey() const {
  return _impl_.publickey_.Get();
}
inline void PivotHello::_internal_set_publickey(const std::string& value) {
  
  _impl_.publickey_.Set(value, GetArenaForAllocation());
}
inline std::string* PivotHello::_internal_mutable_publickey() {
  
  return _impl_.publickey_.Mutable(GetArenaForAllocation());
}
inline std::string* PivotHello::release_publickey() {
  // @@protoc_insertion_point(field_release:sliverpb.PivotHello.PublicKey)
  return _impl_.publickey_.Release();
}
inline void PivotHello::set_allocated_publickey(std::string* publickey) {
  if (publickey != nullptr) {
    
  } else {
    
  }
  _impl_.publickey_.SetAllocated(publickey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publickey_.IsDefault()) {
    _impl_.publickey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PivotHello.PublicKey)
}

// int64 PeerID = 2 [jstype = JS_STRING];
inline void PivotHello::clear_peerid() {
  _impl_.peerid_ = int64_t{0};
}
inline int64_t PivotHello::_internal_peerid() const {
  return _impl_.peerid_;
}
inline int64_t PivotHello::peerid() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotHello.PeerID)
  return _internal_peerid();
}
inline void PivotHello::_internal_set_peerid(int64_t value) {
  
  _impl_.peerid_ = value;
}
inline void PivotHello::set_peerid(int64_t value) {
  _internal_set_peerid(value);
  // @@protoc_insertion_point(field_set:sliverpb.PivotHello.PeerID)
}

// string PublicKeySignature = 3;
inline void PivotHello::clear_publickeysignature() {
  _impl_.publickeysignature_.ClearToEmpty();
}
inline const std::string& PivotHello::publickeysignature() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotHello.PublicKeySignature)
  return _internal_publickeysignature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PivotHello::set_publickeysignature(ArgT0&& arg0, ArgT... args) {
 
 _impl_.publickeysignature_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.PivotHello.PublicKeySignature)
}
inline std::string* PivotHello::mutable_publickeysignature() {
  std::string* _s = _internal_mutable_publickeysignature();
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotHello.PublicKeySignature)
  return _s;
}
inline const std::string& PivotHello::_internal_publickeysignature() const {
  return _impl_.publickeysignature_.Get();
}
inline void PivotHello::_internal_set_publickeysignature(const std::string& value) {
  
  _impl_.publickeysignature_.Set(value, GetArenaForAllocation());
}
inline std::string* PivotHello::_internal_mutable_publickeysignature() {
  
  return _impl_.publickeysignature_.Mutable(GetArenaForAllocation());
}
inline std::string* PivotHello::release_publickeysignature() {
  // @@protoc_insertion_point(field_release:sliverpb.PivotHello.PublicKeySignature)
  return _impl_.publickeysignature_.Release();
}
inline void PivotHello::set_allocated_publickeysignature(std::string* publickeysignature) {
  if (publickeysignature != nullptr) {
    
  } else {
    
  }
  _impl_.publickeysignature_.SetAllocated(publickeysignature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publickeysignature_.IsDefault()) {
    _impl_.publickeysignature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PivotHello.PublicKeySignature)
}

// bytes SessionKey = 4;
inline void PivotHello::clear_sessionkey() {
  _impl_.sessionkey_.ClearToEmpty();
}
inline const std::string& PivotHello::sessionkey() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotHello.SessionKey)
  return _internal_sessionkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PivotHello::set_sessionkey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sessionkey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.PivotHello.SessionKey)
}
inline std::string* PivotHello::mutable_sessionkey() {
  std::string* _s = _internal_mutable_sessionkey();
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotHello.SessionKey)
  return _s;
}
inline const std::string& PivotHello::_internal_sessionkey() const {
  return _impl_.sessionkey_.Get();
}
inline void PivotHello::_internal_set_sessionkey(const std::string& value) {
  
  _impl_.sessionkey_.Set(value, GetArenaForAllocation());
}
inline std::string* PivotHello::_internal_mutable_sessionkey() {
  
  return _impl_.sessionkey_.Mutable(GetArenaForAllocation());
}
inline std::string* PivotHello::release_sessionkey() {
  // @@protoc_insertion_point(field_release:sliverpb.PivotHello.SessionKey)
  return _impl_.sessionkey_.Release();
}
inline void PivotHello::set_allocated_sessionkey(std::string* sessionkey) {
  if (sessionkey != nullptr) {
    
  } else {
    
  }
  _impl_.sessionkey_.SetAllocated(sessionkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sessionkey_.IsDefault()) {
    _impl_.sessionkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PivotHello.SessionKey)
}

// -------------------------------------------------------------------

// PivotServerKeyExchange

// int64 OriginID = 1;
inline void PivotServerKeyExchange::clear_originid() {
  _impl_.originid_ = int64_t{0};
}
inline int64_t PivotServerKeyExchange::_internal_originid() const {
  return _impl_.originid_;
}
inline int64_t PivotServerKeyExchange::originid() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotServerKeyExchange.OriginID)
  return _internal_originid();
}
inline void PivotServerKeyExchange::_internal_set_originid(int64_t value) {
  
  _impl_.originid_ = value;
}
inline void PivotServerKeyExchange::set_originid(int64_t value) {
  _internal_set_originid(value);
  // @@protoc_insertion_point(field_set:sliverpb.PivotServerKeyExchange.OriginID)
}

// bytes SessionKey = 2;
inline void PivotServerKeyExchange::clear_sessionkey() {
  _impl_.sessionkey_.ClearToEmpty();
}
inline const std::string& PivotServerKeyExchange::sessionkey() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotServerKeyExchange.SessionKey)
  return _internal_sessionkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PivotServerKeyExchange::set_sessionkey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sessionkey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.PivotServerKeyExchange.SessionKey)
}
inline std::string* PivotServerKeyExchange::mutable_sessionkey() {
  std::string* _s = _internal_mutable_sessionkey();
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotServerKeyExchange.SessionKey)
  return _s;
}
inline const std::string& PivotServerKeyExchange::_internal_sessionkey() const {
  return _impl_.sessionkey_.Get();
}
inline void PivotServerKeyExchange::_internal_set_sessionkey(const std::string& value) {
  
  _impl_.sessionkey_.Set(value, GetArenaForAllocation());
}
inline std::string* PivotServerKeyExchange::_internal_mutable_sessionkey() {
  
  return _impl_.sessionkey_.Mutable(GetArenaForAllocation());
}
inline std::string* PivotServerKeyExchange::release_sessionkey() {
  // @@protoc_insertion_point(field_release:sliverpb.PivotServerKeyExchange.SessionKey)
  return _impl_.sessionkey_.Release();
}
inline void PivotServerKeyExchange::set_allocated_sessionkey(std::string* sessionkey) {
  if (sessionkey != nullptr) {
    
  } else {
    
  }
  _impl_.sessionkey_.SetAllocated(sessionkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sessionkey_.IsDefault()) {
    _impl_.sessionkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PivotServerKeyExchange.SessionKey)
}

// -------------------------------------------------------------------

// PivotPeer

// int64 PeerID = 1 [jstype = JS_STRING];
inline void PivotPeer::clear_peerid() {
  _impl_.peerid_ = int64_t{0};
}
inline int64_t PivotPeer::_internal_peerid() const {
  return _impl_.peerid_;
}
inline int64_t PivotPeer::peerid() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotPeer.PeerID)
  return _internal_peerid();
}
inline void PivotPeer::_internal_set_peerid(int64_t value) {
  
  _impl_.peerid_ = value;
}
inline void PivotPeer::set_peerid(int64_t value) {
  _internal_set_peerid(value);
  // @@protoc_insertion_point(field_set:sliverpb.PivotPeer.PeerID)
}

// string Name = 2;
inline void PivotPeer::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PivotPeer::name() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotPeer.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PivotPeer::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.PivotPeer.Name)
}
inline std::string* PivotPeer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotPeer.Name)
  return _s;
}
inline const std::string& PivotPeer::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PivotPeer::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PivotPeer::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* PivotPeer::release_name() {
  // @@protoc_insertion_point(field_release:sliverpb.PivotPeer.Name)
  return _impl_.name_.Release();
}
inline void PivotPeer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PivotPeer.Name)
}

// -------------------------------------------------------------------

// PivotPeerEnvelope

// repeated .sliverpb.PivotPeer Peers = 1;
inline int PivotPeerEnvelope::_internal_peers_size() const {
  return _impl_.peers_.size();
}
inline int PivotPeerEnvelope::peers_size() const {
  return _internal_peers_size();
}
inline void PivotPeerEnvelope::clear_peers() {
  _impl_.peers_.Clear();
}
inline ::sliverpb::PivotPeer* PivotPeerEnvelope::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotPeerEnvelope.Peers)
  return _impl_.peers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::PivotPeer >*
PivotPeerEnvelope::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.PivotPeerEnvelope.Peers)
  return &_impl_.peers_;
}
inline const ::sliverpb::PivotPeer& PivotPeerEnvelope::_internal_peers(int index) const {
  return _impl_.peers_.Get(index);
}
inline const ::sliverpb::PivotPeer& PivotPeerEnvelope::peers(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotPeerEnvelope.Peers)
  return _internal_peers(index);
}
inline ::sliverpb::PivotPeer* PivotPeerEnvelope::_internal_add_peers() {
  return _impl_.peers_.Add();
}
inline ::sliverpb::PivotPeer* PivotPeerEnvelope::add_peers() {
  ::sliverpb::PivotPeer* _add = _internal_add_peers();
  // @@protoc_insertion_point(field_add:sliverpb.PivotPeerEnvelope.Peers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::PivotPeer >&
PivotPeerEnvelope::peers() const {
  // @@protoc_insertion_point(field_list:sliverpb.PivotPeerEnvelope.Peers)
  return _impl_.peers_;
}

// uint32 Type = 2;
inline void PivotPeerEnvelope::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t PivotPeerEnvelope::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t PivotPeerEnvelope::type() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotPeerEnvelope.Type)
  return _internal_type();
}
inline void PivotPeerEnvelope::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void PivotPeerEnvelope::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sliverpb.PivotPeerEnvelope.Type)
}

// bytes PivotSessionID = 3;
inline void PivotPeerEnvelope::clear_pivotsessionid() {
  _impl_.pivotsessionid_.ClearToEmpty();
}
inline const std::string& PivotPeerEnvelope::pivotsessionid() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotPeerEnvelope.PivotSessionID)
  return _internal_pivotsessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PivotPeerEnvelope::set_pivotsessionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pivotsessionid_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.PivotPeerEnvelope.PivotSessionID)
}
inline std::string* PivotPeerEnvelope::mutable_pivotsessionid() {
  std::string* _s = _internal_mutable_pivotsessionid();
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotPeerEnvelope.PivotSessionID)
  return _s;
}
inline const std::string& PivotPeerEnvelope::_internal_pivotsessionid() const {
  return _impl_.pivotsessionid_.Get();
}
inline void PivotPeerEnvelope::_internal_set_pivotsessionid(const std::string& value) {
  
  _impl_.pivotsessionid_.Set(value, GetArenaForAllocation());
}
inline std::string* PivotPeerEnvelope::_internal_mutable_pivotsessionid() {
  
  return _impl_.pivotsessionid_.Mutable(GetArenaForAllocation());
}
inline std::string* PivotPeerEnvelope::release_pivotsessionid() {
  // @@protoc_insertion_point(field_release:sliverpb.PivotPeerEnvelope.PivotSessionID)
  return _impl_.pivotsessionid_.Release();
}
inline void PivotPeerEnvelope::set_allocated_pivotsessionid(std::string* pivotsessionid) {
  if (pivotsessionid != nullptr) {
    
  } else {
    
  }
  _impl_.pivotsessionid_.SetAllocated(pivotsessionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pivotsessionid_.IsDefault()) {
    _impl_.pivotsessionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PivotPeerEnvelope.PivotSessionID)
}

// bytes Data = 4;
inline void PivotPeerEnvelope::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& PivotPeerEnvelope::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotPeerEnvelope.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PivotPeerEnvelope::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.PivotPeerEnvelope.Data)
}
inline std::string* PivotPeerEnvelope::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotPeerEnvelope.Data)
  return _s;
}
inline const std::string& PivotPeerEnvelope::_internal_data() const {
  return _impl_.data_.Get();
}
inline void PivotPeerEnvelope::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* PivotPeerEnvelope::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* PivotPeerEnvelope::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.PivotPeerEnvelope.Data)
  return _impl_.data_.Release();
}
inline void PivotPeerEnvelope::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PivotPeerEnvelope.Data)
}

// int64 PeerFailureAt = 5;
inline void PivotPeerEnvelope::clear_peerfailureat() {
  _impl_.peerfailureat_ = int64_t{0};
}
inline int64_t PivotPeerEnvelope::_internal_peerfailureat() const {
  return _impl_.peerfailureat_;
}
inline int64_t PivotPeerEnvelope::peerfailureat() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotPeerEnvelope.PeerFailureAt)
  return _internal_peerfailureat();
}
inline void PivotPeerEnvelope::_internal_set_peerfailureat(int64_t value) {
  
  _impl_.peerfailureat_ = value;
}
inline void PivotPeerEnvelope::set_peerfailureat(int64_t value) {
  _internal_set_peerfailureat(value);
  // @@protoc_insertion_point(field_set:sliverpb.PivotPeerEnvelope.PeerFailureAt)
}

// -------------------------------------------------------------------

// PivotPing

// uint32 Nonce = 1;
inline void PivotPing::clear_nonce() {
  _impl_.nonce_ = 0u;
}
inline uint32_t PivotPing::_internal_nonce() const {
  return _impl_.nonce_;
}
inline uint32_t PivotPing::nonce() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotPing.Nonce)
  return _internal_nonce();
}
inline void PivotPing::_internal_set_nonce(uint32_t value) {
  
  _impl_.nonce_ = value;
}
inline void PivotPing::set_nonce(uint32_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:sliverpb.PivotPing.Nonce)
}

// -------------------------------------------------------------------

// NetConnPivot

// int64 PeerID = 1 [jstype = JS_STRING];
inline void NetConnPivot::clear_peerid() {
  _impl_.peerid_ = int64_t{0};
}
inline int64_t NetConnPivot::_internal_peerid() const {
  return _impl_.peerid_;
}
inline int64_t NetConnPivot::peerid() const {
  // @@protoc_insertion_point(field_get:sliverpb.NetConnPivot.PeerID)
  return _internal_peerid();
}
inline void NetConnPivot::_internal_set_peerid(int64_t value) {
  
  _impl_.peerid_ = value;
}
inline void NetConnPivot::set_peerid(int64_t value) {
  _internal_set_peerid(value);
  // @@protoc_insertion_point(field_set:sliverpb.NetConnPivot.PeerID)
}

// string RemoteAddress = 2;
inline void NetConnPivot::clear_remoteaddress() {
  _impl_.remoteaddress_.ClearToEmpty();
}
inline const std::string& NetConnPivot::remoteaddress() const {
  // @@protoc_insertion_point(field_get:sliverpb.NetConnPivot.RemoteAddress)
  return _internal_remoteaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetConnPivot::set_remoteaddress(ArgT0&& arg0, ArgT... args) {
 
 _impl_.remoteaddress_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.NetConnPivot.RemoteAddress)
}
inline std::string* NetConnPivot::mutable_remoteaddress() {
  std::string* _s = _internal_mutable_remoteaddress();
  // @@protoc_insertion_point(field_mutable:sliverpb.NetConnPivot.RemoteAddress)
  return _s;
}
inline const std::string& NetConnPivot::_internal_remoteaddress() const {
  return _impl_.remoteaddress_.Get();
}
inline void NetConnPivot::_internal_set_remoteaddress(const std::string& value) {
  
  _impl_.remoteaddress_.Set(value, GetArenaForAllocation());
}
inline std::string* NetConnPivot::_internal_mutable_remoteaddress() {
  
  return _impl_.remoteaddress_.Mutable(GetArenaForAllocation());
}
inline std::string* NetConnPivot::release_remoteaddress() {
  // @@protoc_insertion_point(field_release:sliverpb.NetConnPivot.RemoteAddress)
  return _impl_.remoteaddress_.Release();
}
inline void NetConnPivot::set_allocated_remoteaddress(std::string* remoteaddress) {
  if (remoteaddress != nullptr) {
    
  } else {
    
  }
  _impl_.remoteaddress_.SetAllocated(remoteaddress, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remoteaddress_.IsDefault()) {
    _impl_.remoteaddress_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.NetConnPivot.RemoteAddress)
}

// -------------------------------------------------------------------

// PivotPeerFailure

// int64 PeerID = 1 [jstype = JS_STRING];
inline void PivotPeerFailure::clear_peerid() {
  _impl_.peerid_ = int64_t{0};
}
inline int64_t PivotPeerFailure::_internal_peerid() const {
  return _impl_.peerid_;
}
inline int64_t PivotPeerFailure::peerid() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotPeerFailure.PeerID)
  return _internal_peerid();
}
inline void PivotPeerFailure::_internal_set_peerid(int64_t value) {
  
  _impl_.peerid_ = value;
}
inline void PivotPeerFailure::set_peerid(int64_t value) {
  _internal_set_peerid(value);
  // @@protoc_insertion_point(field_set:sliverpb.PivotPeerFailure.PeerID)
}

// .sliverpb.PeerFailureType Type = 2;
inline void PivotPeerFailure::clear_type() {
  _impl_.type_ = 0;
}
inline ::sliverpb::PeerFailureType PivotPeerFailure::_internal_type() const {
  return static_cast< ::sliverpb::PeerFailureType >(_impl_.type_);
}
inline ::sliverpb::PeerFailureType PivotPeerFailure::type() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotPeerFailure.Type)
  return _internal_type();
}
inline void PivotPeerFailure::_internal_set_type(::sliverpb::PeerFailureType value) {
  
  _impl_.type_ = value;
}
inline void PivotPeerFailure::set_type(::sliverpb::PeerFailureType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sliverpb.PivotPeerFailure.Type)
}

// string Err = 3;
inline void PivotPeerFailure::clear_err() {
  _impl_.err_.ClearToEmpty();
}
inline const std::string& PivotPeerFailure::err() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotPeerFailure.Err)
  return _internal_err();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PivotPeerFailure::set_err(ArgT0&& arg0, ArgT... args) {
 
 _impl_.err_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.PivotPeerFailure.Err)
}
inline std::string* PivotPeerFailure::mutable_err() {
  std::string* _s = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotPeerFailure.Err)
  return _s;
}
inline const std::string& PivotPeerFailure::_internal_err() const {
  return _impl_.err_.Get();
}
inline void PivotPeerFailure::_internal_set_err(const std::string& value) {
  
  _impl_.err_.Set(value, GetArenaForAllocation());
}
inline std::string* PivotPeerFailure::_internal_mutable_err() {
  
  return _impl_.err_.Mutable(GetArenaForAllocation());
}
inline std::string* PivotPeerFailure::release_err() {
  // @@protoc_insertion_point(field_release:sliverpb.PivotPeerFailure.Err)
  return _impl_.err_.Release();
}
inline void PivotPeerFailure::set_allocated_err(std::string* err) {
  if (err != nullptr) {
    
  } else {
    
  }
  _impl_.err_.SetAllocated(err, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.err_.IsDefault()) {
    _impl_.err_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PivotPeerFailure.Err)
}

// -------------------------------------------------------------------

// PivotListenersReq

// .sliverpb.Request Request = 9;
inline bool PivotListenersReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool PivotListenersReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& PivotListenersReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& PivotListenersReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotListenersReq.Request)
  return _internal_request();
}
inline void PivotListenersReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.PivotListenersReq.Request)
}
inline ::sliverpb::Request* PivotListenersReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* PivotListenersReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.PivotListenersReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* PivotListenersReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* PivotListenersReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotListenersReq.Request)
  return _msg;
}
inline void PivotListenersReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PivotListenersReq.Request)
}

// -------------------------------------------------------------------

// PivotListeners

// repeated .sliverpb.PivotListener Listeners = 1;
inline int PivotListeners::_internal_listeners_size() const {
  return _impl_.listeners_.size();
}
inline int PivotListeners::listeners_size() const {
  return _internal_listeners_size();
}
inline void PivotListeners::clear_listeners() {
  _impl_.listeners_.Clear();
}
inline ::sliverpb::PivotListener* PivotListeners::mutable_listeners(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotListeners.Listeners)
  return _impl_.listeners_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::PivotListener >*
PivotListeners::mutable_listeners() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.PivotListeners.Listeners)
  return &_impl_.listeners_;
}
inline const ::sliverpb::PivotListener& PivotListeners::_internal_listeners(int index) const {
  return _impl_.listeners_.Get(index);
}
inline const ::sliverpb::PivotListener& PivotListeners::listeners(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotListeners.Listeners)
  return _internal_listeners(index);
}
inline ::sliverpb::PivotListener* PivotListeners::_internal_add_listeners() {
  return _impl_.listeners_.Add();
}
inline ::sliverpb::PivotListener* PivotListeners::add_listeners() {
  ::sliverpb::PivotListener* _add = _internal_add_listeners();
  // @@protoc_insertion_point(field_add:sliverpb.PivotListeners.Listeners)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::PivotListener >&
PivotListeners::listeners() const {
  // @@protoc_insertion_point(field_list:sliverpb.PivotListeners.Listeners)
  return _impl_.listeners_;
}

// .sliverpb.Response Response = 9;
inline bool PivotListeners::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool PivotListeners::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& PivotListeners::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& PivotListeners::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.PivotListeners.Response)
  return _internal_response();
}
inline void PivotListeners::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.PivotListeners.Response)
}
inline ::sliverpb::Response* PivotListeners::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* PivotListeners::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.PivotListeners.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* PivotListeners::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* PivotListeners::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.PivotListeners.Response)
  return _msg;
}
inline void PivotListeners::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PivotListeners.Response)
}

// -------------------------------------------------------------------

// WGPortForwardStartReq

// int32 LocalPort = 1;
inline void WGPortForwardStartReq::clear_localport() {
  _impl_.localport_ = 0;
}
inline int32_t WGPortForwardStartReq::_internal_localport() const {
  return _impl_.localport_;
}
inline int32_t WGPortForwardStartReq::localport() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGPortForwardStartReq.LocalPort)
  return _internal_localport();
}
inline void WGPortForwardStartReq::_internal_set_localport(int32_t value) {
  
  _impl_.localport_ = value;
}
inline void WGPortForwardStartReq::set_localport(int32_t value) {
  _internal_set_localport(value);
  // @@protoc_insertion_point(field_set:sliverpb.WGPortForwardStartReq.LocalPort)
}

// string RemoteAddress = 2;
inline void WGPortForwardStartReq::clear_remoteaddress() {
  _impl_.remoteaddress_.ClearToEmpty();
}
inline const std::string& WGPortForwardStartReq::remoteaddress() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGPortForwardStartReq.RemoteAddress)
  return _internal_remoteaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WGPortForwardStartReq::set_remoteaddress(ArgT0&& arg0, ArgT... args) {
 
 _impl_.remoteaddress_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.WGPortForwardStartReq.RemoteAddress)
}
inline std::string* WGPortForwardStartReq::mutable_remoteaddress() {
  std::string* _s = _internal_mutable_remoteaddress();
  // @@protoc_insertion_point(field_mutable:sliverpb.WGPortForwardStartReq.RemoteAddress)
  return _s;
}
inline const std::string& WGPortForwardStartReq::_internal_remoteaddress() const {
  return _impl_.remoteaddress_.Get();
}
inline void WGPortForwardStartReq::_internal_set_remoteaddress(const std::string& value) {
  
  _impl_.remoteaddress_.Set(value, GetArenaForAllocation());
}
inline std::string* WGPortForwardStartReq::_internal_mutable_remoteaddress() {
  
  return _impl_.remoteaddress_.Mutable(GetArenaForAllocation());
}
inline std::string* WGPortForwardStartReq::release_remoteaddress() {
  // @@protoc_insertion_point(field_release:sliverpb.WGPortForwardStartReq.RemoteAddress)
  return _impl_.remoteaddress_.Release();
}
inline void WGPortForwardStartReq::set_allocated_remoteaddress(std::string* remoteaddress) {
  if (remoteaddress != nullptr) {
    
  } else {
    
  }
  _impl_.remoteaddress_.SetAllocated(remoteaddress, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remoteaddress_.IsDefault()) {
    _impl_.remoteaddress_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WGPortForwardStartReq.RemoteAddress)
}

// .sliverpb.Request Request = 9;
inline bool WGPortForwardStartReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool WGPortForwardStartReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& WGPortForwardStartReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& WGPortForwardStartReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGPortForwardStartReq.Request)
  return _internal_request();
}
inline void WGPortForwardStartReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.WGPortForwardStartReq.Request)
}
inline ::sliverpb::Request* WGPortForwardStartReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* WGPortForwardStartReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.WGPortForwardStartReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* WGPortForwardStartReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* WGPortForwardStartReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.WGPortForwardStartReq.Request)
  return _msg;
}
inline void WGPortForwardStartReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WGPortForwardStartReq.Request)
}

// -------------------------------------------------------------------

// WGPortForward

// .sliverpb.WGTCPForwarder Forwarder = 1;
inline bool WGPortForward::_internal_has_forwarder() const {
  return this != internal_default_instance() && _impl_.forwarder_ != nullptr;
}
inline bool WGPortForward::has_forwarder() const {
  return _internal_has_forwarder();
}
inline void WGPortForward::clear_forwarder() {
  if (GetArenaForAllocation() == nullptr && _impl_.forwarder_ != nullptr) {
    delete _impl_.forwarder_;
  }
  _impl_.forwarder_ = nullptr;
}
inline const ::sliverpb::WGTCPForwarder& WGPortForward::_internal_forwarder() const {
  const ::sliverpb::WGTCPForwarder* p = _impl_.forwarder_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::WGTCPForwarder&>(
      ::sliverpb::_WGTCPForwarder_default_instance_);
}
inline const ::sliverpb::WGTCPForwarder& WGPortForward::forwarder() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGPortForward.Forwarder)
  return _internal_forwarder();
}
inline void WGPortForward::unsafe_arena_set_allocated_forwarder(
    ::sliverpb::WGTCPForwarder* forwarder) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.forwarder_);
  }
  _impl_.forwarder_ = forwarder;
  if (forwarder) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.WGPortForward.Forwarder)
}
inline ::sliverpb::WGTCPForwarder* WGPortForward::release_forwarder() {
  
  ::sliverpb::WGTCPForwarder* temp = _impl_.forwarder_;
  _impl_.forwarder_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::WGTCPForwarder* WGPortForward::unsafe_arena_release_forwarder() {
  // @@protoc_insertion_point(field_release:sliverpb.WGPortForward.Forwarder)
  
  ::sliverpb::WGTCPForwarder* temp = _impl_.forwarder_;
  _impl_.forwarder_ = nullptr;
  return temp;
}
inline ::sliverpb::WGTCPForwarder* WGPortForward::_internal_mutable_forwarder() {
  
  if (_impl_.forwarder_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::WGTCPForwarder>(GetArenaForAllocation());
    _impl_.forwarder_ = p;
  }
  return _impl_.forwarder_;
}
inline ::sliverpb::WGTCPForwarder* WGPortForward::mutable_forwarder() {
  ::sliverpb::WGTCPForwarder* _msg = _internal_mutable_forwarder();
  // @@protoc_insertion_point(field_mutable:sliverpb.WGPortForward.Forwarder)
  return _msg;
}
inline void WGPortForward::set_allocated_forwarder(::sliverpb::WGTCPForwarder* forwarder) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.forwarder_;
  }
  if (forwarder) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(forwarder);
    if (message_arena != submessage_arena) {
      forwarder = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, forwarder, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.forwarder_ = forwarder;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WGPortForward.Forwarder)
}

// .sliverpb.Response Response = 9;
inline bool WGPortForward::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool WGPortForward::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& WGPortForward::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& WGPortForward::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGPortForward.Response)
  return _internal_response();
}
inline void WGPortForward::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.WGPortForward.Response)
}
inline ::sliverpb::Response* WGPortForward::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* WGPortForward::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.WGPortForward.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* WGPortForward::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* WGPortForward::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.WGPortForward.Response)
  return _msg;
}
inline void WGPortForward::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WGPortForward.Response)
}

// -------------------------------------------------------------------

// WGPortForwardStopReq

// int32 ID = 1;
inline void WGPortForwardStopReq::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t WGPortForwardStopReq::_internal_id() const {
  return _impl_.id_;
}
inline int32_t WGPortForwardStopReq::id() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGPortForwardStopReq.ID)
  return _internal_id();
}
inline void WGPortForwardStopReq::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void WGPortForwardStopReq::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sliverpb.WGPortForwardStopReq.ID)
}

// .sliverpb.Request Request = 9;
inline bool WGPortForwardStopReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool WGPortForwardStopReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& WGPortForwardStopReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& WGPortForwardStopReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGPortForwardStopReq.Request)
  return _internal_request();
}
inline void WGPortForwardStopReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.WGPortForwardStopReq.Request)
}
inline ::sliverpb::Request* WGPortForwardStopReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* WGPortForwardStopReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.WGPortForwardStopReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* WGPortForwardStopReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* WGPortForwardStopReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.WGPortForwardStopReq.Request)
  return _msg;
}
inline void WGPortForwardStopReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WGPortForwardStopReq.Request)
}

// -------------------------------------------------------------------

// WGSocksStartReq

// int32 Port = 1;
inline void WGSocksStartReq::clear_port() {
  _impl_.port_ = 0;
}
inline int32_t WGSocksStartReq::_internal_port() const {
  return _impl_.port_;
}
inline int32_t WGSocksStartReq::port() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGSocksStartReq.Port)
  return _internal_port();
}
inline void WGSocksStartReq::_internal_set_port(int32_t value) {
  
  _impl_.port_ = value;
}
inline void WGSocksStartReq::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:sliverpb.WGSocksStartReq.Port)
}

// .sliverpb.Request Request = 9;
inline bool WGSocksStartReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool WGSocksStartReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& WGSocksStartReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& WGSocksStartReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGSocksStartReq.Request)
  return _internal_request();
}
inline void WGSocksStartReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.WGSocksStartReq.Request)
}
inline ::sliverpb::Request* WGSocksStartReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* WGSocksStartReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.WGSocksStartReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* WGSocksStartReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* WGSocksStartReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.WGSocksStartReq.Request)
  return _msg;
}
inline void WGSocksStartReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WGSocksStartReq.Request)
}

// -------------------------------------------------------------------

// WGSocks

// .sliverpb.WGSocksServer Server = 1;
inline bool WGSocks::_internal_has_server() const {
  return this != internal_default_instance() && _impl_.server_ != nullptr;
}
inline bool WGSocks::has_server() const {
  return _internal_has_server();
}
inline void WGSocks::clear_server() {
  if (GetArenaForAllocation() == nullptr && _impl_.server_ != nullptr) {
    delete _impl_.server_;
  }
  _impl_.server_ = nullptr;
}
inline const ::sliverpb::WGSocksServer& WGSocks::_internal_server() const {
  const ::sliverpb::WGSocksServer* p = _impl_.server_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::WGSocksServer&>(
      ::sliverpb::_WGSocksServer_default_instance_);
}
inline const ::sliverpb::WGSocksServer& WGSocks::server() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGSocks.Server)
  return _internal_server();
}
inline void WGSocks::unsafe_arena_set_allocated_server(
    ::sliverpb::WGSocksServer* server) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_);
  }
  _impl_.server_ = server;
  if (server) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.WGSocks.Server)
}
inline ::sliverpb::WGSocksServer* WGSocks::release_server() {
  
  ::sliverpb::WGSocksServer* temp = _impl_.server_;
  _impl_.server_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::WGSocksServer* WGSocks::unsafe_arena_release_server() {
  // @@protoc_insertion_point(field_release:sliverpb.WGSocks.Server)
  
  ::sliverpb::WGSocksServer* temp = _impl_.server_;
  _impl_.server_ = nullptr;
  return temp;
}
inline ::sliverpb::WGSocksServer* WGSocks::_internal_mutable_server() {
  
  if (_impl_.server_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::WGSocksServer>(GetArenaForAllocation());
    _impl_.server_ = p;
  }
  return _impl_.server_;
}
inline ::sliverpb::WGSocksServer* WGSocks::mutable_server() {
  ::sliverpb::WGSocksServer* _msg = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:sliverpb.WGSocks.Server)
  return _msg;
}
inline void WGSocks::set_allocated_server(::sliverpb::WGSocksServer* server) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.server_;
  }
  if (server) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(server);
    if (message_arena != submessage_arena) {
      server = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.server_ = server;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WGSocks.Server)
}

// .sliverpb.Response Response = 9;
inline bool WGSocks::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool WGSocks::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& WGSocks::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& WGSocks::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGSocks.Response)
  return _internal_response();
}
inline void WGSocks::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.WGSocks.Response)
}
inline ::sliverpb::Response* WGSocks::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* WGSocks::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.WGSocks.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* WGSocks::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* WGSocks::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.WGSocks.Response)
  return _msg;
}
inline void WGSocks::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WGSocks.Response)
}

// -------------------------------------------------------------------

// WGSocksStopReq

// int32 ID = 1;
inline void WGSocksStopReq::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t WGSocksStopReq::_internal_id() const {
  return _impl_.id_;
}
inline int32_t WGSocksStopReq::id() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGSocksStopReq.ID)
  return _internal_id();
}
inline void WGSocksStopReq::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void WGSocksStopReq::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sliverpb.WGSocksStopReq.ID)
}

// .sliverpb.Request Request = 9;
inline bool WGSocksStopReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool WGSocksStopReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& WGSocksStopReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& WGSocksStopReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGSocksStopReq.Request)
  return _internal_request();
}
inline void WGSocksStopReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.WGSocksStopReq.Request)
}
inline ::sliverpb::Request* WGSocksStopReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* WGSocksStopReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.WGSocksStopReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* WGSocksStopReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* WGSocksStopReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.WGSocksStopReq.Request)
  return _msg;
}
inline void WGSocksStopReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WGSocksStopReq.Request)
}

// -------------------------------------------------------------------

// WGTCPForwardersReq

// .sliverpb.Request Request = 9;
inline bool WGTCPForwardersReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool WGTCPForwardersReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& WGTCPForwardersReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& WGTCPForwardersReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGTCPForwardersReq.Request)
  return _internal_request();
}
inline void WGTCPForwardersReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.WGTCPForwardersReq.Request)
}
inline ::sliverpb::Request* WGTCPForwardersReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* WGTCPForwardersReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.WGTCPForwardersReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* WGTCPForwardersReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* WGTCPForwardersReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.WGTCPForwardersReq.Request)
  return _msg;
}
inline void WGTCPForwardersReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WGTCPForwardersReq.Request)
}

// -------------------------------------------------------------------

// WGSocksServersReq

// .sliverpb.Request Request = 9;
inline bool WGSocksServersReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool WGSocksServersReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& WGSocksServersReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& WGSocksServersReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGSocksServersReq.Request)
  return _internal_request();
}
inline void WGSocksServersReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.WGSocksServersReq.Request)
}
inline ::sliverpb::Request* WGSocksServersReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* WGSocksServersReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.WGSocksServersReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* WGSocksServersReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* WGSocksServersReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.WGSocksServersReq.Request)
  return _msg;
}
inline void WGSocksServersReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WGSocksServersReq.Request)
}

// -------------------------------------------------------------------

// WGTCPForwarder

// int32 ID = 1;
inline void WGTCPForwarder::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t WGTCPForwarder::_internal_id() const {
  return _impl_.id_;
}
inline int32_t WGTCPForwarder::id() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGTCPForwarder.ID)
  return _internal_id();
}
inline void WGTCPForwarder::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void WGTCPForwarder::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sliverpb.WGTCPForwarder.ID)
}

// string LocalAddr = 2;
inline void WGTCPForwarder::clear_localaddr() {
  _impl_.localaddr_.ClearToEmpty();
}
inline const std::string& WGTCPForwarder::localaddr() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGTCPForwarder.LocalAddr)
  return _internal_localaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WGTCPForwarder::set_localaddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.localaddr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.WGTCPForwarder.LocalAddr)
}
inline std::string* WGTCPForwarder::mutable_localaddr() {
  std::string* _s = _internal_mutable_localaddr();
  // @@protoc_insertion_point(field_mutable:sliverpb.WGTCPForwarder.LocalAddr)
  return _s;
}
inline const std::string& WGTCPForwarder::_internal_localaddr() const {
  return _impl_.localaddr_.Get();
}
inline void WGTCPForwarder::_internal_set_localaddr(const std::string& value) {
  
  _impl_.localaddr_.Set(value, GetArenaForAllocation());
}
inline std::string* WGTCPForwarder::_internal_mutable_localaddr() {
  
  return _impl_.localaddr_.Mutable(GetArenaForAllocation());
}
inline std::string* WGTCPForwarder::release_localaddr() {
  // @@protoc_insertion_point(field_release:sliverpb.WGTCPForwarder.LocalAddr)
  return _impl_.localaddr_.Release();
}
inline void WGTCPForwarder::set_allocated_localaddr(std::string* localaddr) {
  if (localaddr != nullptr) {
    
  } else {
    
  }
  _impl_.localaddr_.SetAllocated(localaddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.localaddr_.IsDefault()) {
    _impl_.localaddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WGTCPForwarder.LocalAddr)
}

// string RemoteAddr = 3;
inline void WGTCPForwarder::clear_remoteaddr() {
  _impl_.remoteaddr_.ClearToEmpty();
}
inline const std::string& WGTCPForwarder::remoteaddr() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGTCPForwarder.RemoteAddr)
  return _internal_remoteaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WGTCPForwarder::set_remoteaddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.remoteaddr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.WGTCPForwarder.RemoteAddr)
}
inline std::string* WGTCPForwarder::mutable_remoteaddr() {
  std::string* _s = _internal_mutable_remoteaddr();
  // @@protoc_insertion_point(field_mutable:sliverpb.WGTCPForwarder.RemoteAddr)
  return _s;
}
inline const std::string& WGTCPForwarder::_internal_remoteaddr() const {
  return _impl_.remoteaddr_.Get();
}
inline void WGTCPForwarder::_internal_set_remoteaddr(const std::string& value) {
  
  _impl_.remoteaddr_.Set(value, GetArenaForAllocation());
}
inline std::string* WGTCPForwarder::_internal_mutable_remoteaddr() {
  
  return _impl_.remoteaddr_.Mutable(GetArenaForAllocation());
}
inline std::string* WGTCPForwarder::release_remoteaddr() {
  // @@protoc_insertion_point(field_release:sliverpb.WGTCPForwarder.RemoteAddr)
  return _impl_.remoteaddr_.Release();
}
inline void WGTCPForwarder::set_allocated_remoteaddr(std::string* remoteaddr) {
  if (remoteaddr != nullptr) {
    
  } else {
    
  }
  _impl_.remoteaddr_.SetAllocated(remoteaddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remoteaddr_.IsDefault()) {
    _impl_.remoteaddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WGTCPForwarder.RemoteAddr)
}

// -------------------------------------------------------------------

// WGSocksServer

// int32 ID = 1;
inline void WGSocksServer::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t WGSocksServer::_internal_id() const {
  return _impl_.id_;
}
inline int32_t WGSocksServer::id() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGSocksServer.ID)
  return _internal_id();
}
inline void WGSocksServer::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void WGSocksServer::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sliverpb.WGSocksServer.ID)
}

// string LocalAddr = 2;
inline void WGSocksServer::clear_localaddr() {
  _impl_.localaddr_.ClearToEmpty();
}
inline const std::string& WGSocksServer::localaddr() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGSocksServer.LocalAddr)
  return _internal_localaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WGSocksServer::set_localaddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.localaddr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.WGSocksServer.LocalAddr)
}
inline std::string* WGSocksServer::mutable_localaddr() {
  std::string* _s = _internal_mutable_localaddr();
  // @@protoc_insertion_point(field_mutable:sliverpb.WGSocksServer.LocalAddr)
  return _s;
}
inline const std::string& WGSocksServer::_internal_localaddr() const {
  return _impl_.localaddr_.Get();
}
inline void WGSocksServer::_internal_set_localaddr(const std::string& value) {
  
  _impl_.localaddr_.Set(value, GetArenaForAllocation());
}
inline std::string* WGSocksServer::_internal_mutable_localaddr() {
  
  return _impl_.localaddr_.Mutable(GetArenaForAllocation());
}
inline std::string* WGSocksServer::release_localaddr() {
  // @@protoc_insertion_point(field_release:sliverpb.WGSocksServer.LocalAddr)
  return _impl_.localaddr_.Release();
}
inline void WGSocksServer::set_allocated_localaddr(std::string* localaddr) {
  if (localaddr != nullptr) {
    
  } else {
    
  }
  _impl_.localaddr_.SetAllocated(localaddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.localaddr_.IsDefault()) {
    _impl_.localaddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WGSocksServer.LocalAddr)
}

// -------------------------------------------------------------------

// WGSocksServers

// repeated .sliverpb.WGSocksServer Servers = 1;
inline int WGSocksServers::_internal_servers_size() const {
  return _impl_.servers_.size();
}
inline int WGSocksServers::servers_size() const {
  return _internal_servers_size();
}
inline void WGSocksServers::clear_servers() {
  _impl_.servers_.Clear();
}
inline ::sliverpb::WGSocksServer* WGSocksServers::mutable_servers(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.WGSocksServers.Servers)
  return _impl_.servers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::WGSocksServer >*
WGSocksServers::mutable_servers() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.WGSocksServers.Servers)
  return &_impl_.servers_;
}
inline const ::sliverpb::WGSocksServer& WGSocksServers::_internal_servers(int index) const {
  return _impl_.servers_.Get(index);
}
inline const ::sliverpb::WGSocksServer& WGSocksServers::servers(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.WGSocksServers.Servers)
  return _internal_servers(index);
}
inline ::sliverpb::WGSocksServer* WGSocksServers::_internal_add_servers() {
  return _impl_.servers_.Add();
}
inline ::sliverpb::WGSocksServer* WGSocksServers::add_servers() {
  ::sliverpb::WGSocksServer* _add = _internal_add_servers();
  // @@protoc_insertion_point(field_add:sliverpb.WGSocksServers.Servers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::WGSocksServer >&
WGSocksServers::servers() const {
  // @@protoc_insertion_point(field_list:sliverpb.WGSocksServers.Servers)
  return _impl_.servers_;
}

// .sliverpb.Response Response = 9;
inline bool WGSocksServers::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool WGSocksServers::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& WGSocksServers::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& WGSocksServers::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGSocksServers.Response)
  return _internal_response();
}
inline void WGSocksServers::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.WGSocksServers.Response)
}
inline ::sliverpb::Response* WGSocksServers::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* WGSocksServers::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.WGSocksServers.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* WGSocksServers::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* WGSocksServers::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.WGSocksServers.Response)
  return _msg;
}
inline void WGSocksServers::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WGSocksServers.Response)
}

// -------------------------------------------------------------------

// WGTCPForwarders

// repeated .sliverpb.WGTCPForwarder Forwarders = 1;
inline int WGTCPForwarders::_internal_forwarders_size() const {
  return _impl_.forwarders_.size();
}
inline int WGTCPForwarders::forwarders_size() const {
  return _internal_forwarders_size();
}
inline void WGTCPForwarders::clear_forwarders() {
  _impl_.forwarders_.Clear();
}
inline ::sliverpb::WGTCPForwarder* WGTCPForwarders::mutable_forwarders(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.WGTCPForwarders.Forwarders)
  return _impl_.forwarders_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::WGTCPForwarder >*
WGTCPForwarders::mutable_forwarders() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.WGTCPForwarders.Forwarders)
  return &_impl_.forwarders_;
}
inline const ::sliverpb::WGTCPForwarder& WGTCPForwarders::_internal_forwarders(int index) const {
  return _impl_.forwarders_.Get(index);
}
inline const ::sliverpb::WGTCPForwarder& WGTCPForwarders::forwarders(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.WGTCPForwarders.Forwarders)
  return _internal_forwarders(index);
}
inline ::sliverpb::WGTCPForwarder* WGTCPForwarders::_internal_add_forwarders() {
  return _impl_.forwarders_.Add();
}
inline ::sliverpb::WGTCPForwarder* WGTCPForwarders::add_forwarders() {
  ::sliverpb::WGTCPForwarder* _add = _internal_add_forwarders();
  // @@protoc_insertion_point(field_add:sliverpb.WGTCPForwarders.Forwarders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::WGTCPForwarder >&
WGTCPForwarders::forwarders() const {
  // @@protoc_insertion_point(field_list:sliverpb.WGTCPForwarders.Forwarders)
  return _impl_.forwarders_;
}

// .sliverpb.Response Response = 9;
inline bool WGTCPForwarders::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool WGTCPForwarders::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& WGTCPForwarders::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& WGTCPForwarders::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.WGTCPForwarders.Response)
  return _internal_response();
}
inline void WGTCPForwarders::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.WGTCPForwarders.Response)
}
inline ::sliverpb::Response* WGTCPForwarders::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* WGTCPForwarders::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.WGTCPForwarders.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* WGTCPForwarders::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* WGTCPForwarders::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.WGTCPForwarders.Response)
  return _msg;
}
inline void WGTCPForwarders::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WGTCPForwarders.Response)
}

// -------------------------------------------------------------------

// ReconfigureReq

// int64 ReconnectInterval = 1;
inline void ReconfigureReq::clear_reconnectinterval() {
  _impl_.reconnectinterval_ = int64_t{0};
}
inline int64_t ReconfigureReq::_internal_reconnectinterval() const {
  return _impl_.reconnectinterval_;
}
inline int64_t ReconfigureReq::reconnectinterval() const {
  // @@protoc_insertion_point(field_get:sliverpb.ReconfigureReq.ReconnectInterval)
  return _internal_reconnectinterval();
}
inline void ReconfigureReq::_internal_set_reconnectinterval(int64_t value) {
  
  _impl_.reconnectinterval_ = value;
}
inline void ReconfigureReq::set_reconnectinterval(int64_t value) {
  _internal_set_reconnectinterval(value);
  // @@protoc_insertion_point(field_set:sliverpb.ReconfigureReq.ReconnectInterval)
}

// int64 BeaconInterval = 2;
inline void ReconfigureReq::clear_beaconinterval() {
  _impl_.beaconinterval_ = int64_t{0};
}
inline int64_t ReconfigureReq::_internal_beaconinterval() const {
  return _impl_.beaconinterval_;
}
inline int64_t ReconfigureReq::beaconinterval() const {
  // @@protoc_insertion_point(field_get:sliverpb.ReconfigureReq.BeaconInterval)
  return _internal_beaconinterval();
}
inline void ReconfigureReq::_internal_set_beaconinterval(int64_t value) {
  
  _impl_.beaconinterval_ = value;
}
inline void ReconfigureReq::set_beaconinterval(int64_t value) {
  _internal_set_beaconinterval(value);
  // @@protoc_insertion_point(field_set:sliverpb.ReconfigureReq.BeaconInterval)
}

// int64 BeaconJitter = 3;
inline void ReconfigureReq::clear_beaconjitter() {
  _impl_.beaconjitter_ = int64_t{0};
}
inline int64_t ReconfigureReq::_internal_beaconjitter() const {
  return _impl_.beaconjitter_;
}
inline int64_t ReconfigureReq::beaconjitter() const {
  // @@protoc_insertion_point(field_get:sliverpb.ReconfigureReq.BeaconJitter)
  return _internal_beaconjitter();
}
inline void ReconfigureReq::_internal_set_beaconjitter(int64_t value) {
  
  _impl_.beaconjitter_ = value;
}
inline void ReconfigureReq::set_beaconjitter(int64_t value) {
  _internal_set_beaconjitter(value);
  // @@protoc_insertion_point(field_set:sliverpb.ReconfigureReq.BeaconJitter)
}

// .sliverpb.Request Request = 9;
inline bool ReconfigureReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool ReconfigureReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& ReconfigureReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& ReconfigureReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.ReconfigureReq.Request)
  return _internal_request();
}
inline void ReconfigureReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.ReconfigureReq.Request)
}
inline ::sliverpb::Request* ReconfigureReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* ReconfigureReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.ReconfigureReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* ReconfigureReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* ReconfigureReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.ReconfigureReq.Request)
  return _msg;
}
inline void ReconfigureReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ReconfigureReq.Request)
}

// -------------------------------------------------------------------

// Reconfigure

// .sliverpb.Response Response = 9;
inline bool Reconfigure::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool Reconfigure::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& Reconfigure::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& Reconfigure::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.Reconfigure.Response)
  return _internal_response();
}
inline void Reconfigure::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.Reconfigure.Response)
}
inline ::sliverpb::Response* Reconfigure::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* Reconfigure::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.Reconfigure.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* Reconfigure::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* Reconfigure::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.Reconfigure.Response)
  return _msg;
}
inline void Reconfigure::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Reconfigure.Response)
}

// -------------------------------------------------------------------

// PollIntervalReq

// int64 PollInterval = 1;
inline void PollIntervalReq::clear_pollinterval() {
  _impl_.pollinterval_ = int64_t{0};
}
inline int64_t PollIntervalReq::_internal_pollinterval() const {
  return _impl_.pollinterval_;
}
inline int64_t PollIntervalReq::pollinterval() const {
  // @@protoc_insertion_point(field_get:sliverpb.PollIntervalReq.PollInterval)
  return _internal_pollinterval();
}
inline void PollIntervalReq::_internal_set_pollinterval(int64_t value) {
  
  _impl_.pollinterval_ = value;
}
inline void PollIntervalReq::set_pollinterval(int64_t value) {
  _internal_set_pollinterval(value);
  // @@protoc_insertion_point(field_set:sliverpb.PollIntervalReq.PollInterval)
}

// .sliverpb.Request Request = 9;
inline bool PollIntervalReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool PollIntervalReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& PollIntervalReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& PollIntervalReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.PollIntervalReq.Request)
  return _internal_request();
}
inline void PollIntervalReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.PollIntervalReq.Request)
}
inline ::sliverpb::Request* PollIntervalReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* PollIntervalReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.PollIntervalReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* PollIntervalReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* PollIntervalReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.PollIntervalReq.Request)
  return _msg;
}
inline void PollIntervalReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PollIntervalReq.Request)
}

// -------------------------------------------------------------------

// PollInterval

// .sliverpb.Response Response = 9;
inline bool PollInterval::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool PollInterval::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& PollInterval::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& PollInterval::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.PollInterval.Response)
  return _internal_response();
}
inline void PollInterval::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.PollInterval.Response)
}
inline ::sliverpb::Response* PollInterval::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* PollInterval::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.PollInterval.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* PollInterval::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* PollInterval::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.PollInterval.Response)
  return _msg;
}
inline void PollInterval::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.PollInterval.Response)
}

// -------------------------------------------------------------------

// SSHCommandReq

// string Username = 1;
inline void SSHCommandReq::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& SSHCommandReq::username() const {
  // @@protoc_insertion_point(field_get:sliverpb.SSHCommandReq.Username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SSHCommandReq::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SSHCommandReq.Username)
}
inline std::string* SSHCommandReq::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:sliverpb.SSHCommandReq.Username)
  return _s;
}
inline const std::string& SSHCommandReq::_internal_username() const {
  return _impl_.username_.Get();
}
inline void SSHCommandReq::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* SSHCommandReq::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* SSHCommandReq::release_username() {
  // @@protoc_insertion_point(field_release:sliverpb.SSHCommandReq.Username)
  return _impl_.username_.Release();
}
inline void SSHCommandReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SSHCommandReq.Username)
}

// string Hostname = 2;
inline void SSHCommandReq::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& SSHCommandReq::hostname() const {
  // @@protoc_insertion_point(field_get:sliverpb.SSHCommandReq.Hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SSHCommandReq::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SSHCommandReq.Hostname)
}
inline std::string* SSHCommandReq::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:sliverpb.SSHCommandReq.Hostname)
  return _s;
}
inline const std::string& SSHCommandReq::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void SSHCommandReq::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* SSHCommandReq::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* SSHCommandReq::release_hostname() {
  // @@protoc_insertion_point(field_release:sliverpb.SSHCommandReq.Hostname)
  return _impl_.hostname_.Release();
}
inline void SSHCommandReq::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SSHCommandReq.Hostname)
}

// uint32 Port = 3;
inline void SSHCommandReq::clear_port() {
  _impl_.port_ = 0u;
}
inline uint32_t SSHCommandReq::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t SSHCommandReq::port() const {
  // @@protoc_insertion_point(field_get:sliverpb.SSHCommandReq.Port)
  return _internal_port();
}
inline void SSHCommandReq::_internal_set_port(uint32_t value) {
  
  _impl_.port_ = value;
}
inline void SSHCommandReq::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:sliverpb.SSHCommandReq.Port)
}

// string Command = 4;
inline void SSHCommandReq::clear_command() {
  _impl_.command_.ClearToEmpty();
}
inline const std::string& SSHCommandReq::command() const {
  // @@protoc_insertion_point(field_get:sliverpb.SSHCommandReq.Command)
  return _internal_command();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SSHCommandReq::set_command(ArgT0&& arg0, ArgT... args) {
 
 _impl_.command_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SSHCommandReq.Command)
}
inline std::string* SSHCommandReq::mutable_command() {
  std::string* _s = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:sliverpb.SSHCommandReq.Command)
  return _s;
}
inline const std::string& SSHCommandReq::_internal_command() const {
  return _impl_.command_.Get();
}
inline void SSHCommandReq::_internal_set_command(const std::string& value) {
  
  _impl_.command_.Set(value, GetArenaForAllocation());
}
inline std::string* SSHCommandReq::_internal_mutable_command() {
  
  return _impl_.command_.Mutable(GetArenaForAllocation());
}
inline std::string* SSHCommandReq::release_command() {
  // @@protoc_insertion_point(field_release:sliverpb.SSHCommandReq.Command)
  return _impl_.command_.Release();
}
inline void SSHCommandReq::set_allocated_command(std::string* command) {
  if (command != nullptr) {
    
  } else {
    
  }
  _impl_.command_.SetAllocated(command, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.command_.IsDefault()) {
    _impl_.command_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SSHCommandReq.Command)
}

// string Password = 5;
inline void SSHCommandReq::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& SSHCommandReq::password() const {
  // @@protoc_insertion_point(field_get:sliverpb.SSHCommandReq.Password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SSHCommandReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SSHCommandReq.Password)
}
inline std::string* SSHCommandReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:sliverpb.SSHCommandReq.Password)
  return _s;
}
inline const std::string& SSHCommandReq::_internal_password() const {
  return _impl_.password_.Get();
}
inline void SSHCommandReq::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* SSHCommandReq::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* SSHCommandReq::release_password() {
  // @@protoc_insertion_point(field_release:sliverpb.SSHCommandReq.Password)
  return _impl_.password_.Release();
}
inline void SSHCommandReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SSHCommandReq.Password)
}

// bytes PrivKey = 6;
inline void SSHCommandReq::clear_privkey() {
  _impl_.privkey_.ClearToEmpty();
}
inline const std::string& SSHCommandReq::privkey() const {
  // @@protoc_insertion_point(field_get:sliverpb.SSHCommandReq.PrivKey)
  return _internal_privkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SSHCommandReq::set_privkey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.privkey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SSHCommandReq.PrivKey)
}
inline std::string* SSHCommandReq::mutable_privkey() {
  std::string* _s = _internal_mutable_privkey();
  // @@protoc_insertion_point(field_mutable:sliverpb.SSHCommandReq.PrivKey)
  return _s;
}
inline const std::string& SSHCommandReq::_internal_privkey() const {
  return _impl_.privkey_.Get();
}
inline void SSHCommandReq::_internal_set_privkey(const std::string& value) {
  
  _impl_.privkey_.Set(value, GetArenaForAllocation());
}
inline std::string* SSHCommandReq::_internal_mutable_privkey() {
  
  return _impl_.privkey_.Mutable(GetArenaForAllocation());
}
inline std::string* SSHCommandReq::release_privkey() {
  // @@protoc_insertion_point(field_release:sliverpb.SSHCommandReq.PrivKey)
  return _impl_.privkey_.Release();
}
inline void SSHCommandReq::set_allocated_privkey(std::string* privkey) {
  if (privkey != nullptr) {
    
  } else {
    
  }
  _impl_.privkey_.SetAllocated(privkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.privkey_.IsDefault()) {
    _impl_.privkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SSHCommandReq.PrivKey)
}

// string Krb5Conf = 7;
inline void SSHCommandReq::clear_krb5conf() {
  _impl_.krb5conf_.ClearToEmpty();
}
inline const std::string& SSHCommandReq::krb5conf() const {
  // @@protoc_insertion_point(field_get:sliverpb.SSHCommandReq.Krb5Conf)
  return _internal_krb5conf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SSHCommandReq::set_krb5conf(ArgT0&& arg0, ArgT... args) {
 
 _impl_.krb5conf_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SSHCommandReq.Krb5Conf)
}
inline std::string* SSHCommandReq::mutable_krb5conf() {
  std::string* _s = _internal_mutable_krb5conf();
  // @@protoc_insertion_point(field_mutable:sliverpb.SSHCommandReq.Krb5Conf)
  return _s;
}
inline const std::string& SSHCommandReq::_internal_krb5conf() const {
  return _impl_.krb5conf_.Get();
}
inline void SSHCommandReq::_internal_set_krb5conf(const std::string& value) {
  
  _impl_.krb5conf_.Set(value, GetArenaForAllocation());
}
inline std::string* SSHCommandReq::_internal_mutable_krb5conf() {
  
  return _impl_.krb5conf_.Mutable(GetArenaForAllocation());
}
inline std::string* SSHCommandReq::release_krb5conf() {
  // @@protoc_insertion_point(field_release:sliverpb.SSHCommandReq.Krb5Conf)
  return _impl_.krb5conf_.Release();
}
inline void SSHCommandReq::set_allocated_krb5conf(std::string* krb5conf) {
  if (krb5conf != nullptr) {
    
  } else {
    
  }
  _impl_.krb5conf_.SetAllocated(krb5conf, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.krb5conf_.IsDefault()) {
    _impl_.krb5conf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SSHCommandReq.Krb5Conf)
}

// bytes Keytab = 8;
inline void SSHCommandReq::clear_keytab() {
  _impl_.keytab_.ClearToEmpty();
}
inline const std::string& SSHCommandReq::keytab() const {
  // @@protoc_insertion_point(field_get:sliverpb.SSHCommandReq.Keytab)
  return _internal_keytab();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SSHCommandReq::set_keytab(ArgT0&& arg0, ArgT... args) {
 
 _impl_.keytab_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SSHCommandReq.Keytab)
}
inline std::string* SSHCommandReq::mutable_keytab() {
  std::string* _s = _internal_mutable_keytab();
  // @@protoc_insertion_point(field_mutable:sliverpb.SSHCommandReq.Keytab)
  return _s;
}
inline const std::string& SSHCommandReq::_internal_keytab() const {
  return _impl_.keytab_.Get();
}
inline void SSHCommandReq::_internal_set_keytab(const std::string& value) {
  
  _impl_.keytab_.Set(value, GetArenaForAllocation());
}
inline std::string* SSHCommandReq::_internal_mutable_keytab() {
  
  return _impl_.keytab_.Mutable(GetArenaForAllocation());
}
inline std::string* SSHCommandReq::release_keytab() {
  // @@protoc_insertion_point(field_release:sliverpb.SSHCommandReq.Keytab)
  return _impl_.keytab_.Release();
}
inline void SSHCommandReq::set_allocated_keytab(std::string* keytab) {
  if (keytab != nullptr) {
    
  } else {
    
  }
  _impl_.keytab_.SetAllocated(keytab, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.keytab_.IsDefault()) {
    _impl_.keytab_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SSHCommandReq.Keytab)
}

// string Realm = 10;
inline void SSHCommandReq::clear_realm() {
  _impl_.realm_.ClearToEmpty();
}
inline const std::string& SSHCommandReq::realm() const {
  // @@protoc_insertion_point(field_get:sliverpb.SSHCommandReq.Realm)
  return _internal_realm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SSHCommandReq::set_realm(ArgT0&& arg0, ArgT... args) {
 
 _impl_.realm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SSHCommandReq.Realm)
}
inline std::string* SSHCommandReq::mutable_realm() {
  std::string* _s = _internal_mutable_realm();
  // @@protoc_insertion_point(field_mutable:sliverpb.SSHCommandReq.Realm)
  return _s;
}
inline const std::string& SSHCommandReq::_internal_realm() const {
  return _impl_.realm_.Get();
}
inline void SSHCommandReq::_internal_set_realm(const std::string& value) {
  
  _impl_.realm_.Set(value, GetArenaForAllocation());
}
inline std::string* SSHCommandReq::_internal_mutable_realm() {
  
  return _impl_.realm_.Mutable(GetArenaForAllocation());
}
inline std::string* SSHCommandReq::release_realm() {
  // @@protoc_insertion_point(field_release:sliverpb.SSHCommandReq.Realm)
  return _impl_.realm_.Release();
}
inline void SSHCommandReq::set_allocated_realm(std::string* realm) {
  if (realm != nullptr) {
    
  } else {
    
  }
  _impl_.realm_.SetAllocated(realm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.realm_.IsDefault()) {
    _impl_.realm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SSHCommandReq.Realm)
}

// .sliverpb.Request Request = 9;
inline bool SSHCommandReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool SSHCommandReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& SSHCommandReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& SSHCommandReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.SSHCommandReq.Request)
  return _internal_request();
}
inline void SSHCommandReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.SSHCommandReq.Request)
}
inline ::sliverpb::Request* SSHCommandReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* SSHCommandReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.SSHCommandReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* SSHCommandReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* SSHCommandReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.SSHCommandReq.Request)
  return _msg;
}
inline void SSHCommandReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SSHCommandReq.Request)
}

// -------------------------------------------------------------------

// SSHCommand

// string stdout_pb = 1;
inline void SSHCommand::clear_stdout_pb() {
  _impl_.stdout_pb_.ClearToEmpty();
}
inline const std::string& SSHCommand::stdout_pb() const {
  // @@protoc_insertion_point(field_get:sliverpb.SSHCommand.stdout_pb)
  return _internal_stdout_pb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SSHCommand::set_stdout_pb(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stdout_pb_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SSHCommand.stdout_pb)
}
inline std::string* SSHCommand::mutable_stdout_pb() {
  std::string* _s = _internal_mutable_stdout_pb();
  // @@protoc_insertion_point(field_mutable:sliverpb.SSHCommand.stdout_pb)
  return _s;
}
inline const std::string& SSHCommand::_internal_stdout_pb() const {
  return _impl_.stdout_pb_.Get();
}
inline void SSHCommand::_internal_set_stdout_pb(const std::string& value) {
  
  _impl_.stdout_pb_.Set(value, GetArenaForAllocation());
}
inline std::string* SSHCommand::_internal_mutable_stdout_pb() {
  
  return _impl_.stdout_pb_.Mutable(GetArenaForAllocation());
}
inline std::string* SSHCommand::release_stdout_pb() {
  // @@protoc_insertion_point(field_release:sliverpb.SSHCommand.stdout_pb)
  return _impl_.stdout_pb_.Release();
}
inline void SSHCommand::set_allocated_stdout_pb(std::string* stdout_pb) {
  if (stdout_pb != nullptr) {
    
  } else {
    
  }
  _impl_.stdout_pb_.SetAllocated(stdout_pb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stdout_pb_.IsDefault()) {
    _impl_.stdout_pb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SSHCommand.stdout_pb)
}

// string stderr_pb = 2;
inline void SSHCommand::clear_stderr_pb() {
  _impl_.stderr_pb_.ClearToEmpty();
}
inline const std::string& SSHCommand::stderr_pb() const {
  // @@protoc_insertion_point(field_get:sliverpb.SSHCommand.stderr_pb)
  return _internal_stderr_pb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SSHCommand::set_stderr_pb(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stderr_pb_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.SSHCommand.stderr_pb)
}
inline std::string* SSHCommand::mutable_stderr_pb() {
  std::string* _s = _internal_mutable_stderr_pb();
  // @@protoc_insertion_point(field_mutable:sliverpb.SSHCommand.stderr_pb)
  return _s;
}
inline const std::string& SSHCommand::_internal_stderr_pb() const {
  return _impl_.stderr_pb_.Get();
}
inline void SSHCommand::_internal_set_stderr_pb(const std::string& value) {
  
  _impl_.stderr_pb_.Set(value, GetArenaForAllocation());
}
inline std::string* SSHCommand::_internal_mutable_stderr_pb() {
  
  return _impl_.stderr_pb_.Mutable(GetArenaForAllocation());
}
inline std::string* SSHCommand::release_stderr_pb() {
  // @@protoc_insertion_point(field_release:sliverpb.SSHCommand.stderr_pb)
  return _impl_.stderr_pb_.Release();
}
inline void SSHCommand::set_allocated_stderr_pb(std::string* stderr_pb) {
  if (stderr_pb != nullptr) {
    
  } else {
    
  }
  _impl_.stderr_pb_.SetAllocated(stderr_pb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stderr_pb_.IsDefault()) {
    _impl_.stderr_pb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SSHCommand.stderr_pb)
}

// .sliverpb.Response Response = 9;
inline bool SSHCommand::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool SSHCommand::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& SSHCommand::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& SSHCommand::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.SSHCommand.Response)
  return _internal_response();
}
inline void SSHCommand::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.SSHCommand.Response)
}
inline ::sliverpb::Response* SSHCommand::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* SSHCommand::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.SSHCommand.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* SSHCommand::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* SSHCommand::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.SSHCommand.Response)
  return _msg;
}
inline void SSHCommand::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.SSHCommand.Response)
}

// -------------------------------------------------------------------

// GetPrivsReq

// .sliverpb.Request Request = 9;
inline bool GetPrivsReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool GetPrivsReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& GetPrivsReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& GetPrivsReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.GetPrivsReq.Request)
  return _internal_request();
}
inline void GetPrivsReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.GetPrivsReq.Request)
}
inline ::sliverpb::Request* GetPrivsReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* GetPrivsReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.GetPrivsReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* GetPrivsReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* GetPrivsReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.GetPrivsReq.Request)
  return _msg;
}
inline void GetPrivsReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.GetPrivsReq.Request)
}

// -------------------------------------------------------------------

// WindowsPrivilegeEntry

// string Name = 1;
inline void WindowsPrivilegeEntry::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& WindowsPrivilegeEntry::name() const {
  // @@protoc_insertion_point(field_get:sliverpb.WindowsPrivilegeEntry.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WindowsPrivilegeEntry::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.WindowsPrivilegeEntry.Name)
}
inline std::string* WindowsPrivilegeEntry::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sliverpb.WindowsPrivilegeEntry.Name)
  return _s;
}
inline const std::string& WindowsPrivilegeEntry::_internal_name() const {
  return _impl_.name_.Get();
}
inline void WindowsPrivilegeEntry::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* WindowsPrivilegeEntry::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* WindowsPrivilegeEntry::release_name() {
  // @@protoc_insertion_point(field_release:sliverpb.WindowsPrivilegeEntry.Name)
  return _impl_.name_.Release();
}
inline void WindowsPrivilegeEntry::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WindowsPrivilegeEntry.Name)
}

// string Description = 2;
inline void WindowsPrivilegeEntry::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& WindowsPrivilegeEntry::description() const {
  // @@protoc_insertion_point(field_get:sliverpb.WindowsPrivilegeEntry.Description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WindowsPrivilegeEntry::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.WindowsPrivilegeEntry.Description)
}
inline std::string* WindowsPrivilegeEntry::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:sliverpb.WindowsPrivilegeEntry.Description)
  return _s;
}
inline const std::string& WindowsPrivilegeEntry::_internal_description() const {
  return _impl_.description_.Get();
}
inline void WindowsPrivilegeEntry::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* WindowsPrivilegeEntry::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* WindowsPrivilegeEntry::release_description() {
  // @@protoc_insertion_point(field_release:sliverpb.WindowsPrivilegeEntry.Description)
  return _impl_.description_.Release();
}
inline void WindowsPrivilegeEntry::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.WindowsPrivilegeEntry.Description)
}

// bool Enabled = 3;
inline void WindowsPrivilegeEntry::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool WindowsPrivilegeEntry::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool WindowsPrivilegeEntry::enabled() const {
  // @@protoc_insertion_point(field_get:sliverpb.WindowsPrivilegeEntry.Enabled)
  return _internal_enabled();
}
inline void WindowsPrivilegeEntry::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void WindowsPrivilegeEntry::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:sliverpb.WindowsPrivilegeEntry.Enabled)
}

// bool EnabledByDefault = 4;
inline void WindowsPrivilegeEntry::clear_enabledbydefault() {
  _impl_.enabledbydefault_ = false;
}
inline bool WindowsPrivilegeEntry::_internal_enabledbydefault() const {
  return _impl_.enabledbydefault_;
}
inline bool WindowsPrivilegeEntry::enabledbydefault() const {
  // @@protoc_insertion_point(field_get:sliverpb.WindowsPrivilegeEntry.EnabledByDefault)
  return _internal_enabledbydefault();
}
inline void WindowsPrivilegeEntry::_internal_set_enabledbydefault(bool value) {
  
  _impl_.enabledbydefault_ = value;
}
inline void WindowsPrivilegeEntry::set_enabledbydefault(bool value) {
  _internal_set_enabledbydefault(value);
  // @@protoc_insertion_point(field_set:sliverpb.WindowsPrivilegeEntry.EnabledByDefault)
}

// bool Removed = 5;
inline void WindowsPrivilegeEntry::clear_removed() {
  _impl_.removed_ = false;
}
inline bool WindowsPrivilegeEntry::_internal_removed() const {
  return _impl_.removed_;
}
inline bool WindowsPrivilegeEntry::removed() const {
  // @@protoc_insertion_point(field_get:sliverpb.WindowsPrivilegeEntry.Removed)
  return _internal_removed();
}
inline void WindowsPrivilegeEntry::_internal_set_removed(bool value) {
  
  _impl_.removed_ = value;
}
inline void WindowsPrivilegeEntry::set_removed(bool value) {
  _internal_set_removed(value);
  // @@protoc_insertion_point(field_set:sliverpb.WindowsPrivilegeEntry.Removed)
}

// bool UsedForAccess = 6;
inline void WindowsPrivilegeEntry::clear_usedforaccess() {
  _impl_.usedforaccess_ = false;
}
inline bool WindowsPrivilegeEntry::_internal_usedforaccess() const {
  return _impl_.usedforaccess_;
}
inline bool WindowsPrivilegeEntry::usedforaccess() const {
  // @@protoc_insertion_point(field_get:sliverpb.WindowsPrivilegeEntry.UsedForAccess)
  return _internal_usedforaccess();
}
inline void WindowsPrivilegeEntry::_internal_set_usedforaccess(bool value) {
  
  _impl_.usedforaccess_ = value;
}
inline void WindowsPrivilegeEntry::set_usedforaccess(bool value) {
  _internal_set_usedforaccess(value);
  // @@protoc_insertion_point(field_set:sliverpb.WindowsPrivilegeEntry.UsedForAccess)
}

// -------------------------------------------------------------------

// GetPrivs

// repeated .sliverpb.WindowsPrivilegeEntry PrivInfo = 1;
inline int GetPrivs::_internal_privinfo_size() const {
  return _impl_.privinfo_.size();
}
inline int GetPrivs::privinfo_size() const {
  return _internal_privinfo_size();
}
inline void GetPrivs::clear_privinfo() {
  _impl_.privinfo_.Clear();
}
inline ::sliverpb::WindowsPrivilegeEntry* GetPrivs::mutable_privinfo(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.GetPrivs.PrivInfo)
  return _impl_.privinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::WindowsPrivilegeEntry >*
GetPrivs::mutable_privinfo() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.GetPrivs.PrivInfo)
  return &_impl_.privinfo_;
}
inline const ::sliverpb::WindowsPrivilegeEntry& GetPrivs::_internal_privinfo(int index) const {
  return _impl_.privinfo_.Get(index);
}
inline const ::sliverpb::WindowsPrivilegeEntry& GetPrivs::privinfo(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.GetPrivs.PrivInfo)
  return _internal_privinfo(index);
}
inline ::sliverpb::WindowsPrivilegeEntry* GetPrivs::_internal_add_privinfo() {
  return _impl_.privinfo_.Add();
}
inline ::sliverpb::WindowsPrivilegeEntry* GetPrivs::add_privinfo() {
  ::sliverpb::WindowsPrivilegeEntry* _add = _internal_add_privinfo();
  // @@protoc_insertion_point(field_add:sliverpb.GetPrivs.PrivInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::WindowsPrivilegeEntry >&
GetPrivs::privinfo() const {
  // @@protoc_insertion_point(field_list:sliverpb.GetPrivs.PrivInfo)
  return _impl_.privinfo_;
}

// string ProcessIntegrity = 2;
inline void GetPrivs::clear_processintegrity() {
  _impl_.processintegrity_.ClearToEmpty();
}
inline const std::string& GetPrivs::processintegrity() const {
  // @@protoc_insertion_point(field_get:sliverpb.GetPrivs.ProcessIntegrity)
  return _internal_processintegrity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPrivs::set_processintegrity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.processintegrity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.GetPrivs.ProcessIntegrity)
}
inline std::string* GetPrivs::mutable_processintegrity() {
  std::string* _s = _internal_mutable_processintegrity();
  // @@protoc_insertion_point(field_mutable:sliverpb.GetPrivs.ProcessIntegrity)
  return _s;
}
inline const std::string& GetPrivs::_internal_processintegrity() const {
  return _impl_.processintegrity_.Get();
}
inline void GetPrivs::_internal_set_processintegrity(const std::string& value) {
  
  _impl_.processintegrity_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPrivs::_internal_mutable_processintegrity() {
  
  return _impl_.processintegrity_.Mutable(GetArenaForAllocation());
}
inline std::string* GetPrivs::release_processintegrity() {
  // @@protoc_insertion_point(field_release:sliverpb.GetPrivs.ProcessIntegrity)
  return _impl_.processintegrity_.Release();
}
inline void GetPrivs::set_allocated_processintegrity(std::string* processintegrity) {
  if (processintegrity != nullptr) {
    
  } else {
    
  }
  _impl_.processintegrity_.SetAllocated(processintegrity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.processintegrity_.IsDefault()) {
    _impl_.processintegrity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.GetPrivs.ProcessIntegrity)
}

// string ProcessName = 3;
inline void GetPrivs::clear_processname() {
  _impl_.processname_.ClearToEmpty();
}
inline const std::string& GetPrivs::processname() const {
  // @@protoc_insertion_point(field_get:sliverpb.GetPrivs.ProcessName)
  return _internal_processname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPrivs::set_processname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.processname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.GetPrivs.ProcessName)
}
inline std::string* GetPrivs::mutable_processname() {
  std::string* _s = _internal_mutable_processname();
  // @@protoc_insertion_point(field_mutable:sliverpb.GetPrivs.ProcessName)
  return _s;
}
inline const std::string& GetPrivs::_internal_processname() const {
  return _impl_.processname_.Get();
}
inline void GetPrivs::_internal_set_processname(const std::string& value) {
  
  _impl_.processname_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPrivs::_internal_mutable_processname() {
  
  return _impl_.processname_.Mutable(GetArenaForAllocation());
}
inline std::string* GetPrivs::release_processname() {
  // @@protoc_insertion_point(field_release:sliverpb.GetPrivs.ProcessName)
  return _impl_.processname_.Release();
}
inline void GetPrivs::set_allocated_processname(std::string* processname) {
  if (processname != nullptr) {
    
  } else {
    
  }
  _impl_.processname_.SetAllocated(processname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.processname_.IsDefault()) {
    _impl_.processname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.GetPrivs.ProcessName)
}

// .sliverpb.Response Response = 9;
inline bool GetPrivs::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool GetPrivs::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& GetPrivs::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& GetPrivs::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.GetPrivs.Response)
  return _internal_response();
}
inline void GetPrivs::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.GetPrivs.Response)
}
inline ::sliverpb::Response* GetPrivs::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* GetPrivs::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.GetPrivs.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* GetPrivs::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* GetPrivs::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.GetPrivs.Response)
  return _msg;
}
inline void GetPrivs::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.GetPrivs.Response)
}

// -------------------------------------------------------------------

// RegisterExtensionReq

// string Name = 1;
inline void RegisterExtensionReq::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RegisterExtensionReq::name() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegisterExtensionReq.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterExtensionReq::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegisterExtensionReq.Name)
}
inline std::string* RegisterExtensionReq::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegisterExtensionReq.Name)
  return _s;
}
inline const std::string& RegisterExtensionReq::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RegisterExtensionReq::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterExtensionReq::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterExtensionReq::release_name() {
  // @@protoc_insertion_point(field_release:sliverpb.RegisterExtensionReq.Name)
  return _impl_.name_.Release();
}
inline void RegisterExtensionReq::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegisterExtensionReq.Name)
}

// bytes Data = 2;
inline void RegisterExtensionReq::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& RegisterExtensionReq::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegisterExtensionReq.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterExtensionReq::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegisterExtensionReq.Data)
}
inline std::string* RegisterExtensionReq::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegisterExtensionReq.Data)
  return _s;
}
inline const std::string& RegisterExtensionReq::_internal_data() const {
  return _impl_.data_.Get();
}
inline void RegisterExtensionReq::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterExtensionReq::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterExtensionReq::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.RegisterExtensionReq.Data)
  return _impl_.data_.Release();
}
inline void RegisterExtensionReq::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegisterExtensionReq.Data)
}

// string OS = 3;
inline void RegisterExtensionReq::clear_os() {
  _impl_.os_.ClearToEmpty();
}
inline const std::string& RegisterExtensionReq::os() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegisterExtensionReq.OS)
  return _internal_os();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterExtensionReq::set_os(ArgT0&& arg0, ArgT... args) {
 
 _impl_.os_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegisterExtensionReq.OS)
}
inline std::string* RegisterExtensionReq::mutable_os() {
  std::string* _s = _internal_mutable_os();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegisterExtensionReq.OS)
  return _s;
}
inline const std::string& RegisterExtensionReq::_internal_os() const {
  return _impl_.os_.Get();
}
inline void RegisterExtensionReq::_internal_set_os(const std::string& value) {
  
  _impl_.os_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterExtensionReq::_internal_mutable_os() {
  
  return _impl_.os_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterExtensionReq::release_os() {
  // @@protoc_insertion_point(field_release:sliverpb.RegisterExtensionReq.OS)
  return _impl_.os_.Release();
}
inline void RegisterExtensionReq::set_allocated_os(std::string* os) {
  if (os != nullptr) {
    
  } else {
    
  }
  _impl_.os_.SetAllocated(os, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_.IsDefault()) {
    _impl_.os_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegisterExtensionReq.OS)
}

// string Init = 4;
inline void RegisterExtensionReq::clear_init() {
  _impl_.init_.ClearToEmpty();
}
inline const std::string& RegisterExtensionReq::init() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegisterExtensionReq.Init)
  return _internal_init();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterExtensionReq::set_init(ArgT0&& arg0, ArgT... args) {
 
 _impl_.init_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RegisterExtensionReq.Init)
}
inline std::string* RegisterExtensionReq::mutable_init() {
  std::string* _s = _internal_mutable_init();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegisterExtensionReq.Init)
  return _s;
}
inline const std::string& RegisterExtensionReq::_internal_init() const {
  return _impl_.init_.Get();
}
inline void RegisterExtensionReq::_internal_set_init(const std::string& value) {
  
  _impl_.init_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterExtensionReq::_internal_mutable_init() {
  
  return _impl_.init_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterExtensionReq::release_init() {
  // @@protoc_insertion_point(field_release:sliverpb.RegisterExtensionReq.Init)
  return _impl_.init_.Release();
}
inline void RegisterExtensionReq::set_allocated_init(std::string* init) {
  if (init != nullptr) {
    
  } else {
    
  }
  _impl_.init_.SetAllocated(init, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.init_.IsDefault()) {
    _impl_.init_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegisterExtensionReq.Init)
}

// .sliverpb.Request Request = 9;
inline bool RegisterExtensionReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool RegisterExtensionReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& RegisterExtensionReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& RegisterExtensionReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegisterExtensionReq.Request)
  return _internal_request();
}
inline void RegisterExtensionReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RegisterExtensionReq.Request)
}
inline ::sliverpb::Request* RegisterExtensionReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* RegisterExtensionReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.RegisterExtensionReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* RegisterExtensionReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* RegisterExtensionReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegisterExtensionReq.Request)
  return _msg;
}
inline void RegisterExtensionReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegisterExtensionReq.Request)
}

// -------------------------------------------------------------------

// RegisterExtension

// .sliverpb.Response Response = 9;
inline bool RegisterExtension::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool RegisterExtension::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& RegisterExtension::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& RegisterExtension::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.RegisterExtension.Response)
  return _internal_response();
}
inline void RegisterExtension::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RegisterExtension.Response)
}
inline ::sliverpb::Response* RegisterExtension::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* RegisterExtension::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.RegisterExtension.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* RegisterExtension::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* RegisterExtension::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.RegisterExtension.Response)
  return _msg;
}
inline void RegisterExtension::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RegisterExtension.Response)
}

// -------------------------------------------------------------------

// CallExtensionReq

// string Name = 1;
inline void CallExtensionReq::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CallExtensionReq::name() const {
  // @@protoc_insertion_point(field_get:sliverpb.CallExtensionReq.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallExtensionReq::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.CallExtensionReq.Name)
}
inline std::string* CallExtensionReq::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sliverpb.CallExtensionReq.Name)
  return _s;
}
inline const std::string& CallExtensionReq::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CallExtensionReq::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CallExtensionReq::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CallExtensionReq::release_name() {
  // @@protoc_insertion_point(field_release:sliverpb.CallExtensionReq.Name)
  return _impl_.name_.Release();
}
inline void CallExtensionReq::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.CallExtensionReq.Name)
}

// bool ServerStore = 2;
inline void CallExtensionReq::clear_serverstore() {
  _impl_.serverstore_ = false;
}
inline bool CallExtensionReq::_internal_serverstore() const {
  return _impl_.serverstore_;
}
inline bool CallExtensionReq::serverstore() const {
  // @@protoc_insertion_point(field_get:sliverpb.CallExtensionReq.ServerStore)
  return _internal_serverstore();
}
inline void CallExtensionReq::_internal_set_serverstore(bool value) {
  
  _impl_.serverstore_ = value;
}
inline void CallExtensionReq::set_serverstore(bool value) {
  _internal_set_serverstore(value);
  // @@protoc_insertion_point(field_set:sliverpb.CallExtensionReq.ServerStore)
}

// bytes Args = 3;
inline void CallExtensionReq::clear_args() {
  _impl_.args_.ClearToEmpty();
}
inline const std::string& CallExtensionReq::args() const {
  // @@protoc_insertion_point(field_get:sliverpb.CallExtensionReq.Args)
  return _internal_args();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallExtensionReq::set_args(ArgT0&& arg0, ArgT... args) {
 
 _impl_.args_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.CallExtensionReq.Args)
}
inline std::string* CallExtensionReq::mutable_args() {
  std::string* _s = _internal_mutable_args();
  // @@protoc_insertion_point(field_mutable:sliverpb.CallExtensionReq.Args)
  return _s;
}
inline const std::string& CallExtensionReq::_internal_args() const {
  return _impl_.args_.Get();
}
inline void CallExtensionReq::_internal_set_args(const std::string& value) {
  
  _impl_.args_.Set(value, GetArenaForAllocation());
}
inline std::string* CallExtensionReq::_internal_mutable_args() {
  
  return _impl_.args_.Mutable(GetArenaForAllocation());
}
inline std::string* CallExtensionReq::release_args() {
  // @@protoc_insertion_point(field_release:sliverpb.CallExtensionReq.Args)
  return _impl_.args_.Release();
}
inline void CallExtensionReq::set_allocated_args(std::string* args) {
  if (args != nullptr) {
    
  } else {
    
  }
  _impl_.args_.SetAllocated(args, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.args_.IsDefault()) {
    _impl_.args_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.CallExtensionReq.Args)
}

// string Export = 4;
inline void CallExtensionReq::clear_export_() {
  _impl_.export__.ClearToEmpty();
}
inline const std::string& CallExtensionReq::export_() const {
  // @@protoc_insertion_point(field_get:sliverpb.CallExtensionReq.Export)
  return _internal_export_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallExtensionReq::set_export_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.export__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.CallExtensionReq.Export)
}
inline std::string* CallExtensionReq::mutable_export_() {
  std::string* _s = _internal_mutable_export_();
  // @@protoc_insertion_point(field_mutable:sliverpb.CallExtensionReq.Export)
  return _s;
}
inline const std::string& CallExtensionReq::_internal_export_() const {
  return _impl_.export__.Get();
}
inline void CallExtensionReq::_internal_set_export_(const std::string& value) {
  
  _impl_.export__.Set(value, GetArenaForAllocation());
}
inline std::string* CallExtensionReq::_internal_mutable_export_() {
  
  return _impl_.export__.Mutable(GetArenaForAllocation());
}
inline std::string* CallExtensionReq::release_export_() {
  // @@protoc_insertion_point(field_release:sliverpb.CallExtensionReq.Export)
  return _impl_.export__.Release();
}
inline void CallExtensionReq::set_allocated_export_(std::string* export_) {
  if (export_ != nullptr) {
    
  } else {
    
  }
  _impl_.export__.SetAllocated(export_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.export__.IsDefault()) {
    _impl_.export__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.CallExtensionReq.Export)
}

// .sliverpb.Request Request = 9;
inline bool CallExtensionReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool CallExtensionReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& CallExtensionReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& CallExtensionReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.CallExtensionReq.Request)
  return _internal_request();
}
inline void CallExtensionReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.CallExtensionReq.Request)
}
inline ::sliverpb::Request* CallExtensionReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* CallExtensionReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.CallExtensionReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* CallExtensionReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* CallExtensionReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.CallExtensionReq.Request)
  return _msg;
}
inline void CallExtensionReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.CallExtensionReq.Request)
}

// -------------------------------------------------------------------

// CallExtension

// bytes Output = 1;
inline void CallExtension::clear_output() {
  _impl_.output_.ClearToEmpty();
}
inline const std::string& CallExtension::output() const {
  // @@protoc_insertion_point(field_get:sliverpb.CallExtension.Output)
  return _internal_output();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallExtension::set_output(ArgT0&& arg0, ArgT... args) {
 
 _impl_.output_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.CallExtension.Output)
}
inline std::string* CallExtension::mutable_output() {
  std::string* _s = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:sliverpb.CallExtension.Output)
  return _s;
}
inline const std::string& CallExtension::_internal_output() const {
  return _impl_.output_.Get();
}
inline void CallExtension::_internal_set_output(const std::string& value) {
  
  _impl_.output_.Set(value, GetArenaForAllocation());
}
inline std::string* CallExtension::_internal_mutable_output() {
  
  return _impl_.output_.Mutable(GetArenaForAllocation());
}
inline std::string* CallExtension::release_output() {
  // @@protoc_insertion_point(field_release:sliverpb.CallExtension.Output)
  return _impl_.output_.Release();
}
inline void CallExtension::set_allocated_output(std::string* output) {
  if (output != nullptr) {
    
  } else {
    
  }
  _impl_.output_.SetAllocated(output, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.output_.IsDefault()) {
    _impl_.output_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.CallExtension.Output)
}

// bool ServerStore = 2;
inline void CallExtension::clear_serverstore() {
  _impl_.serverstore_ = false;
}
inline bool CallExtension::_internal_serverstore() const {
  return _impl_.serverstore_;
}
inline bool CallExtension::serverstore() const {
  // @@protoc_insertion_point(field_get:sliverpb.CallExtension.ServerStore)
  return _internal_serverstore();
}
inline void CallExtension::_internal_set_serverstore(bool value) {
  
  _impl_.serverstore_ = value;
}
inline void CallExtension::set_serverstore(bool value) {
  _internal_set_serverstore(value);
  // @@protoc_insertion_point(field_set:sliverpb.CallExtension.ServerStore)
}

// .sliverpb.Response Response = 9;
inline bool CallExtension::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool CallExtension::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& CallExtension::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& CallExtension::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.CallExtension.Response)
  return _internal_response();
}
inline void CallExtension::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.CallExtension.Response)
}
inline ::sliverpb::Response* CallExtension::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* CallExtension::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.CallExtension.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* CallExtension::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* CallExtension::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.CallExtension.Response)
  return _msg;
}
inline void CallExtension::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.CallExtension.Response)
}

// -------------------------------------------------------------------

// ListExtensionsReq

// .sliverpb.Request Request = 9;
inline bool ListExtensionsReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool ListExtensionsReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& ListExtensionsReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& ListExtensionsReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.ListExtensionsReq.Request)
  return _internal_request();
}
inline void ListExtensionsReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.ListExtensionsReq.Request)
}
inline ::sliverpb::Request* ListExtensionsReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* ListExtensionsReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.ListExtensionsReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* ListExtensionsReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* ListExtensionsReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.ListExtensionsReq.Request)
  return _msg;
}
inline void ListExtensionsReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ListExtensionsReq.Request)
}

// -------------------------------------------------------------------

// ListExtensions

// repeated string Names = 1;
inline int ListExtensions::_internal_names_size() const {
  return _impl_.names_.size();
}
inline int ListExtensions::names_size() const {
  return _internal_names_size();
}
inline void ListExtensions::clear_names() {
  _impl_.names_.Clear();
}
inline std::string* ListExtensions::add_names() {
  std::string* _s = _internal_add_names();
  // @@protoc_insertion_point(field_add_mutable:sliverpb.ListExtensions.Names)
  return _s;
}
inline const std::string& ListExtensions::_internal_names(int index) const {
  return _impl_.names_.Get(index);
}
inline const std::string& ListExtensions::names(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.ListExtensions.Names)
  return _internal_names(index);
}
inline std::string* ListExtensions::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.ListExtensions.Names)
  return _impl_.names_.Mutable(index);
}
inline void ListExtensions::set_names(int index, const std::string& value) {
  _impl_.names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sliverpb.ListExtensions.Names)
}
inline void ListExtensions::set_names(int index, std::string&& value) {
  _impl_.names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sliverpb.ListExtensions.Names)
}
inline void ListExtensions::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sliverpb.ListExtensions.Names)
}
inline void ListExtensions::set_names(int index, const char* value, size_t size) {
  _impl_.names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sliverpb.ListExtensions.Names)
}
inline std::string* ListExtensions::_internal_add_names() {
  return _impl_.names_.Add();
}
inline void ListExtensions::add_names(const std::string& value) {
  _impl_.names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sliverpb.ListExtensions.Names)
}
inline void ListExtensions::add_names(std::string&& value) {
  _impl_.names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sliverpb.ListExtensions.Names)
}
inline void ListExtensions::add_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sliverpb.ListExtensions.Names)
}
inline void ListExtensions::add_names(const char* value, size_t size) {
  _impl_.names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sliverpb.ListExtensions.Names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListExtensions::names() const {
  // @@protoc_insertion_point(field_list:sliverpb.ListExtensions.Names)
  return _impl_.names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListExtensions::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.ListExtensions.Names)
  return &_impl_.names_;
}

// .sliverpb.Response Response = 9;
inline bool ListExtensions::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool ListExtensions::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& ListExtensions::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& ListExtensions::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.ListExtensions.Response)
  return _internal_response();
}
inline void ListExtensions::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.ListExtensions.Response)
}
inline ::sliverpb::Response* ListExtensions::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* ListExtensions::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.ListExtensions.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* ListExtensions::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* ListExtensions::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.ListExtensions.Response)
  return _msg;
}
inline void ListExtensions::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.ListExtensions.Response)
}

// -------------------------------------------------------------------

// RportFwdStopListenerReq

// uint32 ID = 1;
inline void RportFwdStopListenerReq::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t RportFwdStopListenerReq::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t RportFwdStopListenerReq::id() const {
  // @@protoc_insertion_point(field_get:sliverpb.RportFwdStopListenerReq.ID)
  return _internal_id();
}
inline void RportFwdStopListenerReq::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void RportFwdStopListenerReq::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sliverpb.RportFwdStopListenerReq.ID)
}

// .sliverpb.Request Request = 9;
inline bool RportFwdStopListenerReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool RportFwdStopListenerReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& RportFwdStopListenerReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& RportFwdStopListenerReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.RportFwdStopListenerReq.Request)
  return _internal_request();
}
inline void RportFwdStopListenerReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RportFwdStopListenerReq.Request)
}
inline ::sliverpb::Request* RportFwdStopListenerReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* RportFwdStopListenerReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.RportFwdStopListenerReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* RportFwdStopListenerReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* RportFwdStopListenerReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.RportFwdStopListenerReq.Request)
  return _msg;
}
inline void RportFwdStopListenerReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RportFwdStopListenerReq.Request)
}

// -------------------------------------------------------------------

// RportFwdStartListenerReq

// string BindAddress = 1;
inline void RportFwdStartListenerReq::clear_bindaddress() {
  _impl_.bindaddress_.ClearToEmpty();
}
inline const std::string& RportFwdStartListenerReq::bindaddress() const {
  // @@protoc_insertion_point(field_get:sliverpb.RportFwdStartListenerReq.BindAddress)
  return _internal_bindaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RportFwdStartListenerReq::set_bindaddress(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bindaddress_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RportFwdStartListenerReq.BindAddress)
}
inline std::string* RportFwdStartListenerReq::mutable_bindaddress() {
  std::string* _s = _internal_mutable_bindaddress();
  // @@protoc_insertion_point(field_mutable:sliverpb.RportFwdStartListenerReq.BindAddress)
  return _s;
}
inline const std::string& RportFwdStartListenerReq::_internal_bindaddress() const {
  return _impl_.bindaddress_.Get();
}
inline void RportFwdStartListenerReq::_internal_set_bindaddress(const std::string& value) {
  
  _impl_.bindaddress_.Set(value, GetArenaForAllocation());
}
inline std::string* RportFwdStartListenerReq::_internal_mutable_bindaddress() {
  
  return _impl_.bindaddress_.Mutable(GetArenaForAllocation());
}
inline std::string* RportFwdStartListenerReq::release_bindaddress() {
  // @@protoc_insertion_point(field_release:sliverpb.RportFwdStartListenerReq.BindAddress)
  return _impl_.bindaddress_.Release();
}
inline void RportFwdStartListenerReq::set_allocated_bindaddress(std::string* bindaddress) {
  if (bindaddress != nullptr) {
    
  } else {
    
  }
  _impl_.bindaddress_.SetAllocated(bindaddress, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bindaddress_.IsDefault()) {
    _impl_.bindaddress_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RportFwdStartListenerReq.BindAddress)
}

// uint32 BindPort = 2;
inline void RportFwdStartListenerReq::clear_bindport() {
  _impl_.bindport_ = 0u;
}
inline uint32_t RportFwdStartListenerReq::_internal_bindport() const {
  return _impl_.bindport_;
}
inline uint32_t RportFwdStartListenerReq::bindport() const {
  // @@protoc_insertion_point(field_get:sliverpb.RportFwdStartListenerReq.BindPort)
  return _internal_bindport();
}
inline void RportFwdStartListenerReq::_internal_set_bindport(uint32_t value) {
  
  _impl_.bindport_ = value;
}
inline void RportFwdStartListenerReq::set_bindport(uint32_t value) {
  _internal_set_bindport(value);
  // @@protoc_insertion_point(field_set:sliverpb.RportFwdStartListenerReq.BindPort)
}

// uint32 forwardPort = 3;
inline void RportFwdStartListenerReq::clear_forwardport() {
  _impl_.forwardport_ = 0u;
}
inline uint32_t RportFwdStartListenerReq::_internal_forwardport() const {
  return _impl_.forwardport_;
}
inline uint32_t RportFwdStartListenerReq::forwardport() const {
  // @@protoc_insertion_point(field_get:sliverpb.RportFwdStartListenerReq.forwardPort)
  return _internal_forwardport();
}
inline void RportFwdStartListenerReq::_internal_set_forwardport(uint32_t value) {
  
  _impl_.forwardport_ = value;
}
inline void RportFwdStartListenerReq::set_forwardport(uint32_t value) {
  _internal_set_forwardport(value);
  // @@protoc_insertion_point(field_set:sliverpb.RportFwdStartListenerReq.forwardPort)
}

// string forwardAddress = 4;
inline void RportFwdStartListenerReq::clear_forwardaddress() {
  _impl_.forwardaddress_.ClearToEmpty();
}
inline const std::string& RportFwdStartListenerReq::forwardaddress() const {
  // @@protoc_insertion_point(field_get:sliverpb.RportFwdStartListenerReq.forwardAddress)
  return _internal_forwardaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RportFwdStartListenerReq::set_forwardaddress(ArgT0&& arg0, ArgT... args) {
 
 _impl_.forwardaddress_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RportFwdStartListenerReq.forwardAddress)
}
inline std::string* RportFwdStartListenerReq::mutable_forwardaddress() {
  std::string* _s = _internal_mutable_forwardaddress();
  // @@protoc_insertion_point(field_mutable:sliverpb.RportFwdStartListenerReq.forwardAddress)
  return _s;
}
inline const std::string& RportFwdStartListenerReq::_internal_forwardaddress() const {
  return _impl_.forwardaddress_.Get();
}
inline void RportFwdStartListenerReq::_internal_set_forwardaddress(const std::string& value) {
  
  _impl_.forwardaddress_.Set(value, GetArenaForAllocation());
}
inline std::string* RportFwdStartListenerReq::_internal_mutable_forwardaddress() {
  
  return _impl_.forwardaddress_.Mutable(GetArenaForAllocation());
}
inline std::string* RportFwdStartListenerReq::release_forwardaddress() {
  // @@protoc_insertion_point(field_release:sliverpb.RportFwdStartListenerReq.forwardAddress)
  return _impl_.forwardaddress_.Release();
}
inline void RportFwdStartListenerReq::set_allocated_forwardaddress(std::string* forwardaddress) {
  if (forwardaddress != nullptr) {
    
  } else {
    
  }
  _impl_.forwardaddress_.SetAllocated(forwardaddress, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.forwardaddress_.IsDefault()) {
    _impl_.forwardaddress_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RportFwdStartListenerReq.forwardAddress)
}

// .sliverpb.Request Request = 9;
inline bool RportFwdStartListenerReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool RportFwdStartListenerReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& RportFwdStartListenerReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& RportFwdStartListenerReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.RportFwdStartListenerReq.Request)
  return _internal_request();
}
inline void RportFwdStartListenerReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RportFwdStartListenerReq.Request)
}
inline ::sliverpb::Request* RportFwdStartListenerReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* RportFwdStartListenerReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.RportFwdStartListenerReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* RportFwdStartListenerReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* RportFwdStartListenerReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.RportFwdStartListenerReq.Request)
  return _msg;
}
inline void RportFwdStartListenerReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RportFwdStartListenerReq.Request)
}

// -------------------------------------------------------------------

// RportFwdListener

// uint32 ID = 1;
inline void RportFwdListener::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t RportFwdListener::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t RportFwdListener::id() const {
  // @@protoc_insertion_point(field_get:sliverpb.RportFwdListener.ID)
  return _internal_id();
}
inline void RportFwdListener::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void RportFwdListener::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sliverpb.RportFwdListener.ID)
}

// string BindAddress = 2;
inline void RportFwdListener::clear_bindaddress() {
  _impl_.bindaddress_.ClearToEmpty();
}
inline const std::string& RportFwdListener::bindaddress() const {
  // @@protoc_insertion_point(field_get:sliverpb.RportFwdListener.BindAddress)
  return _internal_bindaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RportFwdListener::set_bindaddress(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bindaddress_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RportFwdListener.BindAddress)
}
inline std::string* RportFwdListener::mutable_bindaddress() {
  std::string* _s = _internal_mutable_bindaddress();
  // @@protoc_insertion_point(field_mutable:sliverpb.RportFwdListener.BindAddress)
  return _s;
}
inline const std::string& RportFwdListener::_internal_bindaddress() const {
  return _impl_.bindaddress_.Get();
}
inline void RportFwdListener::_internal_set_bindaddress(const std::string& value) {
  
  _impl_.bindaddress_.Set(value, GetArenaForAllocation());
}
inline std::string* RportFwdListener::_internal_mutable_bindaddress() {
  
  return _impl_.bindaddress_.Mutable(GetArenaForAllocation());
}
inline std::string* RportFwdListener::release_bindaddress() {
  // @@protoc_insertion_point(field_release:sliverpb.RportFwdListener.BindAddress)
  return _impl_.bindaddress_.Release();
}
inline void RportFwdListener::set_allocated_bindaddress(std::string* bindaddress) {
  if (bindaddress != nullptr) {
    
  } else {
    
  }
  _impl_.bindaddress_.SetAllocated(bindaddress, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bindaddress_.IsDefault()) {
    _impl_.bindaddress_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RportFwdListener.BindAddress)
}

// uint32 bindPort = 3;
inline void RportFwdListener::clear_bindport() {
  _impl_.bindport_ = 0u;
}
inline uint32_t RportFwdListener::_internal_bindport() const {
  return _impl_.bindport_;
}
inline uint32_t RportFwdListener::bindport() const {
  // @@protoc_insertion_point(field_get:sliverpb.RportFwdListener.bindPort)
  return _internal_bindport();
}
inline void RportFwdListener::_internal_set_bindport(uint32_t value) {
  
  _impl_.bindport_ = value;
}
inline void RportFwdListener::set_bindport(uint32_t value) {
  _internal_set_bindport(value);
  // @@protoc_insertion_point(field_set:sliverpb.RportFwdListener.bindPort)
}

// string forwardAddress = 4;
inline void RportFwdListener::clear_forwardaddress() {
  _impl_.forwardaddress_.ClearToEmpty();
}
inline const std::string& RportFwdListener::forwardaddress() const {
  // @@protoc_insertion_point(field_get:sliverpb.RportFwdListener.forwardAddress)
  return _internal_forwardaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RportFwdListener::set_forwardaddress(ArgT0&& arg0, ArgT... args) {
 
 _impl_.forwardaddress_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RportFwdListener.forwardAddress)
}
inline std::string* RportFwdListener::mutable_forwardaddress() {
  std::string* _s = _internal_mutable_forwardaddress();
  // @@protoc_insertion_point(field_mutable:sliverpb.RportFwdListener.forwardAddress)
  return _s;
}
inline const std::string& RportFwdListener::_internal_forwardaddress() const {
  return _impl_.forwardaddress_.Get();
}
inline void RportFwdListener::_internal_set_forwardaddress(const std::string& value) {
  
  _impl_.forwardaddress_.Set(value, GetArenaForAllocation());
}
inline std::string* RportFwdListener::_internal_mutable_forwardaddress() {
  
  return _impl_.forwardaddress_.Mutable(GetArenaForAllocation());
}
inline std::string* RportFwdListener::release_forwardaddress() {
  // @@protoc_insertion_point(field_release:sliverpb.RportFwdListener.forwardAddress)
  return _impl_.forwardaddress_.Release();
}
inline void RportFwdListener::set_allocated_forwardaddress(std::string* forwardaddress) {
  if (forwardaddress != nullptr) {
    
  } else {
    
  }
  _impl_.forwardaddress_.SetAllocated(forwardaddress, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.forwardaddress_.IsDefault()) {
    _impl_.forwardaddress_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RportFwdListener.forwardAddress)
}

// uint32 forwardPort = 5;
inline void RportFwdListener::clear_forwardport() {
  _impl_.forwardport_ = 0u;
}
inline uint32_t RportFwdListener::_internal_forwardport() const {
  return _impl_.forwardport_;
}
inline uint32_t RportFwdListener::forwardport() const {
  // @@protoc_insertion_point(field_get:sliverpb.RportFwdListener.forwardPort)
  return _internal_forwardport();
}
inline void RportFwdListener::_internal_set_forwardport(uint32_t value) {
  
  _impl_.forwardport_ = value;
}
inline void RportFwdListener::set_forwardport(uint32_t value) {
  _internal_set_forwardport(value);
  // @@protoc_insertion_point(field_set:sliverpb.RportFwdListener.forwardPort)
}

// .sliverpb.Response Response = 9;
inline bool RportFwdListener::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool RportFwdListener::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& RportFwdListener::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& RportFwdListener::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.RportFwdListener.Response)
  return _internal_response();
}
inline void RportFwdListener::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RportFwdListener.Response)
}
inline ::sliverpb::Response* RportFwdListener::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* RportFwdListener::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.RportFwdListener.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* RportFwdListener::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* RportFwdListener::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.RportFwdListener.Response)
  return _msg;
}
inline void RportFwdListener::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RportFwdListener.Response)
}

// -------------------------------------------------------------------

// RportFwdListeners

// repeated .sliverpb.RportFwdListener Listeners = 1;
inline int RportFwdListeners::_internal_listeners_size() const {
  return _impl_.listeners_.size();
}
inline int RportFwdListeners::listeners_size() const {
  return _internal_listeners_size();
}
inline void RportFwdListeners::clear_listeners() {
  _impl_.listeners_.Clear();
}
inline ::sliverpb::RportFwdListener* RportFwdListeners::mutable_listeners(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.RportFwdListeners.Listeners)
  return _impl_.listeners_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::RportFwdListener >*
RportFwdListeners::mutable_listeners() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.RportFwdListeners.Listeners)
  return &_impl_.listeners_;
}
inline const ::sliverpb::RportFwdListener& RportFwdListeners::_internal_listeners(int index) const {
  return _impl_.listeners_.Get(index);
}
inline const ::sliverpb::RportFwdListener& RportFwdListeners::listeners(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.RportFwdListeners.Listeners)
  return _internal_listeners(index);
}
inline ::sliverpb::RportFwdListener* RportFwdListeners::_internal_add_listeners() {
  return _impl_.listeners_.Add();
}
inline ::sliverpb::RportFwdListener* RportFwdListeners::add_listeners() {
  ::sliverpb::RportFwdListener* _add = _internal_add_listeners();
  // @@protoc_insertion_point(field_add:sliverpb.RportFwdListeners.Listeners)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sliverpb::RportFwdListener >&
RportFwdListeners::listeners() const {
  // @@protoc_insertion_point(field_list:sliverpb.RportFwdListeners.Listeners)
  return _impl_.listeners_;
}

// .sliverpb.Response Response = 9;
inline bool RportFwdListeners::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool RportFwdListeners::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& RportFwdListeners::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& RportFwdListeners::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.RportFwdListeners.Response)
  return _internal_response();
}
inline void RportFwdListeners::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RportFwdListeners.Response)
}
inline ::sliverpb::Response* RportFwdListeners::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* RportFwdListeners::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.RportFwdListeners.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* RportFwdListeners::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* RportFwdListeners::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.RportFwdListeners.Response)
  return _msg;
}
inline void RportFwdListeners::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RportFwdListeners.Response)
}

// -------------------------------------------------------------------

// RportFwdListenersReq

// .sliverpb.Request Request = 9;
inline bool RportFwdListenersReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool RportFwdListenersReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& RportFwdListenersReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& RportFwdListenersReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.RportFwdListenersReq.Request)
  return _internal_request();
}
inline void RportFwdListenersReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RportFwdListenersReq.Request)
}
inline ::sliverpb::Request* RportFwdListenersReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* RportFwdListenersReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.RportFwdListenersReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* RportFwdListenersReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* RportFwdListenersReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.RportFwdListenersReq.Request)
  return _msg;
}
inline void RportFwdListenersReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RportFwdListenersReq.Request)
}

// -------------------------------------------------------------------

// RPortfwd

// uint32 Port = 1;
inline void RPortfwd::clear_port() {
  _impl_.port_ = 0u;
}
inline uint32_t RPortfwd::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t RPortfwd::port() const {
  // @@protoc_insertion_point(field_get:sliverpb.RPortfwd.Port)
  return _internal_port();
}
inline void RPortfwd::_internal_set_port(uint32_t value) {
  
  _impl_.port_ = value;
}
inline void RPortfwd::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:sliverpb.RPortfwd.Port)
}

// int32 Protocol = 2;
inline void RPortfwd::clear_protocol() {
  _impl_.protocol_ = 0;
}
inline int32_t RPortfwd::_internal_protocol() const {
  return _impl_.protocol_;
}
inline int32_t RPortfwd::protocol() const {
  // @@protoc_insertion_point(field_get:sliverpb.RPortfwd.Protocol)
  return _internal_protocol();
}
inline void RPortfwd::_internal_set_protocol(int32_t value) {
  
  _impl_.protocol_ = value;
}
inline void RPortfwd::set_protocol(int32_t value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:sliverpb.RPortfwd.Protocol)
}

// string Host = 3;
inline void RPortfwd::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& RPortfwd::host() const {
  // @@protoc_insertion_point(field_get:sliverpb.RPortfwd.Host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RPortfwd::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RPortfwd.Host)
}
inline std::string* RPortfwd::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:sliverpb.RPortfwd.Host)
  return _s;
}
inline const std::string& RPortfwd::_internal_host() const {
  return _impl_.host_.Get();
}
inline void RPortfwd::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* RPortfwd::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* RPortfwd::release_host() {
  // @@protoc_insertion_point(field_release:sliverpb.RPortfwd.Host)
  return _impl_.host_.Release();
}
inline void RPortfwd::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RPortfwd.Host)
}

// uint64 TunnelID = 8 [jstype = JS_STRING];
inline void RPortfwd::clear_tunnelid() {
  _impl_.tunnelid_ = uint64_t{0u};
}
inline uint64_t RPortfwd::_internal_tunnelid() const {
  return _impl_.tunnelid_;
}
inline uint64_t RPortfwd::tunnelid() const {
  // @@protoc_insertion_point(field_get:sliverpb.RPortfwd.TunnelID)
  return _internal_tunnelid();
}
inline void RPortfwd::_internal_set_tunnelid(uint64_t value) {
  
  _impl_.tunnelid_ = value;
}
inline void RPortfwd::set_tunnelid(uint64_t value) {
  _internal_set_tunnelid(value);
  // @@protoc_insertion_point(field_set:sliverpb.RPortfwd.TunnelID)
}

// .sliverpb.Response Response = 9;
inline bool RPortfwd::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool RPortfwd::has_response() const {
  return _internal_has_response();
}
inline const ::sliverpb::Response& RPortfwd::_internal_response() const {
  const ::sliverpb::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Response&>(
      ::sliverpb::_Response_default_instance_);
}
inline const ::sliverpb::Response& RPortfwd::response() const {
  // @@protoc_insertion_point(field_get:sliverpb.RPortfwd.Response)
  return _internal_response();
}
inline void RPortfwd::unsafe_arena_set_allocated_response(
    ::sliverpb::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RPortfwd.Response)
}
inline ::sliverpb::Response* RPortfwd::release_response() {
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Response* RPortfwd::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:sliverpb.RPortfwd.Response)
  
  ::sliverpb::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::sliverpb::Response* RPortfwd::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::sliverpb::Response* RPortfwd::mutable_response() {
  ::sliverpb::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:sliverpb.RPortfwd.Response)
  return _msg;
}
inline void RPortfwd::set_allocated_response(::sliverpb::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RPortfwd.Response)
}

// -------------------------------------------------------------------

// RPortfwdReq

// uint32 Port = 1;
inline void RPortfwdReq::clear_port() {
  _impl_.port_ = 0u;
}
inline uint32_t RPortfwdReq::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t RPortfwdReq::port() const {
  // @@protoc_insertion_point(field_get:sliverpb.RPortfwdReq.Port)
  return _internal_port();
}
inline void RPortfwdReq::_internal_set_port(uint32_t value) {
  
  _impl_.port_ = value;
}
inline void RPortfwdReq::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:sliverpb.RPortfwdReq.Port)
}

// int32 Protocol = 2;
inline void RPortfwdReq::clear_protocol() {
  _impl_.protocol_ = 0;
}
inline int32_t RPortfwdReq::_internal_protocol() const {
  return _impl_.protocol_;
}
inline int32_t RPortfwdReq::protocol() const {
  // @@protoc_insertion_point(field_get:sliverpb.RPortfwdReq.Protocol)
  return _internal_protocol();
}
inline void RPortfwdReq::_internal_set_protocol(int32_t value) {
  
  _impl_.protocol_ = value;
}
inline void RPortfwdReq::set_protocol(int32_t value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:sliverpb.RPortfwdReq.Protocol)
}

// string Host = 3;
inline void RPortfwdReq::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& RPortfwdReq::host() const {
  // @@protoc_insertion_point(field_get:sliverpb.RPortfwdReq.Host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RPortfwdReq::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.RPortfwdReq.Host)
}
inline std::string* RPortfwdReq::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:sliverpb.RPortfwdReq.Host)
  return _s;
}
inline const std::string& RPortfwdReq::_internal_host() const {
  return _impl_.host_.Get();
}
inline void RPortfwdReq::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* RPortfwdReq::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* RPortfwdReq::release_host() {
  // @@protoc_insertion_point(field_release:sliverpb.RPortfwdReq.Host)
  return _impl_.host_.Release();
}
inline void RPortfwdReq::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RPortfwdReq.Host)
}

// uint64 TunnelID = 8 [jstype = JS_STRING];
inline void RPortfwdReq::clear_tunnelid() {
  _impl_.tunnelid_ = uint64_t{0u};
}
inline uint64_t RPortfwdReq::_internal_tunnelid() const {
  return _impl_.tunnelid_;
}
inline uint64_t RPortfwdReq::tunnelid() const {
  // @@protoc_insertion_point(field_get:sliverpb.RPortfwdReq.TunnelID)
  return _internal_tunnelid();
}
inline void RPortfwdReq::_internal_set_tunnelid(uint64_t value) {
  
  _impl_.tunnelid_ = value;
}
inline void RPortfwdReq::set_tunnelid(uint64_t value) {
  _internal_set_tunnelid(value);
  // @@protoc_insertion_point(field_set:sliverpb.RPortfwdReq.TunnelID)
}

// .sliverpb.Request Request = 9;
inline bool RPortfwdReq::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool RPortfwdReq::has_request() const {
  return _internal_has_request();
}
inline const ::sliverpb::Request& RPortfwdReq::_internal_request() const {
  const ::sliverpb::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::sliverpb::Request&>(
      ::sliverpb::_Request_default_instance_);
}
inline const ::sliverpb::Request& RPortfwdReq::request() const {
  // @@protoc_insertion_point(field_get:sliverpb.RPortfwdReq.Request)
  return _internal_request();
}
inline void RPortfwdReq::unsafe_arena_set_allocated_request(
    ::sliverpb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sliverpb.RPortfwdReq.Request)
}
inline ::sliverpb::Request* RPortfwdReq::release_request() {
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sliverpb::Request* RPortfwdReq::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:sliverpb.RPortfwdReq.Request)
  
  ::sliverpb::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::sliverpb::Request* RPortfwdReq::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::sliverpb::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::sliverpb::Request* RPortfwdReq::mutable_request() {
  ::sliverpb::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:sliverpb.RPortfwdReq.Request)
  return _msg;
}
inline void RPortfwdReq::set_allocated_request(::sliverpb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request));
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:sliverpb.RPortfwdReq.Request)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sliverpb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sliverpb::RegistryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sliverpb::RegistryType>() {
  return ::sliverpb::RegistryType_descriptor();
}
template <> struct is_proto_enum< ::sliverpb::PivotType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sliverpb::PivotType>() {
  return ::sliverpb::PivotType_descriptor();
}
template <> struct is_proto_enum< ::sliverpb::PeerFailureType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sliverpb::PeerFailureType>() {
  return ::sliverpb::PeerFailureType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sliver_2eproto
