// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2eproto;
namespace sliverpb {
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class EnvVar;
struct EnvVarDefaultTypeInternal;
extern EnvVarDefaultTypeInternal _EnvVar_default_instance_;
class File;
struct FileDefaultTypeInternal;
extern FileDefaultTypeInternal _File_default_instance_;
class Process;
struct ProcessDefaultTypeInternal;
extern ProcessDefaultTypeInternal _Process_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
}  // namespace sliverpb
PROTOBUF_NAMESPACE_OPEN
template<> ::sliverpb::Empty* Arena::CreateMaybeMessage<::sliverpb::Empty>(Arena*);
template<> ::sliverpb::EnvVar* Arena::CreateMaybeMessage<::sliverpb::EnvVar>(Arena*);
template<> ::sliverpb::File* Arena::CreateMaybeMessage<::sliverpb::File>(Arena*);
template<> ::sliverpb::Process* Arena::CreateMaybeMessage<::sliverpb::Process>(Arena*);
template<> ::sliverpb::Request* Arena::CreateMaybeMessage<::sliverpb::Request>(Arena*);
template<> ::sliverpb::Response* Arena::CreateMaybeMessage<::sliverpb::Response>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sliverpb {

// ===================================================================

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:sliverpb.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sliverpb.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit PROTOBUF_CONSTEXPR Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Request& from) {
    Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeaconIDFieldNumber = 8,
    kSessionIDFieldNumber = 9,
    kTimeoutFieldNumber = 2,
    kAsyncFieldNumber = 1,
  };
  // string BeaconID = 8;
  void clear_beaconid();
  const std::string& beaconid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_beaconid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_beaconid();
  PROTOBUF_NODISCARD std::string* release_beaconid();
  void set_allocated_beaconid(std::string* beaconid);
  private:
  const std::string& _internal_beaconid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_beaconid(const std::string& value);
  std::string* _internal_mutable_beaconid();
  public:

  // string SessionID = 9;
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // int64 Timeout = 2;
  void clear_timeout();
  int64_t timeout() const;
  void set_timeout(int64_t value);
  private:
  int64_t _internal_timeout() const;
  void _internal_set_timeout(int64_t value);
  public:

  // bool Async = 1;
  void clear_async();
  bool async() const;
  void set_async(bool value);
  private:
  bool _internal_async() const;
  void _internal_set_async(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr beaconid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
    int64_t timeout_;
    bool async_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit PROTOBUF_CONSTEXPR Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Response& from) {
    Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 1,
    kBeaconIDFieldNumber = 8,
    kTaskIDFieldNumber = 9,
    kAsyncFieldNumber = 2,
  };
  // string Err = 1;
  void clear_err();
  const std::string& err() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err();
  PROTOBUF_NODISCARD std::string* release_err();
  void set_allocated_err(std::string* err);
  private:
  const std::string& _internal_err() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err(const std::string& value);
  std::string* _internal_mutable_err();
  public:

  // string BeaconID = 8;
  void clear_beaconid();
  const std::string& beaconid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_beaconid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_beaconid();
  PROTOBUF_NODISCARD std::string* release_beaconid();
  void set_allocated_beaconid(std::string* beaconid);
  private:
  const std::string& _internal_beaconid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_beaconid(const std::string& value);
  std::string* _internal_mutable_beaconid();
  public:

  // string TaskID = 9;
  void clear_taskid();
  const std::string& taskid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_taskid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_taskid();
  PROTOBUF_NODISCARD std::string* release_taskid();
  void set_allocated_taskid(std::string* taskid);
  private:
  const std::string& _internal_taskid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskid(const std::string& value);
  std::string* _internal_mutable_taskid();
  public:

  // bool Async = 2;
  void clear_async();
  bool async() const;
  void set_async(bool value);
  private:
  bool _internal_async() const;
  void _internal_set_async(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr beaconid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taskid_;
    bool async_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class File final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.File) */ {
 public:
  inline File() : File(nullptr) {}
  ~File() override;
  explicit PROTOBUF_CONSTEXPR File(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  File(const File& from);
  File(File&& from) noexcept
    : File() {
    *this = ::std::move(from);
  }

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  inline File& operator=(File&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const File& default_instance() {
    return *internal_default_instance();
  }
  static inline const File* internal_default_instance() {
    return reinterpret_cast<const File*>(
               &_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(File& a, File& b) {
    a.Swap(&b);
  }
  inline void Swap(File* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(File* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  File* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<File>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const File& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const File& from) {
    File::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(File* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.File";
  }
  protected:
  explicit File(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes Data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.File)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Process final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.Process) */ {
 public:
  inline Process() : Process(nullptr) {}
  ~Process() override;
  explicit PROTOBUF_CONSTEXPR Process(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Process(const Process& from);
  Process(Process&& from) noexcept
    : Process() {
    *this = ::std::move(from);
  }

  inline Process& operator=(const Process& from) {
    CopyFrom(from);
    return *this;
  }
  inline Process& operator=(Process&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Process& default_instance() {
    return *internal_default_instance();
  }
  static inline const Process* internal_default_instance() {
    return reinterpret_cast<const Process*>(
               &_Process_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Process& a, Process& b) {
    a.Swap(&b);
  }
  inline void Swap(Process* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Process* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Process* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Process>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Process& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Process& from) {
    Process::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Process* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.Process";
  }
  protected:
  explicit Process(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmdLineFieldNumber = 6,
    kExecutableFieldNumber = 3,
    kOwnerFieldNumber = 4,
    kArchitectureFieldNumber = 7,
    kPidFieldNumber = 1,
    kPpidFieldNumber = 2,
    kSessionIDFieldNumber = 5,
  };
  // repeated string CmdLine = 6;
  int cmdline_size() const;
  private:
  int _internal_cmdline_size() const;
  public:
  void clear_cmdline();
  const std::string& cmdline(int index) const;
  std::string* mutable_cmdline(int index);
  void set_cmdline(int index, const std::string& value);
  void set_cmdline(int index, std::string&& value);
  void set_cmdline(int index, const char* value);
  void set_cmdline(int index, const char* value, size_t size);
  std::string* add_cmdline();
  void add_cmdline(const std::string& value);
  void add_cmdline(std::string&& value);
  void add_cmdline(const char* value);
  void add_cmdline(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& cmdline() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_cmdline();
  private:
  const std::string& _internal_cmdline(int index) const;
  std::string* _internal_add_cmdline();
  public:

  // string Executable = 3;
  void clear_executable();
  const std::string& executable() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_executable(ArgT0&& arg0, ArgT... args);
  std::string* mutable_executable();
  PROTOBUF_NODISCARD std::string* release_executable();
  void set_allocated_executable(std::string* executable);
  private:
  const std::string& _internal_executable() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_executable(const std::string& value);
  std::string* _internal_mutable_executable();
  public:

  // string Owner = 4;
  void clear_owner();
  const std::string& owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // string Architecture = 7;
  void clear_architecture();
  const std::string& architecture() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_architecture(ArgT0&& arg0, ArgT... args);
  std::string* mutable_architecture();
  PROTOBUF_NODISCARD std::string* release_architecture();
  void set_allocated_architecture(std::string* architecture);
  private:
  const std::string& _internal_architecture() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_architecture(const std::string& value);
  std::string* _internal_mutable_architecture();
  public:

  // int32 Pid = 1;
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // int32 Ppid = 2;
  void clear_ppid();
  int32_t ppid() const;
  void set_ppid(int32_t value);
  private:
  int32_t _internal_ppid() const;
  void _internal_set_ppid(int32_t value);
  public:

  // int32 SessionID = 5;
  void clear_sessionid();
  int32_t sessionid() const;
  void set_sessionid(int32_t value);
  private:
  int32_t _internal_sessionid() const;
  void _internal_set_sessionid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.Process)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> cmdline_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr executable_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr architecture_;
    int32_t pid_;
    int32_t ppid_;
    int32_t sessionid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class EnvVar final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sliverpb.EnvVar) */ {
 public:
  inline EnvVar() : EnvVar(nullptr) {}
  ~EnvVar() override;
  explicit PROTOBUF_CONSTEXPR EnvVar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnvVar(const EnvVar& from);
  EnvVar(EnvVar&& from) noexcept
    : EnvVar() {
    *this = ::std::move(from);
  }

  inline EnvVar& operator=(const EnvVar& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnvVar& operator=(EnvVar&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnvVar& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnvVar* internal_default_instance() {
    return reinterpret_cast<const EnvVar*>(
               &_EnvVar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EnvVar& a, EnvVar& b) {
    a.Swap(&b);
  }
  inline void Swap(EnvVar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnvVar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnvVar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnvVar>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnvVar& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnvVar& from) {
    EnvVar::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnvVar* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sliverpb.EnvVar";
  }
  protected:
  explicit EnvVar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string Key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string Value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:sliverpb.EnvVar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Empty

// -------------------------------------------------------------------

// Request

// bool Async = 1;
inline void Request::clear_async() {
  _impl_.async_ = false;
}
inline bool Request::_internal_async() const {
  return _impl_.async_;
}
inline bool Request::async() const {
  // @@protoc_insertion_point(field_get:sliverpb.Request.Async)
  return _internal_async();
}
inline void Request::_internal_set_async(bool value) {
  
  _impl_.async_ = value;
}
inline void Request::set_async(bool value) {
  _internal_set_async(value);
  // @@protoc_insertion_point(field_set:sliverpb.Request.Async)
}

// int64 Timeout = 2;
inline void Request::clear_timeout() {
  _impl_.timeout_ = int64_t{0};
}
inline int64_t Request::_internal_timeout() const {
  return _impl_.timeout_;
}
inline int64_t Request::timeout() const {
  // @@protoc_insertion_point(field_get:sliverpb.Request.Timeout)
  return _internal_timeout();
}
inline void Request::_internal_set_timeout(int64_t value) {
  
  _impl_.timeout_ = value;
}
inline void Request::set_timeout(int64_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:sliverpb.Request.Timeout)
}

// string BeaconID = 8;
inline void Request::clear_beaconid() {
  _impl_.beaconid_.ClearToEmpty();
}
inline const std::string& Request::beaconid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Request.BeaconID)
  return _internal_beaconid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_beaconid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.beaconid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Request.BeaconID)
}
inline std::string* Request::mutable_beaconid() {
  std::string* _s = _internal_mutable_beaconid();
  // @@protoc_insertion_point(field_mutable:sliverpb.Request.BeaconID)
  return _s;
}
inline const std::string& Request::_internal_beaconid() const {
  return _impl_.beaconid_.Get();
}
inline void Request::_internal_set_beaconid(const std::string& value) {
  
  _impl_.beaconid_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_beaconid() {
  
  return _impl_.beaconid_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_beaconid() {
  // @@protoc_insertion_point(field_release:sliverpb.Request.BeaconID)
  return _impl_.beaconid_.Release();
}
inline void Request::set_allocated_beaconid(std::string* beaconid) {
  if (beaconid != nullptr) {
    
  } else {
    
  }
  _impl_.beaconid_.SetAllocated(beaconid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.beaconid_.IsDefault()) {
    _impl_.beaconid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Request.BeaconID)
}

// string SessionID = 9;
inline void Request::clear_sessionid() {
  _impl_.sessionid_.ClearToEmpty();
}
inline const std::string& Request::sessionid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Request.SessionID)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_sessionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sessionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Request.SessionID)
}
inline std::string* Request::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:sliverpb.Request.SessionID)
  return _s;
}
inline const std::string& Request::_internal_sessionid() const {
  return _impl_.sessionid_.Get();
}
inline void Request::_internal_set_sessionid(const std::string& value) {
  
  _impl_.sessionid_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_sessionid() {
  
  return _impl_.sessionid_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_sessionid() {
  // @@protoc_insertion_point(field_release:sliverpb.Request.SessionID)
  return _impl_.sessionid_.Release();
}
inline void Request::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  _impl_.sessionid_.SetAllocated(sessionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sessionid_.IsDefault()) {
    _impl_.sessionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Request.SessionID)
}

// -------------------------------------------------------------------

// Response

// string Err = 1;
inline void Response::clear_err() {
  _impl_.err_.ClearToEmpty();
}
inline const std::string& Response::err() const {
  // @@protoc_insertion_point(field_get:sliverpb.Response.Err)
  return _internal_err();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Response::set_err(ArgT0&& arg0, ArgT... args) {
 
 _impl_.err_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Response.Err)
}
inline std::string* Response::mutable_err() {
  std::string* _s = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:sliverpb.Response.Err)
  return _s;
}
inline const std::string& Response::_internal_err() const {
  return _impl_.err_.Get();
}
inline void Response::_internal_set_err(const std::string& value) {
  
  _impl_.err_.Set(value, GetArenaForAllocation());
}
inline std::string* Response::_internal_mutable_err() {
  
  return _impl_.err_.Mutable(GetArenaForAllocation());
}
inline std::string* Response::release_err() {
  // @@protoc_insertion_point(field_release:sliverpb.Response.Err)
  return _impl_.err_.Release();
}
inline void Response::set_allocated_err(std::string* err) {
  if (err != nullptr) {
    
  } else {
    
  }
  _impl_.err_.SetAllocated(err, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.err_.IsDefault()) {
    _impl_.err_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Response.Err)
}

// bool Async = 2;
inline void Response::clear_async() {
  _impl_.async_ = false;
}
inline bool Response::_internal_async() const {
  return _impl_.async_;
}
inline bool Response::async() const {
  // @@protoc_insertion_point(field_get:sliverpb.Response.Async)
  return _internal_async();
}
inline void Response::_internal_set_async(bool value) {
  
  _impl_.async_ = value;
}
inline void Response::set_async(bool value) {
  _internal_set_async(value);
  // @@protoc_insertion_point(field_set:sliverpb.Response.Async)
}

// string BeaconID = 8;
inline void Response::clear_beaconid() {
  _impl_.beaconid_.ClearToEmpty();
}
inline const std::string& Response::beaconid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Response.BeaconID)
  return _internal_beaconid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Response::set_beaconid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.beaconid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Response.BeaconID)
}
inline std::string* Response::mutable_beaconid() {
  std::string* _s = _internal_mutable_beaconid();
  // @@protoc_insertion_point(field_mutable:sliverpb.Response.BeaconID)
  return _s;
}
inline const std::string& Response::_internal_beaconid() const {
  return _impl_.beaconid_.Get();
}
inline void Response::_internal_set_beaconid(const std::string& value) {
  
  _impl_.beaconid_.Set(value, GetArenaForAllocation());
}
inline std::string* Response::_internal_mutable_beaconid() {
  
  return _impl_.beaconid_.Mutable(GetArenaForAllocation());
}
inline std::string* Response::release_beaconid() {
  // @@protoc_insertion_point(field_release:sliverpb.Response.BeaconID)
  return _impl_.beaconid_.Release();
}
inline void Response::set_allocated_beaconid(std::string* beaconid) {
  if (beaconid != nullptr) {
    
  } else {
    
  }
  _impl_.beaconid_.SetAllocated(beaconid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.beaconid_.IsDefault()) {
    _impl_.beaconid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Response.BeaconID)
}

// string TaskID = 9;
inline void Response::clear_taskid() {
  _impl_.taskid_.ClearToEmpty();
}
inline const std::string& Response::taskid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Response.TaskID)
  return _internal_taskid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Response::set_taskid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.taskid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Response.TaskID)
}
inline std::string* Response::mutable_taskid() {
  std::string* _s = _internal_mutable_taskid();
  // @@protoc_insertion_point(field_mutable:sliverpb.Response.TaskID)
  return _s;
}
inline const std::string& Response::_internal_taskid() const {
  return _impl_.taskid_.Get();
}
inline void Response::_internal_set_taskid(const std::string& value) {
  
  _impl_.taskid_.Set(value, GetArenaForAllocation());
}
inline std::string* Response::_internal_mutable_taskid() {
  
  return _impl_.taskid_.Mutable(GetArenaForAllocation());
}
inline std::string* Response::release_taskid() {
  // @@protoc_insertion_point(field_release:sliverpb.Response.TaskID)
  return _impl_.taskid_.Release();
}
inline void Response::set_allocated_taskid(std::string* taskid) {
  if (taskid != nullptr) {
    
  } else {
    
  }
  _impl_.taskid_.SetAllocated(taskid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.taskid_.IsDefault()) {
    _impl_.taskid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Response.TaskID)
}

// -------------------------------------------------------------------

// File

// string Name = 1;
inline void File::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& File::name() const {
  // @@protoc_insertion_point(field_get:sliverpb.File.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.File.Name)
}
inline std::string* File::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sliverpb.File.Name)
  return _s;
}
inline const std::string& File::_internal_name() const {
  return _impl_.name_.Get();
}
inline void File::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_name() {
  // @@protoc_insertion_point(field_release:sliverpb.File.Name)
  return _impl_.name_.Release();
}
inline void File::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.File.Name)
}

// bytes Data = 2;
inline void File::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& File::data() const {
  // @@protoc_insertion_point(field_get:sliverpb.File.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.File.Data)
}
inline std::string* File::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:sliverpb.File.Data)
  return _s;
}
inline const std::string& File::_internal_data() const {
  return _impl_.data_.Get();
}
inline void File::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_data() {
  // @@protoc_insertion_point(field_release:sliverpb.File.Data)
  return _impl_.data_.Release();
}
inline void File::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.File.Data)
}

// -------------------------------------------------------------------

// Process

// int32 Pid = 1;
inline void Process::clear_pid() {
  _impl_.pid_ = 0;
}
inline int32_t Process::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t Process::pid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Process.Pid)
  return _internal_pid();
}
inline void Process::_internal_set_pid(int32_t value) {
  
  _impl_.pid_ = value;
}
inline void Process::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:sliverpb.Process.Pid)
}

// int32 Ppid = 2;
inline void Process::clear_ppid() {
  _impl_.ppid_ = 0;
}
inline int32_t Process::_internal_ppid() const {
  return _impl_.ppid_;
}
inline int32_t Process::ppid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Process.Ppid)
  return _internal_ppid();
}
inline void Process::_internal_set_ppid(int32_t value) {
  
  _impl_.ppid_ = value;
}
inline void Process::set_ppid(int32_t value) {
  _internal_set_ppid(value);
  // @@protoc_insertion_point(field_set:sliverpb.Process.Ppid)
}

// string Executable = 3;
inline void Process::clear_executable() {
  _impl_.executable_.ClearToEmpty();
}
inline const std::string& Process::executable() const {
  // @@protoc_insertion_point(field_get:sliverpb.Process.Executable)
  return _internal_executable();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Process::set_executable(ArgT0&& arg0, ArgT... args) {
 
 _impl_.executable_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Process.Executable)
}
inline std::string* Process::mutable_executable() {
  std::string* _s = _internal_mutable_executable();
  // @@protoc_insertion_point(field_mutable:sliverpb.Process.Executable)
  return _s;
}
inline const std::string& Process::_internal_executable() const {
  return _impl_.executable_.Get();
}
inline void Process::_internal_set_executable(const std::string& value) {
  
  _impl_.executable_.Set(value, GetArenaForAllocation());
}
inline std::string* Process::_internal_mutable_executable() {
  
  return _impl_.executable_.Mutable(GetArenaForAllocation());
}
inline std::string* Process::release_executable() {
  // @@protoc_insertion_point(field_release:sliverpb.Process.Executable)
  return _impl_.executable_.Release();
}
inline void Process::set_allocated_executable(std::string* executable) {
  if (executable != nullptr) {
    
  } else {
    
  }
  _impl_.executable_.SetAllocated(executable, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.executable_.IsDefault()) {
    _impl_.executable_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Process.Executable)
}

// string Owner = 4;
inline void Process::clear_owner() {
  _impl_.owner_.ClearToEmpty();
}
inline const std::string& Process::owner() const {
  // @@protoc_insertion_point(field_get:sliverpb.Process.Owner)
  return _internal_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Process::set_owner(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Process.Owner)
}
inline std::string* Process::mutable_owner() {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:sliverpb.Process.Owner)
  return _s;
}
inline const std::string& Process::_internal_owner() const {
  return _impl_.owner_.Get();
}
inline void Process::_internal_set_owner(const std::string& value) {
  
  _impl_.owner_.Set(value, GetArenaForAllocation());
}
inline std::string* Process::_internal_mutable_owner() {
  
  return _impl_.owner_.Mutable(GetArenaForAllocation());
}
inline std::string* Process::release_owner() {
  // @@protoc_insertion_point(field_release:sliverpb.Process.Owner)
  return _impl_.owner_.Release();
}
inline void Process::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  _impl_.owner_.SetAllocated(owner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_.IsDefault()) {
    _impl_.owner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Process.Owner)
}

// string Architecture = 7;
inline void Process::clear_architecture() {
  _impl_.architecture_.ClearToEmpty();
}
inline const std::string& Process::architecture() const {
  // @@protoc_insertion_point(field_get:sliverpb.Process.Architecture)
  return _internal_architecture();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Process::set_architecture(ArgT0&& arg0, ArgT... args) {
 
 _impl_.architecture_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.Process.Architecture)
}
inline std::string* Process::mutable_architecture() {
  std::string* _s = _internal_mutable_architecture();
  // @@protoc_insertion_point(field_mutable:sliverpb.Process.Architecture)
  return _s;
}
inline const std::string& Process::_internal_architecture() const {
  return _impl_.architecture_.Get();
}
inline void Process::_internal_set_architecture(const std::string& value) {
  
  _impl_.architecture_.Set(value, GetArenaForAllocation());
}
inline std::string* Process::_internal_mutable_architecture() {
  
  return _impl_.architecture_.Mutable(GetArenaForAllocation());
}
inline std::string* Process::release_architecture() {
  // @@protoc_insertion_point(field_release:sliverpb.Process.Architecture)
  return _impl_.architecture_.Release();
}
inline void Process::set_allocated_architecture(std::string* architecture) {
  if (architecture != nullptr) {
    
  } else {
    
  }
  _impl_.architecture_.SetAllocated(architecture, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.architecture_.IsDefault()) {
    _impl_.architecture_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.Process.Architecture)
}

// int32 SessionID = 5;
inline void Process::clear_sessionid() {
  _impl_.sessionid_ = 0;
}
inline int32_t Process::_internal_sessionid() const {
  return _impl_.sessionid_;
}
inline int32_t Process::sessionid() const {
  // @@protoc_insertion_point(field_get:sliverpb.Process.SessionID)
  return _internal_sessionid();
}
inline void Process::_internal_set_sessionid(int32_t value) {
  
  _impl_.sessionid_ = value;
}
inline void Process::set_sessionid(int32_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:sliverpb.Process.SessionID)
}

// repeated string CmdLine = 6;
inline int Process::_internal_cmdline_size() const {
  return _impl_.cmdline_.size();
}
inline int Process::cmdline_size() const {
  return _internal_cmdline_size();
}
inline void Process::clear_cmdline() {
  _impl_.cmdline_.Clear();
}
inline std::string* Process::add_cmdline() {
  std::string* _s = _internal_add_cmdline();
  // @@protoc_insertion_point(field_add_mutable:sliverpb.Process.CmdLine)
  return _s;
}
inline const std::string& Process::_internal_cmdline(int index) const {
  return _impl_.cmdline_.Get(index);
}
inline const std::string& Process::cmdline(int index) const {
  // @@protoc_insertion_point(field_get:sliverpb.Process.CmdLine)
  return _internal_cmdline(index);
}
inline std::string* Process::mutable_cmdline(int index) {
  // @@protoc_insertion_point(field_mutable:sliverpb.Process.CmdLine)
  return _impl_.cmdline_.Mutable(index);
}
inline void Process::set_cmdline(int index, const std::string& value) {
  _impl_.cmdline_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sliverpb.Process.CmdLine)
}
inline void Process::set_cmdline(int index, std::string&& value) {
  _impl_.cmdline_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sliverpb.Process.CmdLine)
}
inline void Process::set_cmdline(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.cmdline_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sliverpb.Process.CmdLine)
}
inline void Process::set_cmdline(int index, const char* value, size_t size) {
  _impl_.cmdline_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sliverpb.Process.CmdLine)
}
inline std::string* Process::_internal_add_cmdline() {
  return _impl_.cmdline_.Add();
}
inline void Process::add_cmdline(const std::string& value) {
  _impl_.cmdline_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sliverpb.Process.CmdLine)
}
inline void Process::add_cmdline(std::string&& value) {
  _impl_.cmdline_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sliverpb.Process.CmdLine)
}
inline void Process::add_cmdline(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.cmdline_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sliverpb.Process.CmdLine)
}
inline void Process::add_cmdline(const char* value, size_t size) {
  _impl_.cmdline_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sliverpb.Process.CmdLine)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Process::cmdline() const {
  // @@protoc_insertion_point(field_list:sliverpb.Process.CmdLine)
  return _impl_.cmdline_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Process::mutable_cmdline() {
  // @@protoc_insertion_point(field_mutable_list:sliverpb.Process.CmdLine)
  return &_impl_.cmdline_;
}

// -------------------------------------------------------------------

// EnvVar

// string Key = 1;
inline void EnvVar::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& EnvVar::key() const {
  // @@protoc_insertion_point(field_get:sliverpb.EnvVar.Key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnvVar::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.EnvVar.Key)
}
inline std::string* EnvVar::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:sliverpb.EnvVar.Key)
  return _s;
}
inline const std::string& EnvVar::_internal_key() const {
  return _impl_.key_.Get();
}
inline void EnvVar::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* EnvVar::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* EnvVar::release_key() {
  // @@protoc_insertion_point(field_release:sliverpb.EnvVar.Key)
  return _impl_.key_.Release();
}
inline void EnvVar::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.EnvVar.Key)
}

// string Value = 2;
inline void EnvVar::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& EnvVar::value() const {
  // @@protoc_insertion_point(field_get:sliverpb.EnvVar.Value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnvVar::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sliverpb.EnvVar.Value)
}
inline std::string* EnvVar::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:sliverpb.EnvVar.Value)
  return _s;
}
inline const std::string& EnvVar::_internal_value() const {
  return _impl_.value_.Get();
}
inline void EnvVar::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* EnvVar::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* EnvVar::release_value() {
  // @@protoc_insertion_point(field_release:sliverpb.EnvVar.Value)
  return _impl_.value_.Release();
}
inline void EnvVar::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sliverpb.EnvVar.Value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sliverpb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_2eproto
